

--- START OF FILE: ./test_general_agent.py ---
"""
General Agent Test
"""

import asyncio
from app.agents.general_agent import GeneralAgent

async def test_general_agent():
    """Test general agent."""

    agent = GeneralAgent()

    # Test FAQ queries
    faq_queries = [
        "How do I open an account?",
        "What are your fees?",
        "Is my money safe?",
        "How do I contact support?",
        "What interest rates do you offer?",
    ]

    # Test general queries
    general_queries = [
        "Tell me about your mortgage options",
        "Do you have any special promotions?",
        "How long does transfers take?",
    ]

    print("="*60)
    print("FAQ MATCHING TESTS")
    print("="*60)

    for query in faq_queries:
        print(f"\nQuery: {query}")
        response = await agent.process({"message": query})
        print(f"Source: {response.metadata.get('source')}")
        print(f"Response preview: {response.content[:100]}...")

    print("\n" + "="*60)
    print("GENERAL QUERY TESTS (LLM-based)")
    print("="*60)

    for query in general_queries:
        print(f"\nQuery: {query}")
        response = await agent.process({"message": query})
        print(f"Source: {response.metadata.get('source')}")
        print(f"Response preview: {response.content[:100]}...")

if __name__ == "__main__":
    asyncio.run(test_general_agent())


--- START OF FILE: ./test_product_recommender.py ---
import asyncio
from app.agents.product_recommender import ProductRecommenderAgent

async def test_recommender():
    # Create agent
    agent = ProductRecommenderAgent()

    # Test scenarios
    scenarios = [
        {
            "input": {
                "intent": "loan_inquiry",
                "message": "I'm a first-time buyer looking for a mortgage"
            },
            "context": {
                "customer": {"is_vip": False}
            }
        },
        {
            "input": {
                "intent": "savings_inquiry",
                "message": "I want to save for a house deposit over 3 years"
            },
            "context": {
                "customer": {"is_vip": True}
            }
        },
    ]

    for i, scenario in enumerate(scenarios, 1):
        print(f"\n{'='*60}")
        print(f"Scenario {i}")
        print(f"{'='*60}")
        print(f"Intent: {scenario['input']['intent']}")
        print(f"Message: {scenario['input']['message']}")
        print(f"VIP: {scenario['context']['customer']['is_vip']}")

        response = await agent.process(
            scenario["input"],
            scenario["context"]
        )

        print(f"\nResponse:\n{response.content}")
        print(f"\nConfidence: {response.confidence}")
        print(f"Products: {[p['name'] for p in response.metadata['products']]}")

if __name__ == "__main__":
    asyncio.run(test_recommender())


--- START OF FILE: ./test_human_agent.py ---
"""
Human Agent Test
"""

import asyncio
from app.agents.human_agent import HumanAgent

async def test_human_agent():
    """Test human agent."""

    agent = HumanAgent()

    # Test escalation scenarios
    test_cases = [
        {
            "message": "My card was stolen and I need immediate help!",
            "expected_priority": "urgent",
        },
        {
            "message": "I'm not happy with your service. I want to lodge a complaint.",
            "expected_priority": "high",
        },
        {
            "message": "I'd like to speak to someone about changing my account type.",
            "expected_priority": "medium",
        },
        {
            "message": "Can someone help me with my account?",
            "expected_priority": "low",
        },
    ]

    print("="*60)
    print("ESCALATION TESTS")
    print("="*60)

    for case in test_cases:
        print(f"\nMessage: {case['message']}")
        print(f"Expected Priority: {case['expected_priority'].upper()}")

        response = await agent.process({
            "message": case["message"],
            "customer_id": 1,
            "conversation_id": 1,
        })

        actual_priority = response.metadata.get("priority")
        print(f"Actual Priority: {actual_priority.upper()}")
        print(f"Escalation ID: {response.metadata.get('escalation_id')}")
        print(f"Response Preview: {response.content[:80]}...")

if __name__ == "__main__":
    asyncio.run(test_human_agent())


--- START OF FILE: ./com31.py ---
from app.database import AsyncSessionLocal
from app.repositories import CustomerRepository

# Create session and repository
async def test():
    async with AsyncSessionLocal() as session:
        repo = CustomerRepository(session)

        # Create customer
        data = {
            "customer_id": "CUST-001",
            "first_name": "John",
            "last_name": "Smith",
            "email": "john@example.com"
        }
        customer = await repo.create(data)
        await session.commit()

        print(f"Created: {customer}")
        print(f"ID: {customer.id}")

        # Get by email
        found = await repo.get_by_email("john@example.com")
        print(f"Found: {found}")

import asyncio
asyncio.run(test())


--- START OF FILE: ./test_coordinator.py ---
"""
Agent Coordinator Test
"""

import asyncio
from app.coordinator.agent_coordinator import AgentCoordinator

async def test_coordinator():
    """Test agent coordinator."""

    coordinator = AgentCoordinator()

    print("\n" + "="*60)
    print("AGENT COORDINATOR TEST")
    print("="*60)

    # Simulate multi-turn conversation
    conversations = [
        {
            "conv_id": 1,
            "customer_id": 101,
            "messages": [
                "What's my account balance?",
                "Show me recent transactions",
                "I need a statement",
            ]
        },
        {
            "conv_id": 2,
            "customer_id": 102,
            "messages": [
                "How do I open an account?",
                "What fees do you charge?",
            ]
        },
        {
            "conv_id": 3,
            "customer_id": 103,
            "messages": [
                "I'm not happy with your service!",
                "I want to escalate this issue",
            ]
        },
    ]

    # Process conversations
    for conv_data in conversations:
        conv_id = conv_data["conv_id"]
        customer_id = conv_data["customer_id"]

        print(f"\n--- Conversation {conv_id} (Customer {customer_id}) ---")

        for msg in conv_data["messages"]:
            response = await coordinator.process_message(
                message=msg,
                customer_id=customer_id,
                conversation_id=conv_id,
            )

            print(f"\nMessage: {msg}")
            print(f"Agent: {response['agent']}")
            print(f"Intent: {response['intent']}")
            print(f"Turn: {response['turn_count']}")
            if response.get('escalation_id'):
                print(f"⚠️ Escalated: {response['escalation_id']}")

    # Print statistics
    print("\n" + "="*60)
    print("STATISTICS")
    print("="*60)
    stats = coordinator.get_statistics()
    print(f"Total Conversations: {stats['total_conversations']}")
    print(f"Total Messages: {stats['total_messages']}")
    print(f"Escalated: {stats['escalated_conversations']}")
    print(f"Avg Messages/Conversation: {stats['avg_messages_per_conversation']:.1f}")
    print("\nAgent Distribution:")
    for agent, count in stats['agent_distribution'].items():
        print(f"  {agent}: {count}")
    print("\nIntent Distribution:")
    for intent, count in stats['intent_distribution'].items():
        print(f"  {intent}: {count}")

    # Get conversation history
    print("\n" + "="*60)
    print("CONVERSATION HISTORY (Conv 1)")
    print("="*60)
    history = coordinator.get_conversation_history(1)
    for i, turn in enumerate(history, 1):
        print(f"\nTurn {i}:")
        print(f"  User: {turn['message']}")
        print(f"  Agent: {turn['agent']}")
        print(f"  Intent: {turn['intent']}")

if __name__ == "__main__":
    asyncio.run(test_coordinator())


--- START OF FILE: ./test_account_agent.py ---
import asyncio
from app.agents.account_agent import AccountAgent

async def test_account_agent():
    agent = AccountAgent()

    test_messages = [
        "What's my account balance?",
        "Show me my recent transactions",
        "I need a statement",
        "Tell me about my account",
    ]

    for message in test_messages:
        print("\n" + "="*60)
        print(f"Query: {message}")
        print("="*60)

        response = await agent.process(
            {
                "customer_id": 1,
                "message": message,
            },
            context=None,  # no services needed
        )

        print(f"Response: {response.content}")
        print(f"Query Type: {response.metadata.get('query_type')}")

if __name__ == "__main__":
    asyncio.run(test_account_agent())


--- START OF FILE: ./com50.py ---
import asyncio

from app.database import AsyncSessionLocal
from app.services.account_service import AccountService
from app.services.customer import CustomerService
from app.services.transaction_service import TransactionService
from app.services.product_service import ProductService
from app.services.conversation import ConversationService  # if this exists in your project

from app.agents.account_agent import AccountAgent
from app.agents.product_recommender import ProductRecommenderAgent
from app.agents.general_agent import GeneralAgent
from app.agents.human_agent import HumanAgent


async def main():
    async with AsyncSessionLocal() as session:
        # DB-backed services
        account_svc = AccountService(db=session)
        customer_svc = CustomerService(db=session)
        txn_svc = TransactionService(db=session)
        product_svc = ProductService(db=session)

        # Agents
        account_agent = AccountAgent(
            account_service=account_svc,
            customer_service=customer_svc,
            transaction_service=txn_svc,
        )

        product_agent = ProductRecommenderAgent(product_service=product_svc)  # requires injection [file:243]

        # For a true DB test, update GeneralAgent to accept injected ProductService (recommended)
        general_agent = GeneralAgent(product_service=product_svc)  # only works if you implement injection [file:245]

        human_agent = HumanAgent(conversation_service=ConversationService(db=session))  # if your ConversationService supports db

        customer_id = 2210
        conversation_id = 1

        print("\n--- AccountAgent (balance) ---")
        print((await account_agent.process({"customer_id": customer_id, "message": "What is my balance?"})).to_dict())

        print("\n--- AccountAgent (transactions) ---")
        print((await account_agent.process({"customer_id": customer_id, "message": "Show my recent transactions"})).to_dict())

        print("\n--- ProductRecommenderAgent (DB products + LLM) ---")
        # Note: this will also call Groq; if you want DB-only, modify ProductRecommenderAgent to fetch products from product_svc
        print((await product_agent.process({"customer_id": customer_id, "message": "I want a credit card"})).to_dict())

        print("\n--- GeneralAgent (should hit FAQ, not DB unless you add DB usage) ---")
        print((await general_agent.process({"message": "What are your fees?"})).to_dict())

        print("\n--- HumanAgent escalation (DB only if ConversationService saves) ---")
        ctx = {"conversation_service": human_agent.conversation_service}
        print((await human_agent.process(
            {"message": "I want to make a complaint", "customer_id": customer_id, "conversation_id": conversation_id},
            context=ctx,
        )).to_dict())

if __name__ == "__main__":
    asyncio.run(main())


--- START OF FILE: ./test_intent.py ---
import asyncio
from app.agents.intent_classifier import IntentClassifierAgent

async def test_classifier():
    # Create agent
    agent = IntentClassifierAgent()

    # Test messages
    messages = [
        "I want to apply for a mortgage",
        "What is my account balance?",
        "I'm not happy with the service",
        "Hello, can you help me?",
    ]

    for msg in messages:
        print(f"\nMessage: {msg}")

        response = await agent.process({"message": msg})

        print(f"Intent: {response.metadata['intent']}")
        print(f"Confidence: {response.confidence}")
        print(f"Sentiment: {response.metadata['sentiment']}")
        print(f"Routing: {response.metadata['routing']}")
        print(f"Explanation: {response.metadata['explanation']}")

if __name__ == "__main__":
    asyncio.run(test_classifier())


--- START OF FILE: ./test_workflow.py ---
"""
Message Workflow Test
"""

import asyncio
from app.workflows.message_workflow import MessageWorkflow

async def test_workflow():
    """Test message workflow."""

    workflow = MessageWorkflow()

    # Print workflow info
    print("\n" + "="*60)
    print("WORKFLOW STRUCTURE")
    print("="*60)
    info = workflow.get_workflow_info()
    for line in info["flow"]:
        print(line)

    # Test scenarios
    test_cases = [
        {
            "message": "i want a credit card?",
            "expected_agent": "account",
        },
        {
            "message": "i want a mortgage?",
            "expected_agent": "general",
        },
        {
            "message": "I'm not happy with your service!",
            "expected_agent": "human",
        },
    ]

    for case in test_cases:
        print("\n" + "="*60)
        print(f"Test: {case['message']}")
        print("="*60)

        response = await workflow.process_message(
            message=case["message"],
            customer_id=1,
            conversation_id=1,
        )

        print(f"Agent: {response.get('agent')}")
        print(f"Intent: {response.get('intent')}")
        print(f"Confidence: {response.get('confidence'):.2f}")
        print(f"\nResponse:\n{response.get('message')[:150]}...")

if __name__ == "__main__":
    asyncio.run(test_workflow())


--- START OF FILE: ./com32.py ---
from app.services import CustomerService, ConversationService
from app.models.conversation import ConversationChannel
import asyncio

async def test():
    # Create customer
    async with CustomerService() as service:
        customer = await service.create_customer(
            customer_id="CUST-002",
            first_name="John",
            last_name="Smith",
            email="john1@example.com"
        )
        print(f"Created customer: {customer.id}")

    # Start conversation
    async with ConversationService() as service:
        conv = await service.start_conversation(
            customer_id=customer.id,
            title="Loan Inquiry",
            channel=ConversationChannel.WEB
        )
        print(f"Started conversation: {conv.id}")

asyncio.run(test())

asyncio.run(test())


--- START OF FILE: ./com36.py ---
from app.agents.base import BaseAgent, AgentConfig, AgentResponse

# Test AgentConfig
config = AgentConfig(temperature=0.5, max_tokens=512)
config.to_dict()
{'model_name': 'mixtral-8x7b-32768', 'temperature': 0.5, 'max_tokens': 512, 'timeout': 30}

# Test AgentResponse
response = AgentResponse(
    content="Test response",
    confidence=0.9,
    agent_name="test_agent"
)
response.to_dict()
{'content': 'Test response', 'metadata': {}, 'confidence': 0.9, }

# Test abstract class (should fail)
try:
    agent = BaseAgent("test")
except TypeError as e:
    print(f"Expected error: {e}")


--- START OF FILE: ./test_api.py ---
"""
Message Router API Test
"""

import asyncio
from fastapi.testclient import TestClient
from app.main import app  # Assuming FastAPI app in app/main.py

def test_message_api():
    """Test message API endpoints."""

    client = TestClient(app)

    print("\n" + "="*60)
    print("MESSAGE ROUTER API TEST")
    print("="*60)

    # Test health check
    print("\n1️⃣ Health Check")
    response = client.get("/api/v1/health")
    print(f"Status: {response.status_code}")
    print(f"Response: {response.json()}")

    # Test message processing
    print("\n2️⃣ Process Message")
    response = client.post(
        "/api/v1/messages/process",
        json={
            "message": "What's my account balance?",
            "customer_id": 101,
            "conversation_id": 1,
        }
    )
    print(f"Status: {response.status_code}")
    result = response.json()
    print(f"Response: {result['response'][:100]}...")
    print(f"Agent: {result['metadata']['agent']}")
    print(f"Intent: {result['metadata']['intent']}")

    # Test conversation history
    print("\n3️⃣ Get Conversation History")
    response = client.get("/api/v1/conversations/1/history")
    if response.status_code == 200:
        print(f"Status: {response.status_code}")
        data = response.json()
        print(f"Conversation: {data['conversation_id']}")
        print(f"Messages: {len(data['history'])}")

    # Test statistics
    print("\n4️⃣ Get Statistics")
    response = client.get("/api/v1/statistics")
    if response.status_code == 200:
        print(f"Status: {response.status_code}")
        stats = response.json()
        print(f"Total Conversations: {stats['total_conversations']}")
        print(f"Total Messages: {stats['total_messages']}")
        print(f"Escalations: {stats['escalated_conversations']}")

if __name__ == "__main__":
    test_message_api()


--- START OF FILE: ./test_compliance.py ---
import asyncio
from app.agents.compliance_checker import ComplianceCheckerAgent

async def test_compliance():
    # Create agent
    agent = ComplianceCheckerAgent()

    # Test scenarios
    scenarios = [
        {
            "name": "Compliant message",
            "content": "Our Fixed Rate Mortgage offers rates from 3.99% APR. "
                      "Subject to status and affordability assessment.",
            "product_type": "loan",
        },
        {
            "name": "Non-compliant (guaranteed)",
            "content": "Guaranteed returns with zero risk! Can't lose!",
            "product_type": "investment",
        },
        {
            "name": "Missing disclaimer",
            "content": "Apply for a credit card today! Low interest rates.",
            "product_type": "credit",
        },
        {
            "name": "Sensitive topic",
            "content": "If you're struggling with debt, we can help.",
            "product_type": "loan",
        },
    ]

    for scenario in scenarios:
        print(f"\n{'='*60}")
        print(f"Test: {scenario['name']}")
        print(f"{'='*60}")
        print(f"Content: {scenario['content']}")
        print(f"Product Type: {scenario['product_type']}")

        response = await agent.process(
            {"content": scenario["content"]},
            {"product_type": scenario["product_type"]}
        )

        print(f"\nResult:\n{response.content}")
        print(f"\nCompliant: {response.metadata['is_compliant']}")

        if response.metadata['issues']:
            print(f"Issues: {response.metadata['issues']}")

        if response.metadata['required_disclaimers']:
            print(f"Required Disclaimers:")
            for disclaimer in response.metadata['required_disclaimers']:
                print(f"  - {disclaimer}")

if __name__ == "__main__":
    asyncio.run(test_compliance())


--- START OF FILE: ./test_db_smoke.py ---
import asyncio
from sqlalchemy import select, func

from app.database import AsyncSessionLocal
from app.models.customer import Customer
from app.models.account import Account
from app.models.transaction import Transaction

from app.services.customer import CustomerService
from app.services.account_service import AccountService
from app.services.transaction_service import TransactionService


async def main():
    async with AsyncSessionLocal() as session:
        # --- Raw DB sanity ---
        cust_count = (await session.execute(select(func.count(Customer.id)))).scalar_one()
        acct_count = (await session.execute(select(func.count(Account.id)))).scalar_one()
        txn_count = (await session.execute(select(func.count(Transaction.id)))).scalar_one()
        print("Counts:", {"customers": cust_count, "accounts": acct_count, "transactions": txn_count})

        # pick a real customer id
        customer_id = (await session.execute(select(Customer.id).order_by(Customer.id).limit(1))).scalar_one()
        print("Using customer_id:", customer_id)

        # --- Service sanity ---
        customer_svc = CustomerService(db=session)
        account_svc = AccountService(db=session)
        txn_svc = TransactionService(db=session)

        customer = await customer_svc.get_customer(customer_id)
        print("Customer exists:", bool(customer), "external_customer_id:", getattr(customer, "customer_id", None))

        external_customer_id = getattr(customer, "customer_id", None)
        accounts = await account_svc.get_accounts_by_customer(external_customer_id)
        print("Accounts found:", len(accounts))

        if accounts:
            acct = accounts[0]
            print("First account:", {"id": acct.id, "account_number": acct.account_number, "type": acct.type})

            # NOTE: your TransactionService expects account_id (despite name)
            txns = await txn_svc.get_transactions_by_customer(acct.id, limit=5)
            print("Recent transactions:", len(txns))

if __name__ == "__main__":
    asyncio.run(main())


--- START OF FILE: ./app/config.py ---
"""
Configuration Management

This module handles all application configuration using Pydantic Settings.
Settings are loaded from environment variables with validation and type checking.
"""

from pydantic_settings import BaseSettings, SettingsConfigDict
from pydantic import Field, field_validator
from typing import List, Literal
import json


class Settings(BaseSettings):
    """
    Application settings loaded from environment variables.

    All settings are loaded from .env file and environment variables.
    Type validation is automatic via Pydantic.
    """

    # ========================================================================
    # APPLICATION SETTINGS
    # ========================================================================

    app_name: str = Field(
        default="FCA Multi-Agent Support System",
        description="Application name",
    )

    app_version: str = Field(
        default="0.1.0",
        description="Application version (semantic versioning)",
    )

    environment: Literal["development", "staging", "production"] = Field(
        default="development",
        description="Current environment",
    )

    debug: bool = Field(
        default=False,
        description="Enable debug mode (detailed errors, API docs)",
    )

    # ========================================================================
    # DATABASE SETTINGS
    # ========================================================================

    database_url: str = Field(
        default="postgresql+asyncpg://fca_user:fca_password@localhost:5432/fca_support",
        description="PostgreSQL connection URL",
    )

    database_echo: bool = Field(
        default=False,
        description="Echo SQL queries to console (debugging)",
    )

    database_pool_size: int = Field(
        default=5,
        ge=1,
        le=20,
        description="Database connection pool size",
    )

    database_max_overflow: int = Field(
        default=10,
        ge=0,
        le=50,
        description="Max connections above pool_size",
    )

    # ========================================================================
    # REDIS SETTINGS
    # ========================================================================

    redis_url: str = Field(
        default="redis://localhost:6379/0",
        description="Redis connection URL",
    )

    redis_enabled: bool = Field(
        default=False,
        description="Enable Redis caching",
    )

    # ========================================================================
    # GROQ AI SETTINGS
    # ========================================================================

    groq_api_key: str = Field(
        default="",
        description="Groq AI API key (required for LLM)",
    )

    groq_model: str = Field(
        default="mixtral-8x7b-32768",
        description="Groq AI model name",
    )

    groq_temperature: float = Field(
        default=0.7,
        ge=0.0,
        le=1.0,
        description="LLM temperature (0=deterministic, 1=creative)",
    )

    groq_max_tokens: int = Field(
        default=1024,
        ge=1,
        le=32768,
        description="Maximum tokens in response",
    )

    groq_timeout: int = Field(
        default=30,
        ge=5,
        le=300,
        description="API request timeout (seconds)",
    )

    # ========================================================================
    # SECURITY SETTINGS
    # ========================================================================

    secret_key: str = Field(
        default="your-secret-key-change-in-production",
        min_length=32,
        description="Secret key for encryption (min 32 chars)",
    )

    cors_origins: List[str] = Field(
        default=["http://localhost:3000", "http://localhost:8000"],
        description="Allowed CORS origins",
    )

    # ========================================================================
    # RATE LIMITING SETTINGS
    # ========================================================================

    rate_limit_calls: int = Field(
        default=10,
        ge=1,
        description="Max requests per period",
    )

    rate_limit_period: int = Field(
        default=60,
        ge=1,
        description="Rate limit period (seconds)",
    )

    # ========================================================================
    # LOGGING SETTINGS
    # ========================================================================

    log_level: Literal["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"] = Field(
        default="INFO",
        description="Minimum log level",
    )

    log_file: str = Field(
        default="logs/app.log",
        description="Log file path",
    )

    log_format: Literal["json", "text"] = Field(
        default="json",
        description="Log output format",
    )

    # ========================================================================
    # REQUEST VALIDATION SETTINGS
    # ========================================================================

    max_body_size: int = Field(
        default=10485760,  # 10 MB
        ge=1024,  # Min 1 KB
        le=52428800,  # Max 50 MB
        description="Maximum request body size (bytes)",
    )

    # ========================================================================
    # PYDANTIC CONFIGURATION
    # ========================================================================

    model_config = SettingsConfigDict(
        env_file=".env",
        env_file_encoding="utf-8",
        case_sensitive=False,  # Environment variables are case-insensitive
        extra="ignore",  # Ignore extra environment variables
    )

    # ========================================================================
    # VALIDATORS
    # ========================================================================

    @field_validator("cors_origins", mode="before")
    @classmethod
    def parse_cors_origins(cls, v):
        """
        Parse CORS origins from JSON string or list.

        Supports both:
        - List: ["http://localhost:3000"]
        - JSON string: '["http://localhost:3000"]'

        Args:
            v: Value to parse

        Returns:
            List[str]: Parsed origins
        """
        if isinstance(v, str):
            try:
                return json.loads(v)
            except json.JSONDecodeError:
                return [v]  # Single origin as string
        return v

    @field_validator("secret_key")
    @classmethod
    def validate_secret_key(cls, v, info):
        """
        Validate secret key in production.

        Ensures secret key is changed from default in production.

        Args:
            v: Secret key value
            info: Validation context

        Returns:
            str: Validated secret key

        Raises:
            ValueError: If using default key in production
        """
        environment = info.data.get("environment", "development")

        if environment == "production" and v == "your-secret-key-change-in-production":
            raise ValueError(
                "CRITICAL SECURITY: Must change SECRET_KEY in production! "
                "Generate with: openssl rand -hex 32"
            )

        return v

    @field_validator("groq_api_key")
    @classmethod
    def validate_groq_key(cls, v, info):
        """
        Warn if Groq API key is missing.

        Note: Doesn't raise error to allow app to start,
        but agents won't work without key.

        Args:
            v: API key value
            info: Validation context

        Returns:
            str: API key
        """
        if not v or v == "":
            print("⚠️  WARNING: GROQ_API_KEY not set. AI agents will not function.")
            print("   Get free API key: https://console.groq.com")

        return v

    # ========================================================================
    # COMPUTED PROPERTIES
    # ========================================================================

    @property
    def is_production(self) -> bool:
        """Check if running in production environment."""
        return self.environment == "production"

    @property
    def is_development(self) -> bool:
        """Check if running in development environment."""
        return self.environment == "development"

    @property
    def database_url_sync(self) -> str:
        """
        Get synchronous database URL (for Alembic migrations).

        Alembic doesn't support asyncpg, so replace with psycopg2.

        Returns:
            str: Synchronous PostgreSQL URL
        """
        return self.database_url.replace("+asyncpg", "")

    def get_log_config(self) -> dict:
        """
        Get logging configuration dictionary.

        Returns:
            dict: Python logging configuration
        """
        return {
            "version": 1,
            "disable_existing_loggers": False,
            "formatters": {
                "default": {
                    "format": "%(asctime)s - %(name)s - %(levelname)s - %(message)s",
                },
                "json": {
                    "()": "pythonjsonlogger.jsonlogger.JsonFormatter",
                    "format": "%(asctime)s %(name)s %(levelname)s %(message)s",
                },
            },
            "handlers": {
                "console": {
                    "class": "logging.StreamHandler",
                    "formatter": "default" if self.log_format == "text" else "json",
                    "stream": "ext://sys.stdout",
                },
                "file": {
                    "class": "logging.handlers.RotatingFileHandler",
                    "formatter": "json",
                    "filename": self.log_file,
                    "maxBytes": 10485760,  # 10 MB
                    "backupCount": 5,
                },
            },
            "root": {
                "level": self.log_level,
                "handlers": ["console", "file"],
            },
        }


# ============================================================================
# SETTINGS INSTANCE
# ============================================================================

# Create global settings instance
# Loaded once at import time
settings = Settings()


# ============================================================================
# SETTINGS DISPLAY (for debugging)
# ============================================================================

def display_settings():
    """
    Display current settings (for debugging).

    Masks sensitive values like API keys and passwords.
    """
    print("=" * 60)
    print("APPLICATION SETTINGS")
    print("=" * 60)

    print(f"\nApplication:")
    print(f"  Name: {settings.app_name}")
    print(f"  Version: {settings.app_version}")
    print(f"  Environment: {settings.environment}")
    print(f"  Debug: {settings.debug}")

    print(f"\nDatabase:")
    # Mask password in URL
    db_url = settings.database_url
    if "@" in db_url:
        parts = db_url.split("@")
        credentials = parts[0].split("://")[1]
        user = credentials.split(":")[0]
        db_url = f"postgresql+asyncpg://{user}:****@{parts[1]}"
    print(f"  URL: {db_url}")
    print(f"  Echo: {settings.database_echo}")
    print(f"  Pool Size: {settings.database_pool_size}")

    print(f"\nRedis:")
    print(f"  URL: {settings.redis_url}")
    print(f"  Enabled: {settings.redis_enabled}")

    print(f"\nGroq AI:")
    # Mask API key
    key_display = f"{settings.groq_api_key[:8]}****" if settings.groq_api_key else "NOT SET"
    print(f"  API Key: {key_display}")
    print(f"  Model: {settings.groq_model}")
    print(f"  Temperature: {settings.groq_temperature}")

    print(f"\nSecurity:")
    print(f"  Secret Key: {'SET' if settings.secret_key else 'NOT SET'}")
    print(f"  CORS Origins: {settings.cors_origins}")

    print(f"\nLogging:")
    print(f"  Level: {settings.log_level}")
    print(f"  File: {settings.log_file}")
    print(f"  Format: {settings.log_format}")

    print("=" * 60)


if __name__ == "__main__":
    # Display settings when run directly
    display_settings()


--- START OF FILE: ./app/database.py ---
"""
Database Connection and Session Management

This module configures SQLAlchemy async engine and provides
database session management for the application.
"""

from sqlalchemy.ext.asyncio import (
    create_async_engine,
    AsyncSession,
    async_sessionmaker,
)
from sqlalchemy.orm import declarative_base
from sqlalchemy.pool import NullPool, QueuePool
from sqlalchemy import  text  # Add 'text' here

from typing import AsyncGenerator
import logging

from app.config import settings

logger = logging.getLogger(__name__)

# ============================================================================
# DATABASE ENGINE
# ============================================================================

# Create async engine
engine = create_async_engine(
    settings.database_url,
    echo=settings.database_echo,  # Log SQL queries (debugging)
    future=True,  # Use SQLAlchemy 2.0 style
    pool_size=settings.database_pool_size,  # Connection pool size
    max_overflow=settings.database_max_overflow,  # Max connections above pool_size
    pool_pre_ping=True,  # Verify connections before using
    pool_recycle=3600,  # Recycle connections after 1 hour
    poolclass=QueuePool if not settings.is_production else QueuePool,
)


# ============================================================================
# SESSION MAKER
# ============================================================================

# Create session factory
AsyncSessionLocal = async_sessionmaker(
    engine,
    class_=AsyncSession,
    expire_on_commit=False,  # Don't expire objects after commit
    autocommit=False,  # Explicit commits only
    autoflush=False,  # Explicit flushes only
)


# ============================================================================
# BASE MODEL
# ============================================================================

# Declarative base for ORM models
Base = declarative_base()


# ============================================================================
# SESSION DEPENDENCY
# ============================================================================

async def get_db() -> AsyncGenerator[AsyncSession, None]:
    """
    Database session dependency for FastAPI.

    Provides a database session for each request and ensures
    proper cleanup after the request completes.

    Yields:
        AsyncSession: Database session

    Example:
        @app.get("/users")
        async def get_users(db: AsyncSession = Depends(get_db)):
            result = await db.execute(select(User))
            return result.scalars().all()
    """
    async with AsyncSessionLocal() as session:
        try:
            yield session
            await session.commit()  # Commit if no exceptions
        except Exception:
            await session.rollback()  # Rollback on error
            raise
        finally:
            await session.close()  # Always close session


# ============================================================================
# DATABASE INITIALIZATION
# ============================================================================

async def init_db() -> None:
    """
    Initialize database tables.

    Creates all tables defined in Base metadata.

    Note: In production, use Alembic migrations instead.
    This is for development/testing only.
    """
    async with engine.begin() as conn:
        # Drop all tables (development only!)
        if settings.is_development:
            logger.warning("Dropping all database tables (development mode)")
            await conn.run_sync(Base.metadata.drop_all)

        # Create all tables
        logger.info("Creating database tables")
        await conn.run_sync(Base.metadata.create_all)
        logger.info("Database tables created successfully")


async def close_db() -> None:
    """
    Close database connections.

    Should be called on application shutdown to properly
    close all database connections.
    """
    logger.info("Closing database connections")
    await engine.dispose()
    logger.info("Database connections closed")


# ============================================================================
# DATABASE HEALTH CHECK
# ============================================================================

async def check_db_connection() -> bool:
    """
    Check if database connection is healthy.

    Returns:
        bool: True if connection successful, False otherwise
    """
    try:
        async with AsyncSessionLocal() as session:
            # Simple query to test connection
            await session.execute(text("SELECT 1"))
            return True
    except Exception as e:
        logger.error(f"Database connection check failed: {e}")
        return False


# ============================================================================
# TESTING HELPER
# ============================================================================

if __name__ == "__main__":
    import asyncio

    async def test_connection():
        """Test database connection."""
        print("Testing database connection...")

        # Test connection
        is_healthy = await check_db_connection()

        if is_healthy:
            print("✅ Database connection successful!")
        else:
            print("❌ Database connection failed!")

        # Close connections
        await close_db()

    # Run test
    asyncio.run(test_connection())








--- START OF FILE: ./app/__init__.py ---


--- START OF FILE: ./app/logger.py ---
"""
Structured Logging Configuration

This module sets up structured logging for the application using
Python's logging module with JSON formatting for production.
"""

import logging
import logging.config
import logging.handlers
import sys
from pathlib import Path
from typing import Optional
import json
from datetime import datetime,timezone

from app.config import settings


# ============================================================================
# JSON FORMATTER (Simple Implementation)
# ============================================================================

class JSONFormatter(logging.Formatter):
    """
    Custom JSON formatter for structured logging.

    Formats log records as JSON objects with consistent structure.
    """

    def format(self, record: logging.LogRecord) -> str:
        """
        Format log record as JSON string.

        Args:
            record: Log record to format

        Returns:
            str: JSON-formatted log message
        """
        log_data = {
            "timestamp": datetime.now(timezone.utc).isoformat().replace("+00:00", "Z"),
            "level": record.levelname,
            "logger": record.name,
            "message": record.getMessage(),
            "module": record.module,
            "function": record.funcName,
            "line": record.lineno,
        }

        # Add exception info if present
        if record.exc_info:
            log_data["exception"] = self.formatException(record.exc_info)

        # Add extra fields if present
        if hasattr(record, "extra"):
            log_data.update(record.extra)

        return json.dumps(log_data)


# ============================================================================
# LOGGING SETUP
# ============================================================================

def setup_logging(
    log_level: Optional[str] = None,
    log_file: Optional[str] = None,
    log_format: Optional[str] = None,
) -> None:
    """
    Configure application logging.

    Sets up console and file handlers with appropriate formatters.
    Uses settings from config if parameters not provided.

    Args:
        log_level: Minimum log level (DEBUG, INFO, WARNING, ERROR, CRITICAL)
        log_file: Path to log file
        log_format: Format type ('json' or 'text')
    """
    # Use settings as defaults
    log_level = log_level or settings.log_level
    log_file = log_file or settings.log_file
    log_format = log_format or settings.log_format

    # Create logs directory if it doesn't exist
    log_path = Path(log_file)
    log_path.parent.mkdir(parents=True, exist_ok=True)

    # ========================================================================
    # FORMATTERS
    # ========================================================================

    # Text formatter (human-readable)
    text_formatter = logging.Formatter(
        fmt="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
        datefmt="%Y-%m-%d %H:%M:%S",
    )

    # JSON formatter (structured)
    json_formatter = JSONFormatter()

    # Choose formatter based on log_format setting
    formatter = json_formatter if log_format == "json" else text_formatter

    # ========================================================================
    # HANDLERS
    # ========================================================================

    # Console handler (stdout)
    console_handler = logging.StreamHandler(sys.stdout)
    console_handler.setLevel(logging.DEBUG)
    console_handler.setFormatter(formatter)

    # File handler (rotating)
    file_handler = logging.handlers.RotatingFileHandler(
        filename=log_file,
        maxBytes=10 * 1024 * 1024,  # 10 MB
        backupCount=5,  # Keep 5 backup files
        encoding="utf-8",
    )
    file_handler.setLevel(logging.DEBUG)
    file_handler.setFormatter(json_formatter)  # Always use JSON for file

    # ========================================================================
    # ROOT LOGGER CONFIGURATION
    # ========================================================================

    # Get root logger
    root_logger = logging.getLogger()
    root_logger.setLevel(log_level)

    # Remove existing handlers
    root_logger.handlers.clear()

    # Add our handlers
    root_logger.addHandler(console_handler)
    root_logger.addHandler(file_handler)

    # ========================================================================
    # THIRD-PARTY LOGGER LEVELS
    # ========================================================================

    # Reduce verbosity of third-party loggers
    logging.getLogger("uvicorn").setLevel(logging.INFO)
    logging.getLogger("uvicorn.access").setLevel(logging.WARNING)
    logging.getLogger("sqlalchemy").setLevel(logging.WARNING)
    logging.getLogger("httpx").setLevel(logging.WARNING)

    # Log initialization
    logger = logging.getLogger(__name__)
    logger.info(
        "Logging configured",
        extra={
            "log_level": log_level,
            "log_file": log_file,
            "log_format": log_format,
        },
    )


# ============================================================================
# LOGGING HELPERS
# ============================================================================

def get_logger(name: str) -> logging.Logger:
    """
    Get a logger instance with the specified name.

    Args:
        name: Logger name (usually __name__)

    Returns:
        logging.Logger: Configured logger instance
    """
    return logging.getLogger(name)


def log_request(
    method: str,
    path: str,
    status_code: int,
    duration_ms: float,
    extra: Optional[dict] = None,
) -> None:
    """
    Log HTTP request with consistent format.

    Args:
        method: HTTP method (GET, POST, etc.)
        path: Request path
        status_code: HTTP status code
        duration_ms: Request duration in milliseconds
        extra: Additional fields to log
    """
    logger = get_logger("app.requests")

    log_data = {
        "method": method,
        "path": path,
        "status_code": status_code,
        "duration_ms": duration_ms,
    }

    if extra:
        log_data.update(extra)

    # Log level based on status code
    if status_code >= 500:
        logger.error(f"{method} {path} - {status_code}", extra=log_data)
    elif status_code >= 400:
        logger.warning(f"{method} {path} - {status_code}", extra=log_data)
    else:
        logger.info(f"{method} {path} - {status_code}", extra=log_data)


def log_agent_action(
    agent_name: str,
    action: str,
    conversation_id: str,
    success: bool,
    duration_ms: float,
    extra: Optional[dict] = None,
) -> None:
    """
    Log agent action with consistent format.

    Args:
        agent_name: Name of the agent
        action: Action performed
        conversation_id: Conversation ID
        success: Whether action succeeded
        duration_ms: Action duration in milliseconds
        extra: Additional fields to log
    """
    logger = get_logger(f"app.agents.{agent_name}")

    log_data = {
        "agent": agent_name,
        "action": action,
        "conversation_id": conversation_id,
        "success": success,
        "duration_ms": duration_ms,
    }

    if extra:
        log_data.update(extra)

    if success:
        logger.info(f"Agent {agent_name} - {action}", extra=log_data)
    else:
        logger.error(f"Agent {agent_name} - {action} FAILED", extra=log_data)


def log_database_query(
    operation: str,
    table: str,
    duration_ms: float,
    rows_affected: int = 0,
    extra: Optional[dict] = None,
) -> None:
    """
    Log database query with consistent format.

    Args:
        operation: Operation type (SELECT, INSERT, UPDATE, DELETE)
        table: Table name
        duration_ms: Query duration in milliseconds
        rows_affected: Number of rows affected
        extra: Additional fields to log
    """
    logger = get_logger("app.database")

    log_data = {
        "operation": operation,
        "table": table,
        "duration_ms": duration_ms,
        "rows_affected": rows_affected,
    }

    if extra:
        log_data.update(extra)

    logger.debug(f"DB {operation} {table}", extra=log_data)


# ============================================================================
# TESTING/DEBUG
# ============================================================================

if __name__ == "__main__":
    # Setup logging
    setup_logging(log_level="DEBUG", log_format="text")

    # Test logging at different levels
    logger = get_logger(__name__)

    logger.debug("This is a DEBUG message")
    logger.info("This is an INFO message")
    logger.warning("This is a WARNING message")
    logger.error("This is an ERROR message")
    logger.critical("This is a CRITICAL message")

    # Test helper functions
    log_request("GET", "/api/v1/health", 200, 15.5)
    log_agent_action("intent_classifier", "classify", "conv-123", True, 50.2)
    log_database_query("SELECT", "customers", 5.3, 1)

    # Test with exception
    try:
        raise ValueError("Test exception")
    except Exception:
        logger.exception("Exception occurred")

    print("\n✅ Logging test complete. Check logs/app.log")


--- START OF FILE: ./app/seed.py ---
"""
Database Seeding Script

Populates database with sample data for development and testing.
"""

import asyncio
import logging
from datetime import datetime
from sqlalchemy import text  # <--- Added import

from app.database import AsyncSessionLocal
from app.services.customer import CustomerService
from app.services.conversation import ConversationService
from app.services.message import MessageService
from app.models.conversation import ConversationChannel, ConversationStatus
from app.models.message import MessageRole

# Setup logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# ============================================================================
# SAMPLE DATA
# ============================================================================

SAMPLE_CUSTOMERS = [
    {
        "customer_id": "CUST-001",
        "first_name": "John",
        "last_name": "Smith",
        "email": "john.smith@example.com",
        "phone": "+44123456789",
        "is_vip": True,
    },
    {
        "customer_id": "CUST-002",
        "first_name": "Jane",
        "last_name": "Doe",
        "email": "jane.doe@example.com",
        "phone": "+44987654321",
        "is_vip": False,
    },
    {
        "customer_id": "CUST-003",
        "first_name": "Robert",
        "last_name": "Johnson",
        "email": "robert.johnson@example.com",
        "phone": "+44111222333",
        "is_vip": True,
    },
]

SAMPLE_CONVERSATIONS = [
    {
        "title": "Mortgage Application Inquiry",
        "channel": ConversationChannel.WEB,
        "intent": "loan_inquiry",
    },
    {
        "title": "Account Balance Question",
        "channel": ConversationChannel.MOBILE,
        "intent": "account_balance",
    },
    {
        "title": "Credit Card Application",
        "channel": ConversationChannel.WEB,
        "intent": "credit_card",
    },
]

SAMPLE_MESSAGES = [
    # Conversation 1 messages
    [
        {
            "role": MessageRole.CUSTOMER,
            "content": "I'm interested in applying for a mortgage. What are the requirements?",
            "intent": "loan_inquiry",
            "sentiment": "neutral",
            "confidence_score": 95,
        },
        {
            "role": MessageRole.AGENT,
            "content": "I'd be happy to help you with your mortgage inquiry. Let me provide you with the key requirements...",
            "agent_name": "product_recommender",
        },
        {
            "role": MessageRole.CUSTOMER,
            "content": "What interest rates do you currently offer?",
            "intent": "loan_inquiry",
            "sentiment": "positive",
            "confidence_score": 92,
        },
    ],
    # Conversation 2 messages
    [
        {
            "role": MessageRole.CUSTOMER,
            "content": "What is my current account balance?",
            "intent": "account_balance",
            "sentiment": "neutral",
            "confidence_score": 98,
        },
        {
            "role": MessageRole.AGENT,
            "content": "I can help you check your account balance. Let me retrieve that information...",
            "agent_name": "account_agent",
        },
    ],
]

# ============================================================================
# SEEDING FUNCTIONS
# ============================================================================

async def seed_customers() -> list:
    """
    Seed sample customers.

    Returns:
        list: Created customer IDs
    """
    logger.info("Seeding customers...")

    customer_ids = []

    async with CustomerService() as service:
        for data in SAMPLE_CUSTOMERS:
            try:
                customer = await service.create_customer(**data)
                customer_ids.append(customer.id)
                logger.info(f"Created customer: {customer.full_name} ({customer.email})")
            except ValueError as e:
                logger.warning(f"Skipped customer {data['email']}: {e}")

    logger.info(f"Seeded {len(customer_ids)} customers")
    return customer_ids

async def seed_conversations(customer_ids: list) -> list:
    """
    Seed sample conversations.

    Args:
        customer_ids: List of customer IDs

    Returns:
        list: Created conversation IDs
    """
    logger.info("Seeding conversations...")

    conversation_ids = []

    async with ConversationService() as service:
        for i, data in enumerate(SAMPLE_CONVERSATIONS):
            # Assign to customers in round-robin fashion
            customer_id = customer_ids[i % len(customer_ids)]

            conversation = await service.start_conversation(
                customer_id=customer_id,
                title=data["title"],
                channel=data["channel"]
            )

            # Update intent if provided
            if "intent" in data:
                async with AsyncSessionLocal() as session:
                    conv = await session.get(type(conversation), conversation.id)
                    conv.intent = data["intent"]
                    await session.commit()

            conversation_ids.append(conversation.id)
            logger.info(f"Created conversation: {conversation.title}")

    logger.info(f"Seeded {len(conversation_ids)} conversations")
    return conversation_ids

async def seed_messages(conversation_ids: list):
    """
    Seed sample messages.

    Args:
        conversation_ids: List of conversation IDs
    """
    logger.info("Seeding messages...")

    message_count = 0

    async with MessageService() as service:
        for i, messages in enumerate(SAMPLE_MESSAGES):
            if i >= len(conversation_ids):
                break

            conversation_id = conversation_ids[i]

            for msg_data in messages:
                message = await service.add_message(
                    conversation_id=conversation_id,
                    **msg_data
                )
                message_count += 1
                logger.info(f"Created message: {msg_data['role'].value} - {msg_data['content'][:50]}...")

    logger.info(f"Seeded {message_count} messages")

async def clear_database():
    """
    Clear all data from database.

    WARNING: This will delete ALL data!
    """
    logger.warning("Clearing database...")

    async with AsyncSessionLocal() as session:
        # Delete in reverse order of foreign keys
        # Wraps SQL strings in text() to avoid SQLAlchemy errors
        await session.execute(text("DELETE FROM messages"))
        await session.execute(text("DELETE FROM conversations"))
        await session.execute(text("DELETE FROM customers"))
        await session.commit()

    logger.info("Database cleared")

# ============================================================================
# MAIN SEEDING FUNCTION
# ============================================================================

async def seed_all(clear_first: bool = False):
    """
    Seed all sample data.

    Args:
        clear_first: Whether to clear existing data first
    """
    try:
        if clear_first:
            await clear_database()

        logger.info("Starting database seeding...")

        # Seed in order of dependencies
        customer_ids = await seed_customers()
        conversation_ids = await seed_conversations(customer_ids)
        await seed_messages(conversation_ids)

        logger.info("✅ Database seeding completed successfully!")

    except Exception as e:
        logger.error(f"❌ Error seeding database: {e}", exc_info=True)
        raise

# ============================================================================
# CLI ENTRY POINT
# ============================================================================

if __name__ == "__main__":
    import sys

    # Check for --clear flag
    clear_first = "--clear" in sys.argv

    # Run seeding
    asyncio.run(seed_all(clear_first=clear_first))


--- START OF FILE: ./app/main.py ---
"""
FastAPI Application Entry Point

This module initializes the FastAPI application, configures middleware,
registers routers, and sets up CORS policies.
"""
from contextlib import asynccontextmanager
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi.middleware.gzip import GZipMiddleware
from fastapi.responses import JSONResponse
import logging

# Import configuration and utilities
from app.config import settings
from app.logger import setup_logging
from app.database import init_db, close_db
from app.api.routes.messages import router as messages_router
from app.routers.admin import router as admin_router


# Import routers
from app.routers import health

# Setup logging
setup_logging()
logger = logging.getLogger(__name__)



@asynccontextmanager
async def lifespan(app: FastAPI):
    """
    Manage application lifespan (startup and shutdown).

    Startup:
    - Initialize logging
    - Initialize database tables (development only)
    - Log startup information

    Shutdown:
    - Close database connections
    - Cleanup resources
    - Log shutdown
    """
    # ========== STARTUP ==========
    logger.info(f"Starting {settings.app_name} v{settings.app_version}")
    logger.info(f"Environment: {settings.environment}")
    logger.info(f"Debug mode: {settings.debug}")

    # Initialize database (development only)
    if settings.is_development:
        logger.info("Initializing database tables (development mode)")
        try:
            await init_db()
        except Exception as e:
            logger.error(f"Database initialization failed: {e}", exc_info=True)

    logger.info("Application startup complete")

    yield  # Application runs here

    # ========== SHUTDOWN ==========
    logger.info("Shutting down application")

    # Close database connections
    try:
        await close_db()
    except Exception as e:
        logger.error(f"Error closing database: {e}", exc_info=True)

    logger.info("Application shutdown complete")


# ============================================================================
# APPLICATION FACTORY
# ============================================================================


def create_application() -> FastAPI:
    """
    Create and configure FastAPI application instance.

    Returns:
        FastAPI: Configured application instance
    """

    # Create FastAPI instance
    app = FastAPI(
        title=settings.app_name,
        version=settings.app_version,
        description="FCA-compliant multi-agent AI support system for UK financial services",
        docs_url="/docs" if settings.debug else None,  # Disable docs in production
        redoc_url="/redoc" if settings.debug else None,
        openapi_url="/openapi.json" if settings.debug else None,
        lifespan=lifespan,
        # Metadata for OpenAPI schema
        contact={
            "name": "David Sandeep",
            "email": "davidsandeep1996@gmail.com",
        },
        license_info={
            "name": "MIT",
            "url": "https://opensource.org/licenses/MIT",
        },
    )

    # ========================================================================
    # MIDDLEWARE CONFIGURATION
    # ========================================================================

    # CORS Middleware - Allow cross-origin requests
    app.add_middleware(
        CORSMiddleware,
        allow_origins=settings.cors_origins,
        allow_credentials=True,
        allow_methods=["*"],  # Allow all HTTP methods
        allow_headers=["*"],  # Allow all headers
    )

    # GZip Middleware - Compress responses
    app.add_middleware(
        GZipMiddleware,
        minimum_size=1000,  # Only compress responses > 1KB
    )




    # ========================================================================
    # EXCEPTION HANDLERS
    # ========================================================================

    @app.exception_handler(Exception)
    async def global_exception_handler(request, exc):
        """
        Global exception handler for unhandled errors.

        Args:
            request: FastAPI request object
            exc: Exception that was raised

        Returns:
            JSONResponse with error details
        """
        logger.error(f"Unhandled exception: {exc}", exc_info=True)

        return JSONResponse(
            status_code=500,
            content={
                "error": "Internal Server Error",
                "message": str(exc) if settings.debug else "An unexpected error occurred",
            },
        )

    # ========================================================================
    # ROUTERS
    # ========================================================================

    # Root endpoint
    @app.get("/", tags=["Root"])
    async def root():
        """
        Root endpoint - API information.

        Returns:
            dict: API metadata
        """
        return {
            "name": settings.app_name,
            "version": settings.app_version,
            "status": "operational",
            "environment": settings.environment,
            "docs": "/docs" if settings.debug else "disabled",
        }

    # Register routers
    app.include_router(
        health.router,
        prefix="/api/v1",
        tags=["Health"],
    )

    app.include_router(messages_router)
    app.include_router(admin_router)


    return app


# ============================================================================
# APPLICATION INSTANCE
# ============================================================================

# Create application instance
app = create_application()


# ============================================================================
# MAIN ENTRY POINT (for direct execution)
# ============================================================================

if __name__ == "__main__":
    import uvicorn

    # Run with uvicorn (development only)
    uvicorn.run(
        "app.main:app",
        host="0.0.0.0",
        port=8000,
        reload=True,  # Auto-reload on code changes
        log_level="info",
    )


--- START OF FILE: ./app/seed_database.py ---
"""
Database Seeding Script - 1000+ Realistic Records with Auto-Table Creation

Populates database with large-scale sample data for development and testing.

Features:
- Auto-creates all tables (idempotent, safe to run multiple times)
- Generates realistic UK customer data via Faker
- Seeds products, accounts, transactions, conversations, and messages
- Optional data clearing (--clear flag)
- Configurable scale (--customers N)
- Expected vs Actual report (variance + success rate)
- FIXED: Proper transaction handling without savepoints
- FIXED: datetime.utcnow() deprecation warning resolved
- FIXED: Better error reporting with full exception details
"""

import asyncio
import logging
from datetime import datetime, timedelta, timezone
from decimal import Decimal

from faker import Faker
from sqlalchemy import text

from app.database import AsyncSessionLocal, engine, Base
from app.services.customer import CustomerService
from app.services.conversation import ConversationService
from app.services.message import MessageService
from app.services import ProductService, AccountService, TransactionService
from app.models.conversation import ConversationChannel
from app.models.message import MessageRole
from app.models.account import AccountType, AccountStatus


# =============================================================================
# Logging + Faker
# =============================================================================
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)
fake = Faker("en_GB")


# =============================================================================
# Table creation
# =============================================================================
async def create_all_tables() -> None:
    """Create all database tables if they don't exist (idempotent)."""
    logger.info("🔧 Checking/Creating database tables...")
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)
    logger.info("✅ All tables created/verified successfully\n")


# =============================================================================
# Data generation
# =============================================================================
def generate_customers(count: int = 100) -> list[dict]:
    customers: list[dict] = []
    for i in range(1, count + 1):
        customers.append(
            {
                "customer_id": f"CUST-{i:06d}",
                "first_name": fake.first_name(),
                "last_name": fake.last_name(),
                "email": fake.unique.email(),
                "phone": fake.phone_number(),
                "is_vip": fake.random_element([True, False, False, False]),  # ~25% VIP
            }
        )
    return customers


SAMPLE_PRODUCTS = [
    {
        "name": "Premium Savings Account",
        "type": "savings",
        "description": "Earn interest on your savings with flexible access",
        "interest_rate": Decimal("2.50"),
        "features": ["Interest payments", "Easy access", "No fees"],
        "requirements": {"min_balance": 1000, "age": 18},
        "is_active": True,
    },
    {
        "name": "Current Account",
        "type": "current",
        "description": "Everyday banking made easy",
        "interest_rate": Decimal("0.00"),
        "features": ["Debit card", "Online banking", "Direct deposits"],
        "requirements": {"age": 16},
        "is_active": True,
    },
    {
        "name": "Travel Credit Card",
        "type": "credit",
        "description": "Rewards on every purchase",
        "interest_rate": Decimal("9.99"),
        "features": ["Cashback", "Travel insurance", "No foreign fees"],
        "requirements": {"min_income": 25000},
        "is_active": True,
    },
    {
        "name": "Personal Loan",
        "type": "loan",
        "description": "Borrow up to £50,000 at competitive rates",
        "interest_rate": Decimal("7.49"),
        "features": ["Flexible terms", "Quick approval", "No early repayment penalty"],
        "requirements": {"min_income": 30000, "credit_score": 600},
        "is_active": True,
    },
    {
        "name": "Fixed Rate Bond",
        "type": "savings",
        "description": "Guaranteed returns on your investment",
        "interest_rate": Decimal("4.25"),
        "features": ["Fixed returns", "1-year term", "FSCS protected"],
        "requirements": {"min_balance": 5000},
        "is_active": True,
    },
]

REALISTIC_MERCHANTS = [
    "Tesco", "Sainsbury's", "Asda", "Morrisons", "Waitrose", "Co-op",
    "Lidl", "Aldi", "Iceland", "Marks & Spencer", "Starbucks", "Costa Coffee",
    "Pret A Manger", "Greggs", "McDonald's", "Subway", "Pizza Hut", "KFC",
    "Nando's", "Wagamama", "Netflix", "Spotify", "Amazon", "eBay",
    "Argos", "John Lewis", "Boots", "Uber",
]

TRANSACTION_CATEGORIES = [
    "groceries", "dining", "entertainment", "transport", "utilities", "shopping",
    "subscriptions", "travel", "health", "fitness", "education", "bills",
    "insurance", "fuel", "phone", "internet",
]

SAMPLE_CONVERSATIONS = [
    {"title": "Mortgage Application Inquiry", "channel": ConversationChannel.WEB, "intent": "loan_inquiry"},
    {"title": "Account Balance Question", "channel": ConversationChannel.MOBILE, "intent": "account_balance"},
    {"title": "Credit Card Application", "channel": ConversationChannel.WEB, "intent": "credit_card"},
]


# =============================================================================
# Seeding functions
# =============================================================================
async def seed_customers(count: int = 100) -> list[int]:
    logger.info(f"🌱 Seeding {count} customers...")
    customer_ids: list[int] = []
    customers_data = generate_customers(count)
    customers_failed = 0

    async with CustomerService() as service:
        for i, data in enumerate(customers_data, start=1):
            try:
                customer = await service.create_customer(**data)
                customer_ids.append(customer.id)
                if i % 10 == 0:
                    logger.info(f"  ✅ Created {i}/{count} customers")
            except Exception as e:
                customers_failed += 1
                await service.rollback()
                logger.debug(f"⚠️  Skipped customer {data.get('email')}: {str(e)[:200]}")

        await service.commit()

    logger.info(f"📊 Seeded {len(customer_ids)}/{count} customers ({customers_failed} failed)\n")
    return customer_ids


async def seed_products() -> list[int]:
    """Seed products and COMMIT each individually (FK requirement for accounts)."""
    logger.info("🌱 Seeding products...")
    product_ids: list[int] = []
    products_failed = 0

    for data in SAMPLE_PRODUCTS:
        async with ProductService() as service:
            try:
                product = await service.repo.create(data)
                await service.commit()  # Commit EACH product individually
                product_ids.append(product.id)
                logger.info(f"✅ Created product: {product.name} ({product.type}) id={product.id}")
            except Exception as e:
                products_failed += 1
                try:
                    await service.rollback()
                except Exception:
                    pass
                logger.warning(f"⚠️  Skipped product {data.get('name')}: {str(e)[:200]}")

    logger.info(f"🔐 {len(product_ids)}/{len(SAMPLE_PRODUCTS)} Products COMMITTED - safe for FK references ({products_failed} failed)\n")
    return product_ids


async def seed_accounts(customer_ids: list[int], product_ids: list[int]) -> list[int]:
    logger.info("🌱 Seeding accounts (2-3 per customer)...")

    if not product_ids:
        raise RuntimeError("❌ No products were created; cannot seed accounts safely.")

    logger.info(f"   Available product IDs: {product_ids}\n")

    account_ids: list[int] = []
    account_types = [AccountType.CURRENT, AccountType.SAVINGS, AccountType.CREDIT]
    accounts_failed = 0

    for idx, customer_id in enumerate(customer_ids):
        async with AccountService() as service:
            try:
                async with AsyncSessionLocal() as session:
                    from app.models.customer import Customer

                    customer = await session.get(Customer, customer_id)
                    ext_customer_id = customer.customer_id if customer else f"CUST-{idx+1:06d}"

                num_accounts = 2 + (idx % 2)  # 2 or 3 accounts
                for j in range(num_accounts):
                    try:
                        product_id = product_ids[j % len(product_ids)]
                        account_type = account_types[j % len(account_types)]

                        account_data = {
                            "account_number": f"ACC{ext_customer_id}{j:02d}",
                            "customer_id": ext_customer_id,
                            "product_id": product_id,
                            "type": account_type,
                            "status": AccountStatus.ACTIVE,
                            "currency": "GBP",
                            "balance": Decimal(str(fake.random_int(1000, 500000))),
                            "available_balance": Decimal(str(fake.random_int(500, 500000))),
                        }

                        account = await service.repo.create(account_data)
                        account_ids.append(account.id)
                    except Exception as e:
                        accounts_failed += 1
                        logger.debug(f"⚠️  Skipped account {ext_customer_id}:{j}: {str(e)[:200]}")
                        continue

                await service.commit()

            except Exception as e:
                logger.debug(f"⚠️  Customer {idx} batch error: {str(e)[:200]}")
                try:
                    await service.rollback()
                except Exception:
                    pass
                continue

            if (idx + 1) % 20 == 0:
                logger.info(f"  ✅ Created {len(account_ids)} accounts for {idx + 1}/{len(customer_ids)} customers ({accounts_failed} failed)")

    logger.info(f"📊 Seeded {len(account_ids)} accounts ({accounts_failed} failed)\n")
    return account_ids


async def seed_transactions(account_ids: list[int]) -> int:
    logger.info("🌱 Seeding transactions (10-20 per account)...")
    logger.info(f"   This will create ~{len(account_ids) * 15:,} transactions...\n")

    transaction_count = 0
    transactions_failed = 0
    first_error_logged = 0

    for acc_idx, account_id in enumerate(account_ids, start=1):
        # FIXED: Create fresh service per account to avoid session issues
        async with TransactionService() as service:
            num_transactions = fake.random_int(10, 20)

            for i in range(num_transactions):
                try:
                    days_ago = fake.random_int(1, 90)
                    # FIXED: Use naive UTC datetime instead of deprecated utcnow()
                    trans_date = datetime.now(timezone.utc).replace(tzinfo=None) - timedelta(days=days_ago)

                    transaction_data = {
                        "account_id": account_id,
                        "reference": f"TXN-{account_id}-{i:04d}",
                        "amount": Decimal(str(fake.random_int(10, 50000) / 100)),
                        "currency": "GBP",
                        "description": fake.sentence(nb_words=4),
                        "category": fake.random_element(TRANSACTION_CATEGORIES),
                        "date": trans_date,
                        "merchant_name": fake.random_element(REALISTIC_MERCHANTS),
                    }

                    # FIXED: Create directly without nested savepoint
                    await service.repo.create(transaction_data)
                    transaction_count += 1

                except Exception as e:
                    transactions_failed += 1
                    # FIXED: Rollback after error to reset session state
                    try:
                        await service.rollback()
                    except Exception:
                        pass

                    # Print detailed error for first few failures
                    if first_error_logged < 5:
                        logger.warning(
                            f"❌ Transaction failed (account_id={account_id}, i={i}): {type(e).__name__}: {str(e)}"
                        )
                        first_error_logged += 1
                    continue

            # Commit all successful transactions for this account
            try:
                await service.commit()
            except Exception as e:
                logger.warning(f"❌ Account {account_id} commit failed: {type(e).__name__}: {str(e)}")
                try:
                    await service.rollback()
                except Exception:
                    pass

            if acc_idx % 50 == 0:
                logger.info(f"  ✅ Created {transaction_count:,} transactions for {acc_idx}/{len(account_ids)} accounts ({transactions_failed} failed)")

    logger.info(f"📊 Seeded {transaction_count:,} transactions ({transactions_failed} failed)\n")
    return transaction_count


async def seed_conversations(customer_ids: list[int]) -> list[int]:
    logger.info("🌱 Seeding conversations...")
    conversation_ids: list[int] = []
    conversations_failed = 0

    async with ConversationService() as service:
        for i, data in enumerate(SAMPLE_CONVERSATIONS):
            customer_id = customer_ids[i % len(customer_ids)]
            try:
                conversation = await service.start_conversation(
                    customer_id=customer_id,
                    title=data["title"],
                    channel=data["channel"],
                )
                conversation_ids.append(conversation.id)
                logger.info(f"✅ Created conversation: {conversation.title}")
            except Exception as e:
                conversations_failed += 1
                await service.rollback()
                logger.warning(f"⚠️  Skipped conversation: {str(e)[:200]}")

        await service.commit()

    logger.info(f"📊 Seeded {len(conversation_ids)}/{len(SAMPLE_CONVERSATIONS)} conversations ({conversations_failed} failed)\n")
    return conversation_ids


async def seed_messages(conversation_ids: list[int]) -> int:
    logger.info("🌱 Seeding messages...")

    sample_messages = [
        {
            "role": MessageRole.CUSTOMER,
            "content": "I'm interested in applying for a mortgage. What are the requirements?",
            "intent": "loan_inquiry",
        },
        {
            "role": MessageRole.AGENT,
            "content": "I'd be happy to help you with your mortgage inquiry. Let me provide key requirements...",
            "agent_name": "product_recommender",
        },
        {
            "role": MessageRole.CUSTOMER,
            "content": "What is my current account balance?",
            "intent": "account_balance",
        },
        {
            "role": MessageRole.AGENT,
            "content": "Let me retrieve your current account balance from our system...",
            "agent_name": "account_agent",
        },
    ]

    message_count = 0
    messages_failed = 0

    async with MessageService() as service:
        for i, conversation_id in enumerate(conversation_ids):
            for msg_data in sample_messages[i : i + 2]:
                try:
                    await service.add_message(conversation_id=conversation_id, **msg_data)
                    message_count += 1
                except Exception as e:
                    messages_failed += 1
                    logger.debug(f"⚠️  Skipped message: {str(e)[:200]}")

        await service.commit()

    logger.info(f"📊 Seeded {message_count} messages ({messages_failed} failed)\n")
    return message_count


async def clear_database() -> None:
    logger.warning("🗑️  CLEARING DATABASE - ALL DATA WILL BE DELETED!")
    logger.warning("   ⚠️  Tables will remain, only data is cleared\n")

    async with AsyncSessionLocal() as session:
        await session.execute(text("DELETE FROM transactions"))
        await session.execute(text("DELETE FROM accounts"))
        await session.execute(text("DELETE FROM products"))
        await session.execute(text("DELETE FROM messages"))
        await session.execute(text("DELETE FROM conversations"))
        await session.execute(text("DELETE FROM customers"))
        await session.commit()

    logger.info("✅ Database cleared (tables preserved)\n")


# =============================================================================
# Main seeding function + report
# =============================================================================
async def seed_all(clear_first: bool = False, customer_count: int = 100) -> None:
    try:
        logger.info("=" * 70)
        logger.info("🌱 STARTING DATABASE SEEDING (1000+ RECORDS)")
        logger.info("=" * 70 + "\n")

        logger.info("STEP 1/3: CREATE/VERIFY TABLES")
        logger.info("-" * 70)
        await create_all_tables()

        if clear_first:
            logger.info("STEP 2/3: CLEAR EXISTING DATA (--clear flag used)")
            logger.info("-" * 70)
            await clear_database()
        else:
            logger.info("STEP 2/3: SKIP DATA CLEAR (appending to existing data)")
            logger.info("-" * 70 + "\n")

        logger.info("STEP 3/3: SEED NEW DATA")
        logger.info("-" * 70 + "\n")

        customer_ids = await seed_customers(customer_count)
        product_ids = await seed_products()
        account_ids = await seed_accounts(customer_ids, product_ids)
        trans_count = await seed_transactions(account_ids)
        conv_ids = await seed_conversations(customer_ids)
        message_count = await seed_messages(conv_ids)

        logger.info("=" * 70)
        logger.info("✅ DATABASE SEEDING COMPLETED SUCCESSFULLY!")
        logger.info("=" * 70 + "\n")

        expected_products = 5
        expected_accounts_per_customer = 2.5
        expected_transactions_per_account = 15
        expected_conversations = 3
        expected_messages_per_conversation = 2

        expected_customers = customer_count
        expected_accounts = int(len(customer_ids) * expected_accounts_per_customer)
        expected_transactions = int(expected_accounts * expected_transactions_per_account)
        expected_messages = expected_conversations * expected_messages_per_conversation
        expected_total = (
            expected_customers
            + expected_products
            + expected_accounts
            + expected_transactions
            + expected_conversations
            + expected_messages
        )

        actual_customers = len(customer_ids)
        actual_products = len(product_ids)
        actual_accounts = len(account_ids)
        actual_transactions = trans_count
        actual_conversations = len(conv_ids)
        actual_messages = message_count
        actual_total = (
            actual_customers
            + actual_products
            + actual_accounts
            + actual_transactions
            + actual_conversations
            + actual_messages
        )

        variance = actual_total - expected_total
        variance_percent = (variance / expected_total * 100) if expected_total > 0 else 0
        success_rate = (actual_total / expected_total * 100) if expected_total > 0 else 0

        logger.info("\n📊 DETAILED SEEDING REPORT\n")
        logger.info("=" * 75)
        logger.info(f"{'ENTITY':<20} {'EXPECTED':>18} {'ACTUAL':>18} {'VARIANCE':>15}")
        logger.info("=" * 75)
        logger.info(f"{'Customers':<20} {expected_customers:>18,} {actual_customers:>18,} {actual_customers - expected_customers:>+14,}")
        logger.info(f"{'Products':<20} {expected_products:>18,} {actual_products:>18,} {actual_products - expected_products:>+14,}")
        logger.info(f"{'Accounts':<20} {expected_accounts:>18,} {actual_accounts:>18,} {actual_accounts - expected_accounts:>+14,}")
        logger.info(f"{'Transactions':<20} {expected_transactions:>18,} {actual_transactions:>18,} {actual_transactions - expected_transactions:>+14,}")
        logger.info(f"{'Conversations':<20} {expected_conversations:>18,} {actual_conversations:>18,} {actual_conversations - expected_conversations:>+14,}")
        logger.info(f"{'Messages':<20} {expected_messages:>18,} {actual_messages:>18,} {actual_messages - expected_messages:>+14,}")
        logger.info("-" * 75)
        logger.info(f"{'TOTAL RECORDS':<20} {expected_total:>18,} {actual_total:>18,} {variance:>+14,}")
        logger.info("=" * 75)

        logger.info("\n📈 PERFORMANCE METRICS:")
        logger.info(f"  • Total Expected:     {expected_total:>10,} records")
        logger.info(f"  • Total Actual:       {actual_total:>10,} records")
        logger.info(f"  • Variance:           {variance:>+10,} records ({variance_percent:>+.2f}%)")
        logger.info(f"  • Success Rate:       {success_rate:>10.2f}%")

        logger.info("\n" + "=" * 75)
        logger.info("✅ COMPLETION STATUS:")
        logger.info("=" * 75)

        if variance >= -5:
            logger.info("  ✅ PASSED - All expected records created successfully!")
            logger.info(f"     Variance within acceptable range: {variance:+,} records")
        elif -50 < variance < -5:
            logger.info("  ⚠️  WARNING - Minor record creation failures detected")
            logger.info(f"     Variance: {variance:+,} records ({variance_percent:.2f}%)")
            logger.info(f"     Success Rate: {success_rate:.2f}%")
        else:
            logger.info("  ❌ FAILED - Significant record creation failures")
            logger.info(f"     Variance: {variance:+,} records ({variance_percent:.2f}%)")
            logger.info(f"     Success Rate: {success_rate:.2f}%")

        logger.info("=" * 75)
        logger.info("\n✨ SEEDING SESSION SUMMARY:")
        logger.info(f"  • Session Type:       {'Full Reset' if clear_first else 'Append Mode'}")
        logger.info(f"  • Customers Seeded:   {actual_customers:,}")
        logger.info(f"  • Total Records:      {actual_total:,}")
        logger.info("  • Database Ready:     ✅ YES")
        logger.info("\n🎯 Next Steps:")
        logger.info("  1. Verify data in database: psql or database client")
        logger.info("  2. Run API tests: pytest -v")
        logger.info("  3. Start application: python -m uvicorn app.main:app --reload")
        logger.info("\n" + "=" * 75 + "\n")

    except Exception as e:
        logger.error(f"❌ Error seeding database: {e}", exc_info=True)
        raise


# =============================================================================
# CLI entry point
# =============================================================================
if __name__ == "__main__":
    import sys

    clear_first = "--clear" in sys.argv

    customer_count = 100
    for i, arg in enumerate(sys.argv):
        if arg == "--customers" and i + 1 < len(sys.argv):
            try:
                customer_count = int(sys.argv[i + 1])
            except ValueError:
                pass

    logger.info(f"Starting seed with {customer_count} customers...")
    asyncio.run(seed_all(clear_first=clear_first, customer_count=customer_count))


--- START OF FILE: ./app/routers/health.py ---
"""
Health Check Router

Provides endpoints for system health monitoring, database status,
and dependency checks.
"""

from fastapi import APIRouter, status
from fastapi.responses import JSONResponse
from pydantic import BaseModel
from typing import Dict, Any
from datetime import datetime,timezone
import logging

from app.config import settings
from app.database import check_db_connection

logger = logging.getLogger(__name__)

# Create router
router = APIRouter()


# ============================================================================
# RESPONSE MODELS
# ============================================================================

class HealthResponse(BaseModel):
    """Health check response model."""

    status: str
    timestamp: str
    version: str
    environment: str
    checks: Dict[str, Any]


class PingResponse(BaseModel):
    """Simple ping response model."""

    status: str
    timestamp: str


# ============================================================================
# ENDPOINTS
# ============================================================================

@router.get(
    "/health",
    response_model=HealthResponse,
    status_code=status.HTTP_200_OK,
    summary="Comprehensive health check",
    description="Check overall system health including database and dependencies",
    tags=["Health"],
)
async def health_check() -> HealthResponse:
    """
    Comprehensive health check endpoint.

    Checks:
    - Database connectivity
    - System configuration
    - Application status

    Returns:
        HealthResponse: Detailed health status
    """
    # Check database
    db_healthy = await check_db_connection()

    # Overall status
    overall_status = "healthy" if db_healthy else "unhealthy"

    # Build response
    health_data = HealthResponse(
        status=overall_status,
        timestamp=datetime.now(timezone.utc).isoformat().replace("+00:00", "Z"),
        version=settings.app_version,
        environment=settings.environment,
        checks={
            "database": {
                "status": "healthy" if db_healthy else "unhealthy",
                "type": "postgresql",
                "pool_size": settings.database_pool_size,
            },
            "redis": {
                "status": "healthy" if settings.redis_enabled else "disabled",
                "enabled": settings.redis_enabled,
            },
            "groq_ai": {
                "status": "configured" if settings.groq_api_key else "not_configured",
                "model": settings.groq_model,
            },
        },
    )

    # Log health check
    logger.info(
        f"Health check: {overall_status}",
        extra={
            "status": overall_status,
            "db_healthy": db_healthy,
        },
    )

    # Return appropriate status code
    if overall_status == "healthy":
        return health_data
    else:
        return JSONResponse(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            content=health_data.model_dump(),
        )


@router.get(
    "/ping",
    response_model=PingResponse,
    status_code=status.HTTP_200_OK,
    summary="Simple ping check",
    description="Quick response check without dependency verification",
    tags=["Health"],
)
async def ping() -> PingResponse:
    """
    Simple ping endpoint.

    Returns immediate response without checking dependencies.
    Useful for basic liveness checks.

    Returns:
        PingResponse: Simple status
    """
    return PingResponse(
        status="ok",
        timestamp=datetime.now(timezone.utc).isoformat().replace("+00:00", "Z"),
    )


@router.get(
    "/ready",
    status_code=status.HTTP_200_OK,
    summary="Readiness check",
    description="Check if application is ready to accept requests",
    tags=["Health"],
)
async def readiness() -> Dict[str, Any]:
    """
    Readiness check endpoint.

    Used by Kubernetes to determine if pod is ready to receive traffic.
    Checks all critical dependencies.

    Returns:
        dict: Readiness status
    """
    # Check database
    db_healthy = await check_db_connection()

    # Application is ready if database is healthy
    is_ready = db_healthy

    if is_ready:
        return {
            "status": "ready",
            "timestamp":datetime.now(timezone.utc).isoformat().replace("+00:00", "Z"),
        }
    else:
        return JSONResponse(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            content={
                "status": "not_ready",
                "reason": "database_unhealthy",
                "timestamp":datetime.now(timezone.utc).isoformat().replace("+00:00", "Z"),
            },
        )


@router.get(
    "/live",
    status_code=status.HTTP_200_OK,
    summary="Liveness check",
    description="Check if application is alive (no dependency checks)",
    tags=["Health"],
)
async def liveness() -> Dict[str, str]:
    """
    Liveness check endpoint.

    Used by Kubernetes to determine if pod is alive and shouldn't be restarted.
    Returns 200 OK if application is running, regardless of dependencies.

    Returns:
        dict: Liveness status
    """
    return {
        "status": "alive",
        "timestamp":datetime.now(timezone.utc).isoformat().replace("+00:00", "Z"),
    }


--- START OF FILE: ./app/routers/__init__.py ---


--- START OF FILE: ./app/routers/admin.py ---
"""
Admin Routes

Protected endpoints for administrative tasks including database seeding.
"""

import logging
from fastapi import APIRouter, HTTPException, BackgroundTasks
from pydantic import BaseModel

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/api/v1/admin", tags=["admin"])

# ============================================================================
# MODELS
# ============================================================================

class SeedRequest(BaseModel):
    """Request to seed database."""
    clear_first: bool = False
    customer_count: int = 100  # Allow custom customer count


class SeedResponse(BaseModel):
    """Response from seeding."""
    status: str
    message: str


# ============================================================================
# ENDPOINTS
# ============================================================================

@router.post("/seed-db", response_model=SeedResponse)
async def seed_database(request: SeedRequest, background_tasks: BackgroundTasks):
    """
    Seed database with realistic sample data (1000+ records).

    WARNING: If clear_first=true, all existing data will be deleted!

    Args:
        request: Seed request with options
        background_tasks: FastAPI background tasks

    Returns:
        SeedResponse: Status of seeding operation

    Example:
        POST /api/v1/admin/seed-db
        {
            "clear_first": false,
            "customer_count": 100
        }
    """
    try:
        # Import here to avoid circular imports
        from app.seed_database import seed_all

        # Validate customer count
        customer_count = request.customer_count
        if customer_count < 10 or customer_count > 10000:
            raise ValueError("customer_count must be between 10 and 10000")

        # Run seeding in background
        background_tasks.add_task(
            seed_all,
            clear_first=request.clear_first,
            customer_count=customer_count
        )

        action = "Clearing database and seeding" if request.clear_first else "Seeding"

        return SeedResponse(
            status="started",
            message=f"{action} started with {customer_count} customers. "
                    f"This will generate ~{customer_count * 40:,} total records. Check logs for progress."
        )

    except Exception as e:
        logger.error(f"Failed to start seeding: {e}")
        raise HTTPException(
            status_code=500,
            detail=f"Failed to start seeding: {str(e)}"
        )


@router.get("/health")
async def health_check():
    """Simple health check endpoint."""
    return {
        "status": "healthy",
        "message": "Admin API is operational"
    }


--- START OF FILE: ./app/middleware/__init__.py ---


--- START OF FILE: ./app/coordinator/__init__.py ---
"""
Coordinator module - Agent orchestration and persistence
"""

from app.coordinator.agent_coordinator import AgentCoordinator

__all__ = ["AgentCoordinator"]


--- START OF FILE: ./app/coordinator/agent_coordinator.py ---
"""
Agent Coordinator

Manages conversation state, routing, and persistence.
Coordinates multi-agent responses across conversation turns.
"""

from typing import Dict, Any, Optional, List
from datetime import datetime
import logging

from app.workflows.message_workflow import MessageWorkflow
from app.database import AsyncSessionLocal
from app.services import (
            AccountService,
            CustomerService,
            ProductService,
            ConversationService,
            TransactionService,
        )
class ConversationMessage:
    """Single message in conversation."""

    def __init__(
        self,
        customer_id: int,
        message: str,
        agent_type: str,
        response: str,
        intent: str,
        confidence: float,
    ):
        self.timestamp = datetime.utcnow()
        self.customer_id = customer_id
        self.message = message
        self.agent_type = agent_type
        self.response = response
        self.intent = intent
        self.confidence = confidence


class ConversationContext:
    """Maintains conversation state and history."""

    def __init__(self, customer_id: int, conversation_id: int):
        self.customer_id = customer_id
        self.conversation_id = conversation_id
        self.messages: List[ConversationMessage] = []
        self.created_at = datetime.utcnow()
        self.last_intent = None
        self.escalation_id = None
        self.is_escalated = False

    def add_message(
        self,
        message: str,
        agent_type: str,
        response: str,
        intent: str,
        confidence: float,
    ) -> None:
        """Add message to conversation history."""
        conv_msg = ConversationMessage(
            customer_id=self.customer_id,
            message=message,
            agent_type=agent_type,
            response=response,
            intent=intent,
            confidence=confidence,
        )
        self.messages.append(conv_msg)
        self.last_intent = intent

    def mark_escalated(self, escalation_id: str) -> None:
        """Mark conversation as escalated."""
        self.is_escalated = True
        self.escalation_id = escalation_id

    def get_history(self, limit: int = 10) -> List[Dict[str, Any]]:
        """Get conversation history."""
        recent = self.messages[-limit:]
        return [
            {
                "timestamp": msg.timestamp.isoformat(),
                "message": msg.message,
                "agent": msg.agent_type,
                "intent": msg.intent,
                "response": msg.response[:100] + "...",
            }
            for msg in recent
        ]


class AgentCoordinator:
    """
    Coordinates multi-agent responses.

    Manages:
    - Conversation state
    - Message routing
    - Escalations
    - Persistence
    """

    def __init__(self,
    account_service=None,
    customer_service=None,
    product_service=None,
    conversation_service=None,
                 ):
        """Initialize coordinator."""
        self.logger = logging.getLogger(__name__)
        self.conversations: Dict[int, ConversationContext] = {}

            # Initialize services


        self.account_service = account_service or AccountService()
        self.customer_service = customer_service or CustomerService()
        self.product_service = product_service or ProductService()
        self.conversation_service = conversation_service or ConversationService()

    # ========================================================================
    # CONVERSATION MANAGEMENT
    # ========================================================================

    def get_or_create_conversation(
        self,
        customer_id: int,
        conversation_id: int,
    ) -> ConversationContext:
        """Get or create conversation context."""

        if conversation_id not in self.conversations:
            self.conversations[conversation_id] = ConversationContext(
                customer_id=customer_id,
                conversation_id=conversation_id,
            )

        return self.conversations[conversation_id]

    async def process_message(self, message: str, customer_id: int, conversation_id: int, context=None):
        self.logger.info(f"\n🔄 Coordinating message for customer {customer_id}")

        conv_context = self.get_or_create_conversation(customer_id, conversation_id)

        if context is None:
            context = {}

        async with AsyncSessionLocal() as session:
            account_service = AccountService(db=session)
            customer_service = CustomerService(db=session)
            transaction_service = TransactionService(db=session)
            product_service = ProductService(db=session)

            # build workflow WITH db-backed services
            workflow = MessageWorkflow(
                account_service=account_service,
                customer_service=customer_service,
                transaction_service=transaction_service,
                product_service=product_service,
            )

            # IMPORTANT: update context with the db-backed services (not self.*)
            context.update({
                "account_service": account_service,
                "customer_service": customer_service,
                "transaction_service": transaction_service,
                "product_service": product_service,
                # keep these only if they exist and are DB-safe in your project:
                # "compliance_service": ...,
                # "conversation_service": ...,
            })

            # IMPORTANT: call the local workflow, not self.workflow
            workflow_response = await workflow.process_message(
                message=message,
                customer_id=customer_id,
                conversation_id=conversation_id,
                context=context,
            )

        # everything below stays the same (uses workflow_response)
        agent_type = workflow_response.get("agent")
        response_text = workflow_response.get("message")
        intent = workflow_response.get("intent")
        confidence = workflow_response.get("confidence", 0.0)

        conv_context.add_message(
            message=message,
            agent_type=agent_type,
            response=response_text,
            intent=intent,
            confidence=confidence,
        )

        escalation_id = workflow_response.get("metadata", {}).get("escalation_id")
        if escalation_id:
            conv_context.mark_escalated(escalation_id)
            self.logger.info(f"⚠️ Escalation detected: {escalation_id}")


        self.logger.info(f"✅ Message processed: {agent_type} agent, turn #{len(conv_context.messages)}")


        return {
            "response": response_text,
            "agent": agent_type,
            "intent": intent,
            "confidence": confidence,
            "conversation_id": conversation_id,
            "turn_count": len(conv_context.messages),
            "escalated": conv_context.is_escalated,
            "escalation_id": escalation_id,
        }

 

    # ========================================================================
    # PERSISTENCE & RETRIEVAL
    # ========================================================================

    def get_conversation(self, conversation_id: int) -> Optional[ConversationContext]:
        """Get conversation by ID."""
        return self.conversations.get(conversation_id)

    def get_conversation_history(
        self,
        conversation_id: int,
        limit: int = 10,
    ) -> Optional[List[Dict[str, Any]]]:
        """Get conversation history."""
        conv = self.get_conversation(conversation_id)
        if conv:
            return conv.get_history(limit)
        return None

    def get_all_conversations(self, customer_id: int) -> List[ConversationContext]:
        """Get all conversations for a customer."""
        return [
            conv for conv in self.conversations.values()
            if conv.customer_id == customer_id
        ]

    # ========================================================================
    # ESCALATION MANAGEMENT
    # ========================================================================

    def get_escalated_conversations(self) -> List[Dict[str, Any]]:
        """Get all escalated conversations."""
        escalated = []
        for conv in self.conversations.values():
            if conv.is_escalated:
                escalated.append({
                    "conversation_id": conv.conversation_id,
                    "customer_id": conv.customer_id,
                    "escalation_id": conv.escalation_id,
                    "message_count": len(conv.messages),
                    "created_at": conv.created_at.isoformat(),
                })
        return escalated

    def resolve_escalation(
        self,
        conversation_id: int,
        resolution_notes: str,
    ) -> bool:
        """Mark escalation as resolved."""
        conv = self.get_conversation(conversation_id)
        if conv and conv.is_escalated:
            self.logger.info(f"✅ Escalation resolved: {conv.escalation_id}")
            return True
        return False

    # ========================================================================
    # STATISTICS & MONITORING
    # ========================================================================

    def get_statistics(self) -> Dict[str, Any]:
        """Get coordination statistics."""
        total_messages = sum(
            len(conv.messages) for conv in self.conversations.values()
        )
        escalated_count = sum(
            1 for conv in self.conversations.values()
            if conv.is_escalated
        )

        # Agent distribution
        agent_counts = {}
        for conv in self.conversations.values():
            for msg in conv.messages:
                agent = msg.agent_type
                agent_counts[agent] = agent_counts.get(agent, 0) + 1

        # Intent distribution
        intent_counts = {}
        for conv in self.conversations.values():
            for msg in conv.messages:
                intent = msg.intent
                intent_counts[intent] = intent_counts.get(intent, 0) + 1

        return {
            "total_conversations": len(self.conversations),
            "total_messages": total_messages,
            "escalated_conversations": escalated_count,
            "agent_distribution": agent_counts,
            "intent_distribution": intent_counts,
            "avg_messages_per_conversation": (
                total_messages / len(self.conversations)
                if self.conversations else 0
            ),
        }

    def get_coordinator_info(self) -> Dict[str, Any]:
        """Get coordinator information."""
        return {
            "type": "AgentCoordinator",
            "workflow": "LangGraph (MessageWorkflow)",
            "agents": 6,
            "conversation_memory": len(self.conversations),
            "features": [
                "Multi-turn conversations",
                "Intent tracking",
                "Escalation management",
                "Conversation history",
                "Statistics & monitoring",
            ],
        }


--- START OF FILE: ./app/workflows/__init__.py ---
"""
Workflows module - Multi-agent orchestration
"""

from app.workflows.message_workflow import MessageWorkflow

__all__ = ["MessageWorkflow"]


--- START OF FILE: ./app/workflows/message_workflow.py ---
"""
Message Workflow

Multi-agent orchestration using LangGraph.
Routes messages through Intent Classifier → Specialized Agents.
"""

from typing import Dict, Any, Optional, List
from enum import Enum
import logging

from langgraph.graph import StateGraph, END

from app.agents.intent_classifier import IntentClassifierAgent
from app.agents.account_agent import AccountAgent
from app.agents.general_agent import GeneralAgent
from app.agents.human_agent import HumanAgent
from app.agents.product_recommender import ProductRecommenderAgent
from app.agents.compliance_checker import ComplianceCheckerAgent
from app.services import (
    AccountService,
    CustomerService,
    TransactionService,
    ProductService,
)


class WorkflowState(str, Enum):
    """Workflow states."""
    START = "start"
    CLASSIFY = "classify"
    ACCOUNT = "account"
    GENERAL = "general"
    PRODUCT = "product"
    COMPLIANCE = "compliance"
    HUMAN = "human"
    END = "end"


class MessageWorkflow:
    """
    Multi-agent message workflow.

    Flow:
    1. Intent Classifier → determines intent
    2. Conditional routing:
       - account_inquiry → Account Agent
       - general_inquiry → General Agent
       - product_inquiry → Product Agent → Compliance Check
       - complaint → Human Agent (escalation)
    3. Response formatting
    """

    def __init__(self, *, account_service, customer_service, transaction_service, product_service):
        self.intent_classifier = IntentClassifierAgent()
        self.account_agent = AccountAgent(
            account_service=account_service,
            customer_service=customer_service,
            transaction_service=transaction_service,
        )
        self.general_agent = GeneralAgent()
        self.product_agent = ProductRecommenderAgent(product_service=product_service)
        self.compliance_agent = ComplianceCheckerAgent()
        self.human_agent = HumanAgent()


        # Build LangGraph workflow
        self.graph = self._build_graph()
        self.workflow = self.graph.compile()

    def _build_graph(self):
        """Build LangGraph state machine."""

        # Create state graph
        workflow = StateGraph(dict)

        # Define nodes
        workflow.add_node("classify", self._node_classify)
        workflow.add_node("account", self._node_account)
        workflow.add_node("general", self._node_general)
        workflow.add_node("product", self._node_product)
        workflow.add_node("compliance", self._node_compliance)
        workflow.add_node("human", self._node_human)
        workflow.add_node("end", self._node_end)

        # Entry point
        workflow.set_entry_point("classify")

        # Conditional routing from classifier
        workflow.add_conditional_edges(
            "classify",
            self._route_by_intent,
            {
                "account": "account",
                "general": "general",
                "product": "product",
                "complaint": "human",
                "default": "general",
            }
        )

        # Route product recommendations to compliance check
        workflow.add_edge("product", "compliance")

        # All paths eventually end
        workflow.add_edge("account", "end")
        workflow.add_edge("general", "end")
        workflow.add_edge("compliance", "end")
        workflow.add_edge("human", "end")

        # End state
        workflow.set_finish_point("end")

        return workflow

    # ========================================================================
    # NODE IMPLEMENTATIONS
    # ========================================================================

    async def _node_classify(self, state: Dict[str, Any]) -> Dict[str, Any]:
        """Classify intent."""
        self.logger.info("📋 Classifying message intent...")

        message = state.get("message")
        customer_id = state.get("customer_id")

        # Run intent classifier
        classification = await self.intent_classifier.process({
            "message": message,
        })

        # Extract intent
        intent = classification.metadata.get("intent", "general_inquiry")
        confidence = classification.confidence

        # Update state
        state["intent"] = intent
        state["intent_confidence"] = confidence
        state["classifier_response"] = classification.content

        self.logger.info(f"✅ Intent: {intent} (confidence: {confidence:.2f})")

        return state

    async def _node_account(self, state: Dict[str, Any]) -> Dict[str, Any]:
        """Handle account inquiries."""
        self.logger.info("🏦 Processing account inquiry...")

        message = state.get("message")
        customer_id = state.get("customer_id")

        # Run account agent
        response = await self.account_agent.process({
            "customer_id": customer_id,
            "message": message,
        })

        state["agent_type"] = "account"
        state["agent_response"] = response.content
        state["agent_metadata"] = response.metadata
        state["confidence"] = response.confidence

        self.logger.info(f"✅ Account query handled: {response.metadata.get('query_type')}")

        return state

    async def _node_general(self, state: Dict[str, Any]) -> Dict[str, Any]:
        """Handle general inquiries."""
        self.logger.info("❓ Processing general inquiry...")

        message = state.get("message")

        # Run general agent
        response = await self.general_agent.process({
            "message": message,
        })

        state["agent_type"] = "general"
        state["agent_response"] = response.content
        state["agent_metadata"] = response.metadata
        state["confidence"] = response.confidence

        self.logger.info(f"✅ General inquiry handled: {response.metadata.get('source')}")

        return state

    async def _node_product(self, state: Dict[str, Any]) -> Dict[str, Any]:
        """Handle product recommendations."""
        self.logger.info("💼 Processing product inquiry...")

        message = state.get("message")
        customer_id = state.get("customer_id")

        # Run product recommender
        response = await self.product_agent.process({
            "customer_id": customer_id,
            "message": message,
        })

        state["agent_type"] = "product"
        state["agent_response"] = response.content
        state["agent_metadata"] = response.metadata
        state["confidence"] = response.confidence

        self.logger.info(f"✅ Product recommendation generated")

        return state

    async def _node_compliance(self, state: Dict[str, Any]) -> Dict[str, Any]:
        """Check compliance of product recommendations."""
        self.logger.info("⚖️ Checking FCA compliance...")

        agent_response = state.get("agent_response")

        # Run compliance checker
        response = await self.compliance_agent.process({
            "content": agent_response,
            "product_type": state.get("agent_metadata", {}).get("products"),
        })

        state["compliance_check"] = response.content
        state["is_compliant"] = response.metadata.get("is_compliant")
        state["required_disclaimers"] = response.metadata.get("required_disclaimers", [])

        # Append disclaimers to agent response if not compliant
        if not state["is_compliant"]:
            disclaimers = "\n\n".join(state["required_disclaimers"])
            state["agent_response"] = f"{agent_response}\n\n⚠️ Important:\n{disclaimers}"

        self.logger.info(f"✅ Compliance check: {'✅ PASS' if state['is_compliant'] else '❌ NEEDS REVISION'}")

        return state

    async def _node_human(self, state: Dict[str, Any]) -> Dict[str, Any]:
        """Escalate to human agent."""
        self.logger.info("👤 Escalating to human specialist...")

        message = state.get("message")
        customer_id = state.get("customer_id")
        conversation_id = state.get("conversation_id", 0)

        # Run human agent
        response = await self.human_agent.process({
            "message": message,
            "customer_id": customer_id,
            "conversation_id": conversation_id,
        })

        state["agent_type"] = "human"
        state["agent_response"] = response.content
        state["agent_metadata"] = response.metadata
        state["confidence"] = response.confidence

        self.logger.info(f"✅ Escalation created: {response.metadata.get('escalation_id')}")

        return state

    async def _node_end(self, state: Dict[str, Any]) -> Dict[str, Any]:
        """Final response formatting."""
        self.logger.info("📤 Formatting final response...")

        # Build final response object
        state["final_response"] = {
            "message": state.get("agent_response"),
            "agent": state.get("agent_type"),
            "intent": state.get("intent"),
            "confidence": state.get("confidence"),
            "metadata": {
                "intent_confidence": state.get("intent_confidence"),
                "agent_metadata": state.get("agent_metadata"),
                "is_compliant": state.get("is_compliant", True),
                "escalation_id": state.get("agent_metadata", {}).get("escalation_id"),
            }
        }

        self.logger.info("✅ Response ready to send")

        return state

    # ========================================================================
    # ROUTING LOGIC
    # ========================================================================

    def _route_by_intent(self, state: Dict[str, Any]) -> str:
        """Route to agent based on intent."""
        intent = state.get("intent", "general_inquiry")

        intent_map = {
            "account_inquiry": "account",
            "general_inquiry": "general",
            "loan_inquiry": "product",
            "credit_card": "product",
            "complaint": "complaint",
        }

        return intent_map.get(intent, "general")

    # ========================================================================
    # PUBLIC INTERFACE
    # ========================================================================

    async def process_message(
        self,
        message: str,
        customer_id: int,
        conversation_id: int = 0,
        context: Optional[Dict[str, Any]] = None,
    ) -> Dict[str, Any]:
        """
        Process message through workflow.

        Args:
            message: Customer message
            customer_id: Customer ID
            conversation_id: Conversation ID
            context: Optional context with services

        Returns:
            dict: Final response with agent info
        """
        self.logger.info(f"\n🔄 Processing message from customer {customer_id}")
        self.logger.info(f"Message: {message[:100]}...")

        # Initial state
        initial_state = {
            "message": message,
            "customer_id": customer_id,
            "conversation_id": conversation_id,
            "context": context or {},
        }

        # Run workflow
        final_state = await self.workflow.ainvoke(initial_state)

        return final_state.get("final_response")

    def get_workflow_info(self) -> Dict[str, Any]:
        """Get workflow information."""
        return {
            "agents": [
                "IntentClassifier",
                "AccountAgent",
                "GeneralAgent",
                "ProductAgent",
                "ComplianceChecker",
                "HumanAgent",
            ],
            "flow": [
                "START",
                "  ↓",
                "CLASSIFY (IntentClassifier)",
                "  ├→ ACCOUNT (AccountAgent)",
                "  ├→ GENERAL (GeneralAgent)",
                "  ├→ PRODUCT (ProductAgent) → COMPLIANCE (ComplianceChecker)",
                "  └→ HUMAN (HumanAgent)",
                "  ↓",
                "END (Response Formatting)",
            ],
            "intents": [
                "account_inquiry",
                "general_inquiry",
                "product_inquiry",
                "complaint",
            ],
        }


--- START OF FILE: ./app/agents/general_agent.py ---
"""
General Agent

Handles general inquiries and FAQ requests.
Provides help, information, and support.
"""

from typing import Dict, Any, Optional, List
from groq import AsyncGroq

from app.agents.base import BaseAgent, AgentConfig, AgentResponse
from app.services import ProductService

class GeneralAgent(BaseAgent):
    """
    General agent for FAQ and support queries.

    Provides:
    - General banking information
    - FAQ answers
    - Help and support
    - Service information
    """

    # FAQ Knowledge base
    FAQ_DATABASE = {
        "opening_account": {
            "question": "How do I open an account?",
            "answer": (
                "To open an account with us:\n"
                "1. Visit our website or mobile app\n"
                "2. Click 'Open Account'\n"
                "3. Provide personal information\n"
                "4. Verify your identity\n"
                "5. Fund your account\n\n"
                "The process takes about 10 minutes."
            ),
        },
        "contact_support": {
            "question": "How do I contact support?",
            "answer": (
                "You can contact our support team at:\n"
                "📞 Phone: +44-20-XXXX-XXXX\n"
                "📧 Email: support@fca-bank.com\n"
                "💬 Live Chat: Available 9am-6pm weekdays\n"
                "🕐 Hours: Monday-Friday, 9am-6pm GMT\n\n"
                "Our team typically responds within 24 hours."
            ),
        },

        "fees": {
            "question": "What are your account fees?",
            "answer": (
                "We offer fee-free banking:\n"
                "✅ No monthly account fees\n"
                "✅ No transfer fees (domestic)\n"
                "✅ No ATM fees at partner ATMs\n"
                "⚠️ International transfers: £10 + exchange rate\n"
                "⚠️ Overdraft charges apply\n\n"
                "See our full fee schedule at bank.com/fees"
            ),
        },
        "interest_rates": {
            "question": "What interest rates do you offer?",
            "answer": (
                "Current Interest Rates:\n"
                "💰 Savings Account: Up to 4.5% AER\n"
                "💰 Fixed Bond 1-year: 5.1% AER\n"
                "💰 Fixed Bond 3-year: 4.8% AER\n"
                "💳 Credit Cards: 21.9% APR (representative)\n"
                "📌 Mortgage: From 3.99% APR\n\n"
                "Rates subject to change. See full rates at bank.com/rates"
            ),
        },
        "security": {
            "question": "Is my money safe with you?",
            "answer": (
                "Your money is protected:\n"
                "🔒 FSCS Protected: Up to £85,000\n"
                "🔐 256-bit Encryption\n"
                "🛡️ Multi-factor Authentication\n"
                "📋 FCA Regulated\n"
                "🔍 Regular Security Audits\n\n"
                "We take security seriously."
            ),
        },
        "mobile_app": {
            "question": "What can I do in the mobile app?",
            "answer": (
                "Available features:\n"
                "✅ Check balance and transactions\n"
                "✅ Transfer money\n"
                "✅ Pay bills\n"
                "✅ Apply for products\n"
                "✅ Contact support\n"
                "✅ View statements\n"
                "✅ Manage cards\n\n"
                "Download from App Store or Google Play"
            ),
        },
    }

    def __init__(self, config: Optional[AgentConfig] = None,    product_service: ProductService = None,
    **kwargs):
        """Initialize general agent."""
        super().__init__(name="general_agent", config=config)
        self.client = AsyncGroq(api_key=self.config.api_key)
        self.product_service = product_service or ProductService()

    # ========================================================================
    # ABSTRACT METHOD IMPLEMENTATIONS
    # ========================================================================

    def _get_description(self) -> str:
        """Get agent description."""
        return (
            "General Agent - Answers general questions, FAQs, and provides "
            "support information about banking services."
        )

    def _get_capabilities(self) -> List[str]:
        """Get agent capabilities."""
        return [
            "FAQ answers",
            "General banking information",
            "Support information",
            "Account opening guidance",
            "Fee and rate information",
            "Security information",
            "Service details",
        ]

    # ========================================================================
    # CORE PROCESSING
    # ========================================================================

    async def process(
        self,
        input_data: Dict[str, Any],
        context: Optional[Dict[str, Any]] = None,
    ) -> AgentResponse:
        """
        Process general inquiry.

        Args:
            input_data: Must contain 'message'
            context: Optional context

        Returns:
            AgentResponse: Answer to inquiry
        """
        self.log_request(input_data)

        try:
            await self.validate_input(input_data)

            message = input_data.get("message", "")
            if not message:
                raise ValueError("message is required")

            # Try to find FAQ match
            faq_result = self._search_faq(message)

            if faq_result:
                response = self.create_response(
                    content=faq_result["answer"],
                    metadata={
                        "source": "faq",
                        "faq_type": faq_result["type"],
                        "matched_question": faq_result["question"],
                    },
                    confidence=0.95,
                )
            else:
                # Fall back to LLM for general inquiry
                response = await self._process_with_llm(message)

            self.log_response(response)
            return response

        except Exception as e:
            self.logger.error(f"General agent error: {e}")
            error_response = self.create_response(
                content=(
                    "I'm not sure how to answer that. "
                    "Please contact our support team at support@bank.com "
                    "or call 0800-123-4567."
                ),
                metadata={"error": str(e)},
                confidence=0.0,
            )
            return error_response

    # ========================================================================
    # FAQ PROCESSING
    # ========================================================================

    def _search_faq(self, query: str) -> Optional[Dict[str, str]]:
        """
        Search FAQ database for matching question.

        Args:
            query: Customer query

        Returns:
            dict or None: Matching FAQ or None
        """
        query_lower = query.lower()

        # Search by keywords
        for faq_type, faq_data in self.FAQ_DATABASE.items():
            question_lower = faq_data["question"].lower()

            # Exact match
            if query_lower == question_lower:
                return {
                    "type": faq_type,
                    "question": faq_data["question"],
                    "answer": faq_data["answer"],
                }

            # Keyword match (at least 2 matching words)
            query_words = set(query_lower.split())
            question_words = set(question_lower.split())
            matches = query_words & question_words

            if len(matches) >= 2:
                return {
                    "type": faq_type,
                    "question": faq_data["question"],
                    "answer": faq_data["answer"],
                }

        return None

    async def _process_with_llm(self, message: str) -> AgentResponse:
        """
        Process general query using LLM.

        Args:
            message: Customer message

        Returns:
            AgentResponse: Answer
        """
        # Build FAQ context
        faq_context = self._build_faq_context()

        prompt = (
            f"Customer Question: {message}\n\n"
            f"Available FAQ Information:\n{faq_context}\n\n"
            f"Answer the customer's question helpfully and accurately. "
            f"If you don't know the answer, direct them to contact support."
        )

        response = await self.client.chat.completions.create(
            model=self.config.model_name,
            messages=[
                {
                    "role": "system",
                    "content": (
                        "You are a helpful bank support agent. "
                        "Answer general questions about banking services accurately. "
                        "Be friendly and informative."
                    ),
                },
                {"role": "user", "content": prompt},
            ],
            temperature=0.7,
            max_tokens=self.config.max_tokens,
        )

        content = response.choices[0].message.content

        return self.create_response(
            content=content,
            metadata={
                "source": "llm",
                "faq_context": len(self.FAQ_DATABASE),
            },
            confidence=0.85,
        )

    def _build_faq_context(self) -> str:
        """Build FAQ context for LLM prompt."""
        context = ""
        for faq_type, faq_data in self.FAQ_DATABASE.items():
            context += f"Q: {faq_data['question']}\nA: {faq_data['answer']}\n\n"
        return context

    # ========================================================================
    # HELPER METHODS
    # ========================================================================

    def get_faq_topics(self) -> List[str]:
        """Get list of FAQ topics."""
        return list(self.FAQ_DATABASE.keys())

    def get_faq_by_topic(self, topic: str) -> Optional[Dict[str, str]]:
        """Get FAQ by topic."""
        return self.FAQ_DATABASE.get(topic)


--- START OF FILE: ./app/agents/compliance_checker.py ---
"""
Compliance Checker Agent

Ensures all communications and recommendations comply with FCA regulations.
Validates messages, products, and customer interactions for regulatory compliance.
"""

from typing import Dict, Any, Optional, List
from groq import AsyncGroq

from app.agents.base import BaseAgent, AgentConfig, AgentResponse


class ComplianceCheckerAgent(BaseAgent):
    """
    Compliance checker agent.

    Validates communications and recommendations for FCA compliance.
    """

    # ========================================================================
    # COMPLIANCE RULES
    # ========================================================================

    COMPLIANCE_RULES = {
        "prohibited_words": [
            "guaranteed",
            "risk-free",
            "no risk",
            "can't lose",
            "zero risk",
            "100% safe",
            "definitely",
            "promise",
        ],
        "required_disclaimers": {
            "investment": "Investments can go down as well as up",
            "loan": "Subject to status and affordability assessment",
            "credit": "Representative APR - your rate may differ",
            "savings": "Interest rates are variable and subject to change",
        },
        "sensitive_topics": [
            "debt",
            "bankruptcy",
            "foreclosure",
            "repossession",
            "default",
            "arrears",
        ],
        "mandatory_warnings": {
            "high_risk": "This product carries significant risk",
            "affordability": "Borrow only what you can afford to repay",
            "credit_impact": "Missed payments may affect your credit score",
        },
    }

    # FCA Principles (PRIN)
    FCA_PRINCIPLES = [
        "Integrity: Act with integrity in all dealings",
        "Skill, care and diligence: Exercise due skill, care and diligence",
        "Management and control: Take reasonable care to organize affairs responsibly",
        "Financial prudence: Maintain adequate financial resources",
        "Market conduct: Observe proper standards of market conduct",
        "Customers' interests: Pay due regard to customers' interests",
        "Communications: Pay due regard to information needs and communicate fairly",
        "Conflicts of interest: Manage conflicts of interest fairly",
        "Customers: relationships of trust: Take reasonable care for suitable relationships",
        "Clients' assets: Arrange adequate protection for clients' assets",
        "Relations with regulators: Deal with regulators in open and cooperative way",
    ]

    def __init__(self, config: Optional[AgentConfig] = None):
        """Initialize compliance checker agent."""
        super().__init__(name="compliance_checker", config=config)

        # Initialize Groq client
        self.client = AsyncGroq(api_key=self.config.api_key)

    # ========================================================================
    # ABSTRACT METHOD IMPLEMENTATIONS
    # ========================================================================

    def _get_description(self) -> str:
        """Get agent description."""
        return (
            "Compliance Checker Agent - Validates all communications and "
            "recommendations for FCA regulatory compliance."
        )

    def _get_capabilities(self) -> List[str]:
        """Get agent capabilities."""
        return [
            "FCA compliance validation",
            "Prohibited language detection",
            "Required disclaimer verification",
            "Risk assessment",
            "Regulatory guidance",
        ]

    # ========================================================================
    # CORE PROCESSING
    # ========================================================================

    async def process(
        self,
        input_data: Dict[str, Any],
        context: Optional[Dict[str, Any]] = None,
    ) -> AgentResponse:
        """
        Check content for FCA compliance.

        Args:
            input_data: Must contain 'content' (text to check)
            context: Optional context (product type, customer info)

        Returns:
            AgentResponse: Compliance check result
        """
        # Validate input
        await self.validate_input(input_data)

        # Log request
        self.log_request(input_data)

        # Extract content
        content = input_data.get("content", "")
        if not content:
            raise ValueError("Content is required for compliance check")

        # Extract context
        product_type = context.get("product_type", "") if context else ""

        # Perform compliance check
        compliance_result = await self._check_compliance(content, product_type)

        # Determine if compliant
        is_compliant = compliance_result["is_compliant"]

        # Build response message
        if is_compliant:
            response_content = "✅ Content is FCA compliant"
        else:
            response_content = f"⚠️ Compliance issues detected:\n\n"
            for issue in compliance_result["issues"]:
                response_content += f"- {issue}\n"

        # Create response
        response = self.create_response(
            content=response_content,
            metadata={
                "is_compliant": is_compliant,
                "issues": compliance_result["issues"],
                "warnings": compliance_result["warnings"],
                "suggestions": compliance_result["suggestions"],
                "required_disclaimers": compliance_result["required_disclaimers"],
            },
            confidence=compliance_result["confidence"],
        )

        # Log response
        self.log_response(response)

        return response

    # ========================================================================
    # COMPLIANCE CHECKING LOGIC
    # ========================================================================

    async def _check_compliance(
        self,
        content: str,
        product_type: str,
    ) -> Dict[str, Any]:
        """
        Check content for compliance issues.

        Args:
            content: Text to check
            product_type: Type of product (for context)

        Returns:
            dict: Compliance check results
        """
        # Rule-based checks
        rule_issues = self._check_rules(content)

        # LLM-based deep check
        llm_result = await self._llm_compliance_check(content, product_type)

        # Combine results
        all_issues = rule_issues + llm_result["issues"]

        # Determine compliance
        is_compliant = len(all_issues) == 0

        # Get required disclaimers
        required_disclaimers = self._get_required_disclaimers(content, product_type)

        return {
            "is_compliant": is_compliant,
            "issues": all_issues,
            "warnings": llm_result["warnings"],
            "suggestions": llm_result["suggestions"],
            "required_disclaimers": required_disclaimers,
            "confidence": 0.95 if is_compliant else 0.85,
        }

    def _check_rules(self, content: str) -> List[str]:
        """
        Check content against rule-based compliance.

        Args:
            content: Text to check

        Returns:
            List[str]: List of issues found
        """
        issues = []
        content_lower = content.lower()

        # Check for prohibited words
        for word in self.COMPLIANCE_RULES["prohibited_words"]:
            if word in content_lower:
                issues.append(
                    f"Prohibited language detected: '{word}'. "
                    f"FCA requires balanced, not misleading information."
                )

        return issues

    async def _llm_compliance_check(
        self,
        content: str,
        product_type: str,
    ) -> Dict[str, Any]:
        """
        Deep compliance check using LLM.

        Args:
            content: Text to check
            product_type: Product type

        Returns:
            dict: LLM check results
        """
        # Build prompt
        prompt = self._build_compliance_prompt(content, product_type)

        # Call LLM
        response = await self.client.chat.completions.create(
            model=self.config.model_name,
            messages=[
                {
                    "role": "system",
                    "content": self._get_system_prompt(),
                },
                {
                    "role": "user",
                    "content": prompt,
                },
            ],
            temperature=0.1,  # Very low for consistent compliance checks
            max_tokens=self.config.max_tokens,
        )

        # Parse response
        result = self._parse_compliance_response(response.choices[0].message.content)

        return result

    def _build_compliance_prompt(
        self,
        content: str,
        product_type: str,
    ) -> str:
        """
        Build prompt for compliance check.

        Args:
            content: Text to check
            product_type: Product type

        Returns:
            str: Formatted prompt
        """
        # FCA principles summary
        principles_text = "\n".join([f"- {p}" for p in self.FCA_PRINCIPLES[:7]])

        product_context = ""
        if product_type:
            product_context = f"\nProduct Type: {product_type}"

        prompt = f"""Review the following content for FCA (Financial Conduct Authority) compliance.

Key FCA Principles:
{principles_text}

Content to Review:
"{content}"{product_context}

Check for:
1. Misleading or unclear language
2. Missing risk warnings
3. Unbalanced information (only benefits, no risks)
4. Guarantees or promises that can't be kept
5. Clarity of terms and conditions
6. Appropriate disclaimers
7. Fair treatment of customers

Respond in this format:
COMPLIANT: <YES or NO>
ISSUES: <comma-separated list of issues, or NONE>
WARNINGS: <comma-separated warnings, or NONE>
SUGGESTIONS: <improvements to make content more compliant>

Be strict - FCA compliance is critical for customer protection.
"""

        return prompt

    def _get_system_prompt(self) -> str:
        """
        Get system prompt for LLM.

        Returns:
            str: System prompt
        """
        return """You are an FCA compliance expert for a UK financial services company.

Your role:
- Review all customer-facing content for regulatory compliance
- Identify potential violations of FCA principles
- Ensure clear, fair, and not misleading communications
- Verify appropriate risk warnings and disclaimers
- Protect customer interests

FCA Standards:
- Communications must be clear, fair and not misleading (PRIN 7)
- Customers' interests must be paramount (PRIN 6)
- All material information must be disclosed
- Risk warnings must be prominent and clear
- No guarantees or promises unless absolutely certain
- Representative APR must be disclosed for credit products

Be thorough and strict - compliance violations can result in significant penalties."""

    def _parse_compliance_response(self, response_text: str) -> Dict[str, Any]:
        """
        Parse LLM compliance response.

        Args:
            response_text: Raw LLM response

        Returns:
            dict: Parsed compliance result
        """
        # Extract fields
        compliant = True
        issues = []
        warnings = []
        suggestions = ""

        for line in response_text.strip().split("\n"):
            line = line.strip()

            if line.startswith("COMPLIANT:"):
                compliant_str = line.split(":", 1)[1].strip().upper()
                compliant = compliant_str == "YES"
            elif line.startswith("ISSUES:"):
                issues_str = line.split(":", 1)[1].strip()
                if issues_str != "NONE":
                    issues = [i.strip() for i in issues_str.split(",")]
            elif line.startswith("WARNINGS:"):
                warnings_str = line.split(":", 1)[1].strip()
                if warnings_str != "NONE":
                    warnings = [w.strip() for w in warnings_str.split(",")]
            elif line.startswith("SUGGESTIONS:"):
                suggestions = line.split(":", 1)[1].strip()

        return {
            "compliant": compliant,
            "issues": issues,
            "warnings": warnings,
            "suggestions": suggestions,
        }

    def _get_required_disclaimers(
        self,
        content: str,
        product_type: str,
    ) -> List[str]:
        """
        Get required disclaimers based on content and product type.

        Args:
            content: Message content
            product_type: Product type

        Returns:
            List[str]: Required disclaimers
        """
        disclaimers = []
        content_lower = content.lower()

        # Check product type
        if product_type:
            disclaimer = self.COMPLIANCE_RULES["required_disclaimers"].get(product_type)
            if disclaimer:
                disclaimers.append(disclaimer)

        # Check content for keywords
        if any(word in content_lower for word in ["invest", "return", "profit"]):
            disclaimers.append(self.COMPLIANCE_RULES["required_disclaimers"]["investment"])

        if any(word in content_lower for word in ["loan", "borrow", "mortgage"]):
            disclaimers.append(self.COMPLIANCE_RULES["required_disclaimers"]["loan"])

        if any(word in content_lower for word in ["credit", "apr", "interest rate"]):
            disclaimers.append(self.COMPLIANCE_RULES["required_disclaimers"]["credit"])

        # Check for sensitive topics
        for topic in self.COMPLIANCE_RULES["sensitive_topics"]:
            if topic in content_lower:
                disclaimers.append(
                    "We understand this may be a difficult situation. "
                    "Free debt advice is available from MoneyHelper or StepChange."
                )
                break

        return list(set(disclaimers))  # Remove duplicates

    # ========================================================================
    # HELPER METHODS
    # ========================================================================

    def get_prohibited_words(self) -> List[str]:
        """
        Get list of prohibited words.

        Returns:
            List[str]: Prohibited words
        """
        return self.COMPLIANCE_RULES["prohibited_words"]

    def get_fca_principles(self) -> List[str]:
        """
        Get FCA principles.

        Returns:
            List[str]: FCA principles
        """
        return self.FCA_PRINCIPLES


--- START OF FILE: ./app/agents/__init__.py ---
"""
Agents Package

Multi-agent system for FCA financial services support.
"""

from app.agents.base import BaseAgent, AgentConfig, AgentResponse
from app.agents.intent_classifier import IntentClassifierAgent
from app.agents.product_recommender import ProductRecommenderAgent
from app.agents.compliance_checker import ComplianceCheckerAgent
from app.agents.general_agent import GeneralAgent
from app.agents.account_agent import AccountAgent
from app.agents.human_agent import HumanAgent

# Services for dependency injection
from app.services import (
    AccountService,
    CustomerService,
    TransactionService,
    ProductService,
    ConversationService,
)

__all__ = [
    # Agents
    "BaseAgent",
    "AgentConfig",
    "AgentResponse",
    "AccountAgent",
    "IntentClassifierAgent",
    "ProductRecommenderAgent",
    "ComplianceCheckerAgent",
    "GeneralAgent",
    "HumanAgent",
    # Services
    "AccountService",
    "CustomerService",
    "TransactionService",
    "ProductService",
    "ConversationService",
]


--- START OF FILE: ./app/agents/account_agent.py ---
from typing import Dict, Any, Optional, List
from datetime import datetime
from groq import AsyncGroq

from app.agents.base import BaseAgent, AgentConfig, AgentResponse
from app.services import AccountService, CustomerService, TransactionService

class AccountAgent(BaseAgent):
    def __init__(self, config: Optional[AgentConfig] = None
                 ,account_service: AccountService = None,
        customer_service: CustomerService = None,
        transaction_service: TransactionService = None,
        **kwargs):
        super().__init__(name="account_agent", config=config)
        self.client = AsyncGroq(api_key=self.config.api_key)

        if account_service is None or customer_service is None or transaction_service is None:
            raise ValueError("AccountAgent requires DB-backed services (inject AccountService/CustomerService/TransactionService).")

        self.account_service = account_service
        self.customer_service = customer_service
        self.transaction_service = transaction_service

    def _get_description(self) -> str:
        return (
            "Account Agent - Handles customer account inquiries including "
            "balance checks, transaction history, account statements, and operations."
        )

    def _get_capabilities(self) -> List[str]:
        return [
            "Account balance retrieval",
            "Transaction history lookup",
            "Account statement generation",
            "Account detail queries",
            "Natural language account information",
        ]

    async def process(
        self,
        input_data: Dict[str, Any],
        context: Optional[Dict[str, Any]] = None,
    ) -> AgentResponse:
        self.log_request(input_data)

        try:
            await self.validate_input(input_data)

            customer_id = input_data.get("customer_id")
            message = input_data.get("message", "")
            if not customer_id:
                raise ValueError("customer_id is required")

            query_type = self._determine_query_type(message)
            result = await self._fetch_real_data(customer_id, query_type, message)
            response = self.create_response(
                content=result["response"],
                metadata={
                    "query_type": query_type,
                    "account_data": result.get("data"),
                    "data_points": result.get("data_points", []),
                },
                confidence=0.95,
            )
            self.log_response(response)
            return response

        except Exception as e:
            self.logger.error(f"Account query error: {e}")
            return self.create_response(
                content=f"I couldn't retrieve your account information. Error: {str(e)}",
                metadata={"error": str(e)},
                confidence=0.0,
            )

    def _determine_query_type(self, message: str) -> str:
        message_lower = message.lower()
        if any(word in message_lower for word in ["balance", "how much", "account total", "have"]):
            return "balance"
        elif any(word in message_lower for word in ["transaction", "history", "recent", "activity"]):
            return "transactions"
        elif any(word in message_lower for word in ["statement", "download", "pdf", "email"]):
            return "statement"
        elif any(word in message_lower for word in ["details", "information", "account info"]):
            return "details"
        else:
            return "general"

    async def _fetch_real_data(self, customer_id: int, query_type: str, message: str) -> Dict[str, Any]:
        """
        Fetch real data from database services.
        """
        try:
            # 1) Customer lookup uses INTERNAL PK (customers.id: int)
            customer = await self.customer_service.get_customer(customer_id)
            if not customer:
                return {"response": f"Customer {customer_id} not found", "data": {}, "data_points": []}

            # 2) Accounts lookup uses EXTERNAL customer id (accounts.customer_id: varchar)
            external_customer_id = getattr(customer, "customer_id", None)
            if not external_customer_id:
                return {
                    "response": f"Customer {customer_id} is missing external customer_id",
                    "data": {},
                    "data_points": [],
                }

            # Helper: safely pull account fields that differ by schema
            def _account_summary(acct):
                return {
                    "account_number": getattr(acct, "account_number", None),
                    "type": getattr(acct, "type", None),  # <-- real column name is `type`
                    "status": getattr(acct, "status", None),
                    "balance": float(getattr(acct, "balance", 0.0) or 0.0),
                    "created_at": getattr(acct, "created_at", None),
                }

            if query_type == "balance":
                accounts = await self.account_service.get_accounts_by_customer(external_customer_id)
                if not accounts:
                    response = (
                        "Your current account balance is 0.00.\n\n"
                        "Account: N/A\n"
                        "Account Type: N/A\n"
                        f"Last Updated: {datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S')}"
                    )
                    return {
                        "response": response,
                        "data": {"balance": 0.0, "account_number": None, "type": None},
                        "data_points": ["balance", "account_number", "type"],
                    }

                acct = accounts[0]
                acct_num = getattr(acct, "account_number", None)
                acct_type = getattr(acct, "type", None)
                balance = float(getattr(acct, "balance", 0.0) or 0.0)

                response = (
                    f"Your current account balance is {balance:,.2f}.\n\n"
                    f"Account: {acct_num or 'N/A'}\n"
                    f"Account Type: {acct_type or 'N/A'}\n"
                    f"Last Updated: {datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S')}"
                )

                return {
                    "response": response,
                    "data": {"balance": balance, "account_number": acct_num, "type": acct_type},
                    "data_points": ["balance", "account_number", "type"],
                }

            elif query_type == "transactions":
                accounts = await self.account_service.get_accounts_by_customer(external_customer_id)
                if not accounts:
                    return {"response": f"No accounts found for customer {customer_id}", "data": {}, "data_points": []}

                acct = accounts[0]
                account_id = getattr(acct, "id", None)
                if account_id is None:
                    return {"response": "Account record missing id", "data": {}, "data_points": []}

                # Note: this service actually expects account_id (despite method name) in your codebase
                transactions = await self.transaction_service.get_transactions_by_account(account_id, limit=10)

                response = "Your recent transactions (last 10):\n\n"
                for i, txn in enumerate(transactions, 1):
                    response += (
                        f"{i}. {getattr(txn, 'description', 'N/A')}\n"
                        f" Amount: {float(getattr(txn, 'amount', 0.0) or 0.0):,.2f}\n"
                        f" Date: {getattr(txn, 'transaction_date', 'N/A')}\n"
                        f" Balance: {float(getattr(txn, 'balance_after', 0.0) or 0.0):,.2f}\n\n"
                    )

                return {
                    "response": response,
                    "data": {
                        "account": _account_summary(acct),
                        "transactions": [
                            {
                                "description": getattr(t, "description", None),
                                "amount": getattr(t, "amount", None),
                                "date": getattr(t, "transaction_date", None),
                            }
                            for t in transactions
                        ],
                    },
                    "data_points": ["transactions", "dates", "amounts"],
                }

            elif query_type == "statement":
                accounts = await self.account_service.get_accounts_by_customer(external_customer_id)
                acct = accounts[0] if accounts else None
                account_number = getattr(acct, "account_number", None) if acct else None

                response = (
                    f"Statement Request for Account {account_number or 'N/A'}\n\n"
                    "Your account statement has been generated.\n"
                    f"A PDF will be emailed to {getattr(customer, 'email', 'your email')} shortly.\n\n"
                    "You can also download it from your online banking portal:\n"
                    "- Log in to your account\n"
                    "- Go to Documents > Statements\n"
                    "- Select the date range\n"
                    "- Click Download PDF\n\n"
                    "If you need help, contact us at support@bank.com"
                )

                return {
                    "response": response,
                    "data": {"account_number": account_number, "email": getattr(customer, "email", None)},
                    "data_points": ["statement_generated", "email", "account_number"],
                }

            elif query_type == "details":
                accounts = await self.account_service.get_accounts_by_customer(external_customer_id)
                if not accounts:
                    return {"response": f"No accounts found for customer {customer_id}", "data": {}, "data_points": []}

                acct = accounts[0]
                acct_num = getattr(acct, "account_number", None)
                acct_type = getattr(acct, "type", None)
                created_at = getattr(acct, "created_at", None)  # prefer created_at over created_date

                response = (
                    f"Account Details for Customer {customer_id}\n\n"
                    f"Account Number: {acct_num or 'N/A'}\n"
                    f"Account Type: {acct_type or 'N/A'}\n"
                    f"Current Balance: {float(getattr(acct, 'balance', 0.0) or 0.0):,.2f}\n"
                    f"Account Status: {getattr(acct, 'status', 'N/A')}\n"
                    f"Created: {created_at or 'N/A'}\n"
                    f"Last Updated: {datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S')}\n\n"
                    "Contact information on file:\n"
                    f"Email: {getattr(customer, 'email', 'N/A')}\n"
                    f"Phone: {getattr(customer, 'phone', 'N/A')}"
                )

                return {
                    "response": response,
                    "data": {
                        "account_number": acct_num,
                        "type": acct_type,
                        "balance": float(getattr(acct, "balance", 0.0) or 0.0),
                        "status": getattr(acct, "status", None),
                        "created_at": created_at,
                    },
                    "data_points": ["account_number", "type", "balance", "status", "created_at"],
                }

            else:
                accounts = await self.account_service.get_accounts_by_customer(external_customer_id)
                response = f"Account information for customer {customer_id}. How else can I help with your account?"
                return {
                    "response": response,
                    "data": {"account_count": len(accounts) if accounts else 0},
                    "data_points": ["account_info"],
                }

        except Exception as e:
            self.logger.error(f"Error fetching real data: {e}")
            return {"response": f"Error retrieving account information: {str(e)}", "data": {}, "data_points": []}


--- START OF FILE: ./app/agents/intent_classifier.py ---
"""
Intent Classifier Agent

Classifies customer intent from messages to route to appropriate specialists.
"""

from typing import Dict, Any, Optional, List
from groq import AsyncGroq

from app.agents.base import BaseAgent, AgentConfig, AgentResponse
from app.services import ProductService




class IntentClassifierAgent(BaseAgent):
    """
    Intent classifier agent.

    Analyzes customer messages to determine intent and route appropriately.
    """

    # ========================================================================
    # INTENT CATEGORIES
    # ========================================================================

    INTENTS = {
        "loan_inquiry": {
            "description": "Customer asking about loans (mortgage, personal, business)",
            "examples": [
                "I want to apply for a mortgage",
                "What are your loan interest rates?",
                "Can I get a personal loan?",
            ],
            "routing": "product_recommender",
        },
        "account_inquiry": {
            "description": "Questions about EXISTING account details (balance, transactions, statements)",
            "examples": [
                "What is my account balance?",
                "Show me my recent transactions",
                "I need a bank statement",
                "What's my transaction history?",
                "How much can I spend?",
            ],
            "routing": "account_agent",
        },
        "credit_card": {
            "description": "Credit card related queries",
            "examples": [
                "I want to apply for a credit card",
                "What credit cards do you offer?",
                "Increase my credit limit",
            ],
            "routing": "product_recommender",
        },
        "complaint": {
            "description": "Customer complaints or issues",
            "examples": [
                "I'm not happy with the service",
                "This is taking too long",
                "I want to make a complaint",
                "I'm unhappy with your service",
                "I'm disappointed",
                "My card was stolen!",
                "I need immediate help!",
                "This is urgent!",
                "Emergency! My card is missing!"
            ],
            "routing": "human_agent",
        },
        "general_inquiry": {
            "description": "General questions, FAQs, how-to questions, or help/support contact requests",
            "examples": [
                "How do I open an account?",
                "How do I contact support?",
                "What services do you offer?",
                "How can I create a new account?",
                "How do I get help?",
                "What are your support hours?",
                "How do I reach customer service?",
            ],
            "routing": "general_agent",
        },
    }

    def __init__(self, config: Optional[AgentConfig] = None,
                 product_service: ProductService = None,
    **kwargs):
        """Initialize intent classifier agent."""
        super().__init__(name="intent_classifier", config=config)

        # Initialize Groq client
        self.client = AsyncGroq(api_key=self.config.api_key)
        self.product_service = product_service or ProductService()


    # ========================================================================
    # ABSTRACT METHOD IMPLEMENTATIONS
    # ========================================================================

    def _get_description(self) -> str:
        """Get agent description."""
        return (
            "Intent Classifier Agent - Analyzes customer messages to determine "
            "intent and route to appropriate specialist agents."
        )

    def _get_capabilities(self) -> List[str]:
        """Get agent capabilities."""
        return [
            "Intent classification",
            "Sentiment analysis",
            "Confidence scoring",
            "Multi-language support",
            "Context-aware classification",
        ]

    # ========================================================================
    # CORE PROCESSING
    # ========================================================================

    async def process(
        self,
        input_data: Dict[str, Any],
        context: Optional[Dict[str, Any]] = None,
    ) -> AgentResponse:
        """
        Classify intent from customer message.

        Args:
            input_data: Must contain 'message' key
            context: Optional conversation context

        Returns:
            AgentResponse: Classification result
        """
        # Validate input
        await self.validate_input(input_data)

        # Log request
        self.log_request(input_data)

        # Extract message
        message = input_data.get("message", "")
        if not message:
            raise ValueError("Message is required")

        # Classify intent
        classification = await self._classify_intent(message, context)

        # Create response
        response = self.create_response(
            content=classification["intent"],
            metadata={
                "intent": classification["intent"],
                "sentiment": classification["sentiment"],
                "routing": classification["routing"],
                "explanation": classification["explanation"],
            },
            confidence=classification["confidence"],
        )

        # Log response
        self.log_response(response)

        return response

    # ========================================================================
    # CLASSIFICATION LOGIC
    # ========================================================================

    async def _classify_intent(
        self,
        message: str,
        context: Optional[Dict[str, Any]] = None,
    ) -> Dict[str, Any]:
        """
        Classify intent using LLM.

        Args:
            message: Customer message
            context: Optional context

        Returns:
            dict: Classification result
        """
        # Build prompt
        prompt = self._build_classification_prompt(message, context)

        # Call LLM
        response = await self.client.chat.completions.create(
            model=self.config.model_name,
            messages=[
                {
                    "role": "system",
                    "content": self._get_system_prompt(),
                },
                {
                    "role": "user",
                    "content": prompt,
                },
            ],
            temperature=self.config.temperature,
            max_tokens=self.config.max_tokens,
        )

        # Parse response
        result = self._parse_llm_response(response.choices[0].message.content)

        return result

    def _build_classification_prompt(
        self,
        message: str,
        context: Optional[Dict[str, Any]] = None,
    ) -> str:
        """
        Build prompt for classification.

        Args:
            message: Customer message
            context: Optional context

        Returns:
            str: Formatted prompt
        """
        # Intent descriptions
        intent_descriptions = "\n".join([
            f"- {intent}: {data['description']}"
            for intent, data in self.INTENTS.items()
        ])

        # Build prompt
        prompt = f"""Classify the following customer message into one of these intents:

{intent_descriptions}

Customer Message: "{message}"

Respond in this exact format:
INTENT: <intent_name>
CONFIDENCE: <0.0-1.0>
SENTIMENT: <positive|neutral|negative>
EXPLANATION: <brief explanation>
"""

        # Add context if provided
        if context and context.get("conversation_history"):
            history = "\n".join([
                f"{msg['role']}: {msg['content']}"
                for msg in context["conversation_history"][-3:]  # Last 3 messages
            ])
            prompt += f"\n\nConversation History:\n{history}"

        return prompt

    def _get_system_prompt(self) -> str:
        """
        Get system prompt for LLM.

        Returns:
            str: System prompt
        """
        return """You are an expert intent classifier for a UK financial services company (FCA regulated).

Your job is to analyze customer messages and determine their intent accurately.

Guidelines:
- Be precise and confident in your classifications
- Consider context from conversation history
- Detect sentiment (positive, neutral, negative)
- Provide clear explanations
- Use the exact format requested"""

    def _parse_llm_response(self, response_text: str) -> Dict[str, Any]:
        """
        Parse LLM response into structured format.

        Args:
            response_text: Raw LLM response

        Returns:
            dict: Parsed classification
        """
        # Extract fields
        intent = "general_inquiry"  # Default
        confidence = 0.5
        sentiment = "neutral"
        explanation = ""

        for line in response_text.strip().split("\n"):
            line = line.strip()

            if line.startswith("INTENT:"):
                intent = line.split(":", 1)[1].strip().lower()
            elif line.startswith("CONFIDENCE:"):
                try:
                    confidence = float(line.split(":", 1)[1].strip())
                except:
                    confidence = 0.5
            elif line.startswith("SENTIMENT:"):
                sentiment = line.split(":", 1)[1].strip().lower()
            elif line.startswith("EXPLANATION:"):
                explanation = line.split(":", 1)[1].strip()

        # Get routing
        routing = self.INTENTS.get(intent, {}).get("routing", "general_agent")

        return {
            "intent": intent,
            "confidence": confidence,
            "sentiment": sentiment,
            "explanation": explanation,
            "routing": routing,
        }

    # ========================================================================
    # HELPER METHODS
    # ========================================================================

    def get_supported_intents(self) -> List[str]:
        """
        Get list of supported intents.

        Returns:
            List[str]: Intent names
        """
        return list(self.INTENTS.keys())

    def get_intent_info(self, intent: str) -> Optional[Dict[str, Any]]:
        """
        Get information about specific intent.

        Args:
            intent: Intent name

        Returns:
            dict or None: Intent information
        """
        return self.INTENTS.get(intent)


--- START OF FILE: ./app/agents/product_recommender.py ---
"""
Product Recommender Agent

Recommends financial products based on customer needs and profile.
FCA compliant recommendations with clear explanations.
"""

from typing import Dict, Any, Optional, List
from groq import AsyncGroq

from app.agents.base import BaseAgent, AgentConfig, AgentResponse
from app.services import ProductService

class ProductRecommenderAgent(BaseAgent):
    """
    Product recommender agent.

    Analyzes customer needs and recommends suitable financial products.
    """

    # ========================================================================
    # PRODUCT CATALOG
    # ========================================================================

    PRODUCTS = {
        "mortgages": {
            "fixed_rate_mortgage": {
                "name": "Fixed Rate Mortgage",
                "description": "Interest rate stays the same for agreed period",
                "rates": "From 3.99% APR",
                "terms": "2, 3, 5, or 10 year fixed terms",
                "suitable_for": ["First time buyers", "Remortgaging", "Stability seekers"],
                "min_deposit": "5%",
            },
            "tracker_mortgage": {
                "name": "Tracker Mortgage",
                "description": "Interest rate tracks Bank of England base rate",
                "rates": "Base rate + 1.5%",
                "terms": "Flexible terms",
                "suitable_for": ["Rate optimists", "Flexible borrowers"],
                "min_deposit": "10%",
            },
        },
        "savings": {
            "instant_access_saver": {
                "name": "Instant Access Savings",
                "description": "Access your money anytime without penalties",
                "rates": "Up to 4.25% AER",
                "terms": "No fixed term",
                "suitable_for": ["Emergency funds", "Short-term goals"],
                "min_balance": "£1",
            },
            "fixed_rate_bond": {
                "name": "Fixed Rate Bond",
                "description": "Fixed interest rate for set period",
                "rates": "Up to 5.10% AER",
                "terms": "1, 2, 3, or 5 years",
                "suitable_for": ["Long-term savings", "Higher returns"],
                "min_balance": "£1,000",
            },
        },
        "credit_cards": {
            "cashback_card": {
                "name": "Cashback Credit Card",
                "description": "Earn cashback on purchases",
                "rates": "Up to 1% cashback",
                "terms": "Representative 21.9% APR",
                "suitable_for": ["Regular spenders", "Paying full balance monthly"],
                "annual_fee": "£0",
            },
            "balance_transfer_card": {
                "name": "Balance Transfer Card",
                "description": "0% interest on transferred balances",
                "rates": "0% for 24 months",
                "terms": "3% transfer fee",
                "suitable_for": ["Debt consolidation", "Interest savings"],
                "annual_fee": "£0",
            },
        },
        "loans": {
            "personal_loan": {
                "name": "Personal Loan",
                "description": "Unsecured loan for any purpose",
                "rates": "From 6.9% APR",
                "terms": "1-7 years",
                "suitable_for": ["Home improvements", "Debt consolidation", "Major purchases"],
                "amount_range": "£1,000 - £35,000",
            },
        },
    }

    def __init__(self, config: Optional[AgentConfig] = None,    product_service: ProductService = None,
    **kwargs):
        """Initialize product recommender agent."""
        super().__init__(name="product_recommender", config=config)

        # Initialize Groq client
        self.client = AsyncGroq(api_key=self.config.api_key)
        self.productservice = product_service
        if self.productservice is None:
            raise ValueError("ProductRecommenderAgent requires ProductService injected with a DB session")


    # ========================================================================
    # ABSTRACT METHOD IMPLEMENTATIONS
    # ========================================================================

    def _get_description(self) -> str:
        """Get agent description."""
        return (
            "Product Recommender Agent - Analyzes customer needs and recommends "
            "suitable financial products with FCA-compliant explanations."
        )

    def _get_capabilities(self) -> List[str]:
        """Get agent capabilities."""
        return [
            "Product recommendation",
            "Needs analysis",
            "Personalization based on customer profile",
            "FCA compliance",
            "Clear product comparisons",
        ]

    # ========================================================================
    # CORE PROCESSING
    # ========================================================================

    async def process(
        self,
        input_data: Dict[str, Any],
        context: Optional[Dict[str, Any]] = None,
    ) -> AgentResponse:
        """
        Recommend products based on customer needs.

        Args:
            input_data: Must contain 'intent' or 'message'
            context: Optional customer context (profile, history)

        Returns:
            AgentResponse: Product recommendations
        """
        # Validate input
        await self.validate_input(input_data)

        # Log request
        self.log_request(input_data)

        # Extract intent and message
        intent = input_data.get("intent", "")
        message = input_data.get("message", "")

        # Get customer context
        customer_profile = context.get("customer", {}) if context else {}

        # Generate recommendations
        recommendations = await self._generate_recommendations(
            intent=intent,
            message=message,
            customer_profile=customer_profile,
        )

        # Create response
        response = self.create_response(
            content=recommendations["response_text"],
            metadata={
                "products": recommendations["products"],
                "reasoning": recommendations["reasoning"],
                "disclaimers": recommendations["disclaimers"],
            },
            confidence=recommendations["confidence"],
        )

        # Log response
        self.log_response(response)

        return response

    # ========================================================================
    # RECOMMENDATION LOGIC
    # ========================================================================

    async def _generate_recommendations(
        self,
        intent: str,
        message: str,
        customer_profile: Dict[str, Any],
    ) -> Dict[str, Any]:
        """
        Generate product recommendations using LLM.

        Args:
            intent: Customer intent
            message: Customer message
            customer_profile: Customer information

        Returns:
            dict: Recommendations with reasoning
        """
        # Determine product category
        category = self._determine_category(intent)

        # Get available products
        available_products = self._get_products_for_category(category)

        # Build prompt
        prompt = self._build_recommendation_prompt(
            intent=intent,
            message=message,
            customer_profile=customer_profile,
            available_products=available_products,
        )

        # Call LLM
        response = await self.client.chat.completions.create(
            model=self.config.model_name,
            messages=[
                {
                    "role": "system",
                    "content": self._get_system_prompt(),
                },
                {
                    "role": "user",
                    "content": prompt,
                },
            ],
            temperature=0.5,  # Lower for more consistent recommendations
            max_tokens=self.config.max_tokens,
        )

        # Parse response
        result = self._parse_recommendation_response(
            response.choices[0].message.content,
            available_products,
        )

        return result

    def _determine_category(self, intent: str) -> str:
        """
        Determine product category from intent.

        Args:
            intent: Customer intent

        Returns:
            str: Product category
        """
        intent_to_category = {
            "loan_inquiry": "mortgages",
            "mortgage_inquiry": "mortgages",
            "savings_inquiry": "savings",
            "credit_card": "credit_cards",
            "personal_loan": "loans",
        }

        return intent_to_category.get(intent, "mortgages")

    def _get_products_for_category(self, category: str) -> List[Dict[str, Any]]:
        """
        Get products for category.

        Args:
            category: Product category

        Returns:
            List[dict]: Available products
        """
        products = []
        category_products = self.PRODUCTS.get(category, {})

        for product_id, product_data in category_products.items():
            products.append({
                "id": product_id,
                **product_data,
            })

        return products

    def _build_recommendation_prompt(
        self,
        intent: str,
        message: str,
        customer_profile: Dict[str, Any],
        available_products: List[Dict[str, Any]],
    ) -> str:
        """
        Build prompt for recommendations.

        Args:
            intent: Customer intent
            message: Customer message
            customer_profile: Customer info
            available_products: Products to recommend from

        Returns:
            str: Formatted prompt
        """
        # Format products
        products_text = "\n\n".join([
            f"Product: {p['name']}\n"
            f"Description: {p['description']}\n"
            f"Rates: {p.get('rates', 'N/A')}\n"
            f"Terms: {p.get('terms', 'N/A')}\n"
            f"Suitable for: {', '.join(p.get('suitable_for', []))}"
            for p in available_products
        ])

        # Customer context
        customer_text = ""
        if customer_profile:
            is_vip = customer_profile.get("is_vip", False)
            customer_text = f"\n\nCustomer Profile:\n- VIP Status: {'Yes' if is_vip else 'No'}"

        prompt = f"""Based on the customer's needs, recommend the most suitable financial products.

Customer Intent: {intent}
Customer Message: "{message}"{customer_text}

Available Products:
{products_text}

Provide recommendations in this format:
RECOMMENDED PRODUCTS: <comma-separated product names>
REASONING: <why these products are suitable>
KEY BENEFITS: <main benefits for customer>
NEXT STEPS: <what customer should do>
CONFIDENCE: <0.0-1.0>

Guidelines:
- Recommend 1-3 most suitable products
- Explain clearly why each product fits their needs
- Be FCA compliant (clear, fair, not misleading)
- Include relevant disclaimers
- Consider customer profile (VIP gets premium options)
"""

        return prompt

    def _get_system_prompt(self) -> str:
        """
        Get system prompt for LLM.

        Returns:
            str: System prompt
        """
        return """You are a financial product recommendation specialist for a UK bank (FCA regulated).

Your role:
- Recommend suitable financial products based on customer needs
- Provide clear, fair, and not misleading information (FCA principles)
- Explain product features and benefits clearly
- Consider customer circumstances and profile
- Include appropriate disclaimers and warnings

FCA Compliance:
- Always be clear about rates, terms, and conditions
- Mention risks where relevant
- Don't promise guaranteed returns
- Be balanced in your recommendations
- Disclose representative APR where applicable

Remember: Customers must make informed decisions based on complete information."""

    def _parse_recommendation_response(
        self,
        response_text: str,
        available_products: List[Dict[str, Any]],
    ) -> Dict[str, Any]:
        """
        Parse LLM recommendation response.

        Args:
            response_text: Raw LLM response
            available_products: Available products

        Returns:
            dict: Parsed recommendations
        """
        # Extract fields
        recommended_products = []
        reasoning = ""
        key_benefits = ""
        next_steps = ""
        confidence = 0.8

        for line in response_text.strip().split("\n"):
            line = line.strip()

            if line.startswith("RECOMMENDED PRODUCTS:"):
                products_str = line.split(":", 1)[1].strip()
                recommended_products = [p.strip() for p in products_str.split(",")]
            elif line.startswith("REASONING:"):
                reasoning = line.split(":", 1)[1].strip()
            elif line.startswith("KEY BENEFITS:"):
                key_benefits = line.split(":", 1)[1].strip()
            elif line.startswith("NEXT STEPS:"):
                next_steps = line.split(":", 1)[1].strip()
            elif line.startswith("CONFIDENCE:"):
                try:
                    confidence = float(line.split(":", 1)[1].strip())
                except:
                    confidence = 0.8

        # Get full product details
        products = []
        for product_name in recommended_products:
            for p in available_products:
                if product_name.lower() in p["name"].lower():
                    products.append(p)
                    break

        # Build response text
        response_text = self._format_recommendation_text(
            products=products,
            reasoning=reasoning,
            key_benefits=key_benefits,
            next_steps=next_steps,
        )

        # Standard disclaimers
        disclaimers = [
            "Products subject to eligibility and affordability assessment",
            "Rates and terms subject to change",
            "Representative APR quoted - your rate may differ",
            "FCA regulated - complaints can be referred to Financial Ombudsman",
        ]

        return {
            "response_text": response_text,
            "products": products,
            "reasoning": reasoning,
            "disclaimers": disclaimers,
            "confidence": confidence,
        }

    def _format_recommendation_text(
        self,
        products: List[Dict[str, Any]],
        reasoning: str,
        key_benefits: str,
        next_steps: str,
    ) -> str:
        """
        Format recommendation as customer-facing text.

        Args:
            products: Recommended products
            reasoning: Why recommended
            key_benefits: Main benefits
            next_steps: What to do next

        Returns:
            str: Formatted text
        """
        text = "Based on your needs, I recommend the following products:\n\n"

        # Products
        for i, product in enumerate(products, 1):
            text += f"{i}. **{product['name']}**\n"
            text += f"   {product['description']}\n"
            text += f"   Rates: {product.get('rates', 'Varies')}\n"
            text += f"   Terms: {product.get('terms', 'Standard terms apply')}\n\n"

        # Reasoning
        if reasoning:
            text += f"**Why these products?**\n{reasoning}\n\n"

        # Benefits
        if key_benefits:
            text += f"**Key Benefits:**\n{key_benefits}\n\n"

        # Next steps
        if next_steps:
            text += f"**Next Steps:**\n{next_steps}\n\n"

        # Disclaimer
        text += "\n*Products subject to eligibility assessment. Representative rates shown - your rate may differ.*"

        return text

    # ========================================================================
    # HELPER METHODS
    # ========================================================================

    def get_product_categories(self) -> List[str]:
        """
        Get available product categories.

        Returns:
            List[str]: Category names
        """
        return list(self.PRODUCTS.keys())

    def get_products_in_category(self, category: str) -> List[Dict[str, Any]]:
        """
        Get all products in category.

        Args:
            category: Product category

        Returns:
            List[dict]: Products
        """
        return self._get_products_for_category(category)


--- START OF FILE: ./app/agents/human_agent.py ---
"""
Human Agent

Manages escalation to human specialists.
Handles complaints and complex issues.
"""

from typing import Dict, Any, Optional, List
from datetime import datetime
from enum import Enum

from app.agents.base import BaseAgent, AgentConfig, AgentResponse
from app.services import ConversationService

class EscalationPriority(str, Enum):
    """Escalation priority levels."""
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    URGENT = "urgent"


class HumanAgent(BaseAgent):
    """
    Human agent for escalations.

    Manages:
    - Complaint escalations
    - Complex issue handoff
    - Priority routing
    - Escalation tracking
    """

    def __init__(self, config: Optional[AgentConfig] = None, conversation_service: ConversationService = None,
    **kwargs):
        """Initialize human agent."""
        super().__init__(name="human_agent", config=config)
        self.conversation_service = conversation_service or ConversationService()

    # ========================================================================
    # ABSTRACT METHOD IMPLEMENTATIONS
    # ========================================================================

    def _get_description(self) -> str:
        """Get agent description."""
        return (
            "Human Agent - Manages escalation to human specialists "
            "for complaints, complex issues, and priority support."
        )

    def _get_capabilities(self) -> List[str]:
        """Get agent capabilities."""
        return [
            "Complaint escalation",
            "Complex issue routing",
            "Priority assessment",
            "Specialist assignment",
            "Escalation tracking",
            "Conversation handoff",
        ]

    # ========================================================================
    # CORE PROCESSING
    # ========================================================================

    async def process(
        self,
        input_data: Dict[str, Any],
        context: Optional[Dict[str, Any]] = None,
    ) -> AgentResponse:
        """
        Process escalation request.

        Args:
            input_data: Must contain 'message', 'customer_id', 'conversation_id'
            context: Optional context with conversation_service

        Returns:
            AgentResponse: Escalation confirmation
        """
        self.log_request(input_data)

        try:
            await self.validate_input(input_data)

            message = input_data.get("message", "")
            customer_id = input_data.get("customer_id")
            conversation_id = input_data.get("conversation_id")

            if not all([message, customer_id, conversation_id]):
                raise ValueError(
                    "message, customer_id, and conversation_id are required"
                )

            # Assess escalation priority
            priority = self._assess_priority(message)

            # Create escalation
            escalation = await self._create_escalation(
                customer_id=customer_id,
                conversation_id=conversation_id,
                issue=message,
                priority=priority,
                context=context,
            )

            # Generate response
            response_content = self._generate_escalation_response(
                escalation, priority
            )

            response = self.create_response(
                content=response_content,
                metadata={
                    "escalated": True,
                    "escalation_id": escalation.get("id"),
                    "priority": priority.value,
                    "assigned_to": escalation.get("assigned_to"),
                    "estimated_response": escalation.get("estimated_response"),
                },
                confidence=0.98,
            )

            self.log_response(response)
            return response

        except Exception as e:
            self.logger.error(f"Escalation error: {e}")
            error_response = self.create_response(
                content=(
                    "I've logged your issue and will have a specialist contact you shortly. "
                    "Your case reference is being processed."
                ),
                metadata={"error": str(e)},
                confidence=0.9,
            )
            return error_response

    # ========================================================================
    # ESCALATION PROCESSING
    # ========================================================================

    def _assess_priority(self, message: str) -> EscalationPriority:
        """
        Assess escalation priority from message.

        Args:
            message: Customer message

        Returns:
            EscalationPriority: Priority level
        """
        message_lower = message.lower()

        # Urgent keywords
        urgent_keywords = [
            "urgent", "emergency", "critical", "immediate",
            "lost", "stolen", "fraud", "unauthorized",
            "cannot access", "locked out", "security breach"
        ]

        # High priority keywords
        high_keywords = [
            "complaint", "disappointed", "unhappy", "unacceptable",
            "refused", "denied", "failed", "issue", "problem",
            "wrong", "error", "mistake"
        ]

        # Medium priority keywords
        medium_keywords = [
            "help", "question", "need", "want", "prefer",
            "change", "update", "modify"
        ]

        # Check priority levels
        if any(kw in message_lower for kw in urgent_keywords):
            return EscalationPriority.URGENT
        elif any(kw in message_lower for kw in high_keywords):
            return EscalationPriority.HIGH
        elif any(kw in message_lower for kw in medium_keywords):
            return EscalationPriority.MEDIUM
        else:
            return EscalationPriority.LOW

    async def _create_escalation(
        self,
        customer_id: int,
        conversation_id: int,
        issue: str,
        priority: EscalationPriority,
        context: Optional[Dict[str, Any]] = None,
    ) -> Dict[str, Any]:
        """
        Create escalation record.

        Args:
            customer_id: Customer ID
            conversation_id: Conversation ID
            issue: Issue description
            priority: Priority level
            context: Optional context with conversation_service

        Returns:
            dict: Escalation record
        """

        # Get conversation service
        conversation_service = (
            context.get("conversation_service") if context else None
        )

        escalation = {
            "id": f"ESC-{customer_id}-{int(datetime.utcnow().timestamp())}",
            "customer_id": customer_id,
            "conversation_id": conversation_id,
            "issue": issue,
            "priority": priority.value,
            "status": "open",
            "created_at": datetime.utcnow().isoformat(),
            "assigned_to": None,
            "estimated_response": self._estimate_response_time(priority),
        }

        # Save escalation if service available
        if conversation_service:
            try:
                await conversation_service.escalate_conversation(
                    conversation_id,
                    reason=issue,
                    priority=priority.value,
                )
                escalation["saved"] = True
            except Exception as e:
                self.logger.warning(f"Could not save escalation: {e}")
                escalation["saved"] = False

        # Assign based on priority
        escalation["assigned_to"] = self._assign_specialist(priority)

        return escalation

    def _estimate_response_time(self, priority: EscalationPriority) -> str:
        """
        Estimate response time based on priority.

        Args:
            priority: Priority level

        Returns:
            str: Estimated response time
        """
        estimates = {
            EscalationPriority.URGENT: "Within 15 minutes",
            EscalationPriority.HIGH: "Within 1 hour",
            EscalationPriority.MEDIUM: "Within 4 hours",
            EscalationPriority.LOW: "Within 24 hours",
        }
        return estimates.get(priority, "Within 24 hours")

    def _assign_specialist(self, priority: EscalationPriority) -> str:
        """
        Assign specialist based on priority.

        Args:
            priority: Priority level

        Returns:
            str: Specialist team
        """
        teams = {
            EscalationPriority.URGENT: "Security & Fraud Team",
            EscalationPriority.HIGH: "Senior Support Team",
            EscalationPriority.MEDIUM: "Support Specialists",
            EscalationPriority.LOW: "Support Team",
        }
        return teams.get(priority, "Support Team")

    def _generate_escalation_response(
        self, escalation: Dict[str, Any], priority: EscalationPriority
    ) -> str:
        """
        Generate response message for escalation.

        Args:
            escalation: Escalation record
            priority: Priority level

        Returns:
            str: Response message
        """
        response = (
            f"Thank you for bringing this to our attention.\n\n"
            f"We've escalated your issue to our {escalation['assigned_to']}.\n\n"
            f"📋 Reference Number: {escalation['id']}\n"
            f"⏱️  Estimated Response: {escalation['estimated_response']}\n"
            f"🔔 Priority: {priority.value.upper()}\n\n"
        )

        if priority == EscalationPriority.URGENT:
            response += (
                "This is marked as urgent. A specialist will contact you "
                "immediately via your preferred contact method.\n"
            )
        else:
            response += (
                "A specialist will review your case and contact you shortly.\n"
            )

        response += (
            "\nYou'll receive:\n"
            "✓ Email confirmation of this escalation\n"
            "✓ Regular updates on your case\n"
            "✓ Direct contact with a specialist\n"
            "✓ Resolution timeline\n\n"
            "For immediate assistance, call 0800-123-4567"
        )

        return response

    # ========================================================================
    # HELPER METHODS
    # ========================================================================

    def get_priority_levels(self) -> List[str]:
        """Get available priority levels."""
        return [p.value for p in EscalationPriority]

    def get_escalation_info(self) -> Dict[str, Any]:
        """Get escalation information."""
        return {
            "priorities": self.get_priority_levels(),
            "specialist_teams": [
                "Security & Fraud Team",
                "Senior Support Team",
                "Support Specialists",
                "Support Team",
            ],
            "response_targets": {
                "urgent": "15 minutes",
                "high": "1 hour",
                "medium": "4 hours",
                "low": "24 hours",
            },
        }


--- START OF FILE: ./app/agents/base.py ---
"""
Base Agent

Abstract base class for all agents in the multi-agent system.
Provides common functionality and interface.
"""

from abc import ABC, abstractmethod
from typing import Dict, Any, Optional, List
from datetime import datetime
import logging

from app.config import settings


class AgentConfig:
    """
    Agent configuration.

    Common configuration shared by all agents.
    """

    def __init__(
        self,
        model_name: str = "llama-3.1-8b-instant",
        temperature: float = 0.7,
        max_tokens: int = 1024,
        timeout: int = 30,
    ):
        """
        Initialize agent configuration.

        Args:
            model_name: LLM model to use
            temperature: Sampling temperature (0-1)
            max_tokens: Maximum tokens in response
            timeout: API timeout in seconds
        """
        self.model_name = model_name
        self.temperature = temperature
        self.max_tokens = max_tokens
        self.timeout = timeout
        self.api_key = settings.groq_api_key

    def to_dict(self) -> Dict[str, Any]:
        """Convert config to dictionary."""
        return {
            "model_name": self.model_name,
            "temperature": self.temperature,
            "max_tokens": self.max_tokens,
            "timeout": self.timeout,
        }


class AgentResponse:
    """
    Agent response wrapper.

    Standardized response format from all agents.
    """

    def __init__(
        self,
        content: str,
        metadata: Optional[Dict[str, Any]] = None,
        confidence: Optional[float] = None,
        agent_name: Optional[str] = None,
    ):
        """
        Initialize agent response.

        Args:
            content: Response content/text
            metadata: Additional metadata
            confidence: Confidence score (0-1)
            agent_name: Name of agent that generated response
        """
        self.content = content
        self.metadata = metadata or {}
        self.confidence = confidence
        self.agent_name = agent_name
        self.timestamp = datetime.utcnow()

    def to_dict(self) -> Dict[str, Any]:
        """Convert response to dictionary."""
        return {
            "content": self.content,
            "metadata": self.metadata,
            "confidence": self.confidence,
            "agent_name": self.agent_name,
            "timestamp": self.timestamp.isoformat(),
        }

    def __repr__(self) -> str:
        """String representation."""
        return (
            f"<AgentResponse("
            f"agent='{self.agent_name}', "
            f"confidence={self.confidence}, "
            f"content='{self.content[:50]}...')>"
        )


class BaseAgent(ABC):
    """
    Base agent class.

    All agents must inherit from this class and implement:
    - process() method for handling requests
    """

    def __init__(
        self,
        name: str,
        config: Optional[AgentConfig] = None,
        services: Optional[Dict[str, Any]] = None
    ):
        """
        Initialize base agent.

        Args:
            name: Agent name
            config: Agent configuration (uses defaults if not provided)
        """
        self.name = name
        self.config = config or AgentConfig()
        self.logger = logging.getLogger(f"agent.{name}")
        self.services = services or {}

        # Agent metadata
        self.description = self._get_description()
        self.capabilities = self._get_capabilities()

        # Initialize agent
        self._initialize()

    # ========================================================================
    # ABSTRACT METHODS (must be implemented by subclasses)
    # ========================================================================

    @abstractmethod
    async def process(
        self,
        input_data: Dict[str, Any],
        context: Optional[Dict[str, Any]] = None,
    ) -> AgentResponse:
        """
        Process input and generate response.

        Args:
            input_data: Input data to process
            context: Optional context (conversation history, customer info, etc.)

        Returns:
            AgentResponse: Agent response
        """
        pass

    @abstractmethod
    def _get_description(self) -> str:
        """
        Get agent description.

        Returns:
            str: Agent description
        """
        pass

    @abstractmethod
    def _get_capabilities(self) -> List[str]:
        """
        Get agent capabilities.

        Returns:
            List[str]: List of capabilities
        """
        pass

    # ========================================================================
    # COMMON METHODS
    # ========================================================================

    def _initialize(self):
        """
        Initialize agent.

        Called after __init__. Override to add custom initialization.
        """
        self.logger.info(f"Initialized {self.name} agent")

    async def validate_input(self, input_data: Dict[str, Any]) -> bool:
        """
        Validate input data.

        Args:
            input_data: Input to validate

        Returns:
            bool: True if valid

        Raises:
            ValueError: If input is invalid
        """
        if not input_data:
            raise ValueError("Input data cannot be empty")

        return True

    def log_request(self, input_data: Dict[str, Any]):
        """
        Log agent request.

        Args:
            input_data: Request input
        """
        self.logger.info(
            f"{self.name} processing request",
            extra={
                "agent": self.name,
                "input_keys": list(input_data.keys()),
            }
        )

    def log_response(self, response: AgentResponse):
        """
        Log agent response.

        Args:
            response: Agent response
        """
        self.logger.info(
            f"{self.name} generated response",
            extra={
                "agent": self.name,
                "confidence": response.confidence,
                "content_length": len(response.content),
            }
        )

    def create_response(
        self,
        content: str,
        metadata: Optional[Dict[str, Any]] = None,
        confidence: Optional[float] = None,
    ) -> AgentResponse:
        """
        Create standardized response.

        Args:
            content: Response content
            metadata: Additional metadata
            confidence: Confidence score

        Returns:
            AgentResponse: Formatted response
        """
        return AgentResponse(
            content=content,
            metadata=metadata,
            confidence=confidence,
            agent_name=self.name,
        )

    def get_info(self) -> Dict[str, Any]:
        """
        Get agent information.

        Returns:
            dict: Agent info
        """
        return {
            "name": self.name,
            "description": self.description,
            "capabilities": self.capabilities,
            "config": self.config.to_dict(),
        }

    def __repr__(self) -> str:
        """String representation."""
        return f"<{self.__class__.__name__}(name='{self.name}')>"


--- START OF FILE: ./app/repositories/conversation.py ---
"""
Conversation Repository

Data access layer for Conversation model.
"""

from typing import List
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from app.models.conversation import Conversation, ConversationStatus
from app.repositories.base import BaseRepository


class ConversationRepository(BaseRepository[Conversation]):
    """Conversation repository."""

    def __init__(self, db: AsyncSession):
        """Initialize conversation repository."""
        super().__init__(Conversation, db)

    async def get_by_customer(
        self,
        customer_id: int,
        skip: int = 0,
        limit: int = 100
    ) -> List[Conversation]:
        """
        Get conversations for customer.

        Args:
            customer_id: Customer ID
            skip: Number to skip
            limit: Maximum to return

        Returns:
            List[Conversation]: Customer conversations
        """
        result = await self.db.execute(
            select(Conversation)
            .where(Conversation.customer_id == customer_id)
            .offset(skip)
            .limit(limit)
            .order_by(Conversation.created_at.desc())
        )
        return result.scalars().all()

    async def get_active_conversations(
        self,
        skip: int = 0,
        limit: int = 100
    ) -> List[Conversation]:
        """
        Get active conversations.

        Args:
            skip: Number to skip
            limit: Maximum to return

        Returns:
            List[Conversation]: Active conversations
        """
        result = await self.db.execute(
            select(Conversation)
            .where(Conversation.status == ConversationStatus.ACTIVE)
            .offset(skip)
            .limit(limit)
            .order_by(Conversation.updated_at.desc())
        )
        return result.scalars().all()

    async def get_escalated_conversations(
        self,
        skip: int = 0,
        limit: int = 100
    ) -> List[Conversation]:
        """
        Get escalated conversations.

        Args:
            skip: Number to skip
            limit: Maximum to return

        Returns:
            List[Conversation]: Escalated conversations
        """
        result = await self.db.execute(
            select(Conversation)
            .where(Conversation.status == ConversationStatus.ESCALATED)
            .offset(skip)
            .limit(limit)
            .order_by(Conversation.updated_at.asc())  # Oldest first
        )
        return result.scalars().all()


--- START OF FILE: ./app/repositories/transaction.py ---
from typing import List
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession
from app.models.transaction import Transaction
from app.repositories.base import BaseRepository

class TransactionRepository(BaseRepository[Transaction]):
    def __init__(self, db: AsyncSession):
        super().__init__(Transaction, db)

    async def get_by_account_id(self, account_id: int, limit: int = 50) -> List[Transaction]:
        """Get recent transactions for an account."""
        result = await self.db.execute(
            select(Transaction)
            .where(Transaction.account_id == account_id)
            .order_by(Transaction.date.desc())
            .limit(limit)
        )
        return result.scalars().all()


--- START OF FILE: ./app/repositories/__init__.py ---
"""
Repositories Package

Data access layer for all models.
"""

from app.repositories.base import BaseRepository
from app.repositories.customer import CustomerRepository
from app.repositories.conversation import ConversationRepository
from app.repositories.message import MessageRepository
from app.repositories.account import AccountRepository
from app.repositories.transaction import TransactionRepository
from app.repositories.product import ProductRepository

__all__ = [
    "BaseRepository",
    "CustomerRepository",
    "ConversationRepository",
    "MessageRepository",
    "AccountRepository",
    "TransactionRepository",
    "ProductRepository",
]


--- START OF FILE: ./app/repositories/message.py ---
"""
Message Repository

Data access layer for Message model.
"""

from typing import List
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from app.models.message import Message, MessageRole
from app.repositories.base import BaseRepository


class MessageRepository(BaseRepository[Message]):
    """Message repository."""

    def __init__(self, db: AsyncSession):
        """Initialize message repository."""
        super().__init__(Message, db)

    async def get_by_conversation(
        self,
        conversation_id: int,
        skip: int = 0,
        limit: int = 100
    ) -> List[Message]:
        """
        Get messages for conversation.

        Args:
            conversation_id: Conversation ID
            skip: Number to skip
            limit: Maximum to return

        Returns:
            List[Message]: Conversation messages
        """
        result = await self.db.execute(
            select(Message)
            .where(Message.conversation_id == conversation_id)
            .offset(skip)
            .limit(limit)
            .order_by(Message.created_at.asc())  # Chronological order
        )
        return result.scalars().all()

    async def get_requiring_human(
        self,
        skip: int = 0,
        limit: int = 100
    ) -> List[Message]:
        """
        Get messages requiring human intervention.

        Args:
            skip: Number to skip
            limit: Maximum to return

        Returns:
            List[Message]: Messages needing human
        """
        result = await self.db.execute(
            select(Message)
            .where(Message.requires_human == True)
            .offset(skip)
            .limit(limit)
            .order_by(Message.created_at.asc())  # Oldest first
        )
        return result.scalars().all()


--- START OF FILE: ./app/repositories/product.py ---
from typing import List
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession
from app.models.product import Product
from app.repositories.base import BaseRepository

class ProductRepository(BaseRepository[Product]):
    def __init__(self, db: AsyncSession):
        super().__init__(Product, db)

    async def get_by_type(self, product_type: str) -> List[Product]:
        """Get products by type (savings, credit, etc)."""
        result = await self.db.execute(select(Product).where(Product.type == product_type))
        return result.scalars().all()

    async def get_active_products(self) -> List[Product]:
        """Get all active products."""
        result = await self.db.execute(select(Product).where(Product.is_active == True))
        return result.scalars().all()


--- START OF FILE: ./app/repositories/customer.py ---
"""
Customer Repository

Data access layer for Customer model.
Provides customer-specific query methods.
"""

from typing import Optional, List
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from app.models.customer import Customer
from app.repositories.base import BaseRepository


class CustomerRepository(BaseRepository[Customer]):
    """
    Customer repository.

    Provides customer-specific data access methods.
    """

    def __init__(self, db: AsyncSession):
        """Initialize customer repository."""
        super().__init__(Customer, db)

    async def get_by_email(self, email: str) -> Optional[Customer]:
        """
        Get customer by email.

        Args:
            email: Customer email

        Returns:
            Customer or None: Customer if found
        """
        result = await self.db.execute(
            select(Customer).where(Customer.email == email)
        )
        return result.scalar_one_or_none()

    async def get_by_customer_id(self, customer_id: str) -> Optional[Customer]:
        """
        Get customer by external customer ID.

        Args:
            customer_id: External customer ID

        Returns:
            Customer or None: Customer if found
        """
        result = await self.db.execute(
            select(Customer).where(Customer.customer_id == customer_id)
        )
        return result.scalar_one_or_none()

    async def get_active_customers(
        self,
        skip: int = 0,
        limit: int = 100
    ) -> List[Customer]:
        """
        Get active customers.

        Args:
            skip: Number to skip
            limit: Maximum to return

        Returns:
            List[Customer]: Active customers
        """
        result = await self.db.execute(
            select(Customer)
            .where(Customer.is_active == True)
            .offset(skip)
            .limit(limit)
            .order_by(Customer.created_at.desc())
        )
        return result.scalars().all()

    async def get_vip_customers(
        self,
        skip: int = 0,
        limit: int = 100
    ) -> List[Customer]:
        """
        Get VIP customers.

        Args:
            skip: Number to skip
            limit: Maximum to return

        Returns:
            List[Customer]: VIP customers
        """
        result = await self.db.execute(
            select(Customer)
            .where(Customer.is_vip == True)
            .where(Customer.is_active == True)
            .offset(skip)
            .limit(limit)
            .order_by(Customer.created_at.desc())
        )
        return result.scalars().all()

    async def search_by_name(
        self,
        name: str,
        skip: int = 0,
        limit: int = 100
    ) -> List[Customer]:
        """
        Search customers by name (first or last).

        Args:
            name: Name to search for
            skip: Number to skip
            limit: Maximum to return

        Returns:
            List[Customer]: Matching customers
        """
        search_term = f"%{name}%"

        result = await self.db.execute(
            select(Customer)
            .where(
                (Customer.first_name.ilike(search_term)) |
                (Customer.last_name.ilike(search_term))
            )
            .offset(skip)
            .limit(limit)
            .order_by(Customer.last_name, Customer.first_name)
        )
        return result.scalars().all()


--- START OF FILE: ./app/repositories/base.py ---
"""
Base Repository

Provides common CRUD operations for all repositories.
All model-specific repositories should inherit from this.
"""

from typing import Generic, TypeVar, Type, Optional, List, Dict, Any
from sqlalchemy import select, update, delete, func
from sqlalchemy.ext.asyncio import AsyncSession

from app.models import BaseModel

# Type variable for models
ModelType = TypeVar("ModelType", bound=BaseModel)


class BaseRepository(Generic[ModelType]):
    """
    Base repository with common CRUD operations.

    Provides:
    - Create: Add new records
    - Read: Query records by ID or filters
    - Update: Modify existing records
    - Delete: Remove records (soft delete supported)
    """

    def __init__(self, model: Type[ModelType], db: AsyncSession):
        """
        Initialize repository.

        Args:
            model: SQLAlchemy model class
            db: Database session
        """
        self.model = model
        self.db = db

    # ========================================================================
    # CREATE OPERATIONS
    # ========================================================================

    async def create(self, data: Dict[str, Any]) -> ModelType:
        """
        Create new record.

        Args:
            data: Dictionary with model data

        Returns:
            ModelType: Created instance
        """
        instance = self.model(**data)
        self.db.add(instance)
        await self.db.flush()  # Flush to get ID
        await self.db.refresh(instance)  # Refresh to load relationships
        return instance

    async def create_many(self, data_list: List[Dict[str, Any]]) -> List[ModelType]:
        """
        Create multiple records.

        Args:
            data_list: List of dictionaries with model data

        Returns:
            List[ModelType]: Created instances
        """
        instances = [self.model(**data) for data in data_list]
        self.db.add_all(instances)
        await self.db.flush()

        for instance in instances:
            await self.db.refresh(instance)

        return instances

    # ========================================================================
    # READ OPERATIONS
    # ========================================================================

    async def get_by_id(self, id: int) -> Optional[ModelType]:
        """
        Get record by ID.

        Args:
            id: Record ID

        Returns:
            ModelType or None: Record if found
        """
        result = await self.db.execute(
            select(self.model).where(self.model.id == id)
        )
        return result.scalar_one_or_none()

    async def get_all(
        self,
        skip: int = 0,
        limit: int = 100,
        order_by: str = "id"
    ) -> List[ModelType]:
        """
        Get all records with pagination.

        Args:
            skip: Number of records to skip
            limit: Maximum number of records
            order_by: Column name to order by

        Returns:
            List[ModelType]: List of records
        """
        query = select(self.model).offset(skip).limit(limit)

        # Add ordering
        if hasattr(self.model, order_by):
            query = query.order_by(getattr(self.model, order_by))

        result = await self.db.execute(query)
        return result.scalars().all()

    async def get_by_filters(
        self,
        filters: Dict[str, Any],
        skip: int = 0,
        limit: int = 100
    ) -> List[ModelType]:
        """
        Get records by filters.

        Args:
            filters: Dictionary of column:value filters
            skip: Number of records to skip
            limit: Maximum number of records

        Returns:
            List[ModelType]: Filtered records
        """
        query = select(self.model)

        # Apply filters
        for key, value in filters.items():
            if hasattr(self.model, key):
                query = query.where(getattr(self.model, key) == value)

        query = query.offset(skip).limit(limit)

        result = await self.db.execute(query)
        return result.scalars().all()

    async def count(self, filters: Optional[Dict[str, Any]] = None) -> int:
        """
        Count records.

        Args:
            filters: Optional filters

        Returns:
            int: Number of records
        """
        query = select(func.count(self.model.id))

        if filters:
            for key, value in filters.items():
                if hasattr(self.model, key):
                    query = query.where(getattr(self.model, key) == value)

        result = await self.db.execute(query)
        return result.scalar()

    async def exists(self, id: int) -> bool:
        """
        Check if record exists.

        Args:
            id: Record ID

        Returns:
            bool: True if exists
        """
        query = select(func.count(self.model.id)).where(self.model.id == id)
        result = await self.db.execute(query)
        return result.scalar() > 0

    # ========================================================================
    # UPDATE OPERATIONS
    # ========================================================================

    async def update(self, id: int, data: Dict[str, Any]) -> Optional[ModelType]:
        """
        Update record by ID.

        Args:
            id: Record ID
            data: Dictionary with fields to update

        Returns:
            ModelType or None: Updated record
        """
        # Get existing record
        instance = await self.get_by_id(id)
        if not instance:
            return None

        # Update fields
        for key, value in data.items():
            if hasattr(instance, key):
                setattr(instance, key, value)

        await self.db.flush()
        await self.db.refresh(instance)

        return instance

    async def update_many(
        self,
        filters: Dict[str, Any],
        data: Dict[str, Any]
    ) -> int:
        """
        Update multiple records.

        Args:
            filters: Dictionary of filters
            data: Dictionary with fields to update

        Returns:
            int: Number of updated records
        """
        query = update(self.model)

        # Apply filters
        for key, value in filters.items():
            if hasattr(self.model, key):
                query = query.where(getattr(self.model, key) == value)

        query = query.values(**data)

        result = await self.db.execute(query)
        return result.rowcount

    # ========================================================================
    # DELETE OPERATIONS
    # ========================================================================

    async def delete(self, id: int) -> bool:
        """
        Delete record by ID.

        Args:
            id: Record ID

        Returns:
            bool: True if deleted
        """
        instance = await self.get_by_id(id)
        if not instance:
            return False

        await self.db.delete(instance)
        await self.db.flush()

        return True

    async def delete_many(self, filters: Dict[str, Any]) -> int:
        """
        Delete multiple records.

        Args:
            filters: Dictionary of filters

        Returns:
            int: Number of deleted records
        """
        query = delete(self.model)

        # Apply filters
        for key, value in filters.items():
            if hasattr(self.model, key):
                query = query.where(getattr(self.model, key) == value)

        result = await self.db.execute(query)
        return result.rowcount


--- START OF FILE: ./app/repositories/account.py ---
from typing import List, Optional
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession
from app.models.account import Account
from app.repositories.base import BaseRepository

class AccountRepository(BaseRepository[Account]):
    def __init__(self, db: AsyncSession):
        super().__init__(Account, db)

    async def get_by_account_number(self, account_number: str) -> Optional[Account]:
        """Get account by account number."""
        result = await self.db.execute(select(Account).where(Account.account_number == account_number))
        return result.scalar_one_or_none()

    async def get_by_customer_id(self, customer_id: str) -> List[Account]:
        """Get all accounts for a customer."""
        result = await self.db.execute(select(Account).where(Account.customer_id == customer_id))
        return result.scalars().all()


--- START OF FILE: ./app/models/conversation.py ---
"""
Conversation Model

Represents a conversation between a customer and the AI support system.
Links customers to messages and tracks conversation state.
"""

from sqlalchemy import Column, String, Integer, ForeignKey, Text, Enum, Index
from sqlalchemy.orm import relationship
from typing import List
import enum

from app.models import BaseModel


# ============================================================================
# ENUMS
# ============================================================================

class ConversationStatus(str, enum.Enum):
    """Conversation status enumeration."""

    ACTIVE = "active"          # Conversation ongoing
    RESOLVED = "resolved"      # Issue resolved
    ESCALATED = "escalated"    # Escalated to human agent
    CLOSED = "closed"          # Conversation closed


class ConversationChannel(str, enum.Enum):
    """Conversation channel enumeration."""

    WEB = "web"                # Web chat
    MOBILE = "mobile"          # Mobile app
    API = "api"                # API integration
    WHATSAPP = "whatsapp"      # WhatsApp integration
    SMS = "sms"                # SMS integration


# ============================================================================
# CONVERSATION MODEL
# ============================================================================

class Conversation(BaseModel):
    """
    Conversation model.

    Represents a conversation between a customer and the AI system.
    Contains conversation metadata, status, and relationships to
    customer and messages.
    """

    __tablename__ = "conversations"

    # ========================================================================
    # FOREIGN KEYS
    # ========================================================================

    customer_id = Column(
        Integer,
        ForeignKey("customers.id", ondelete="CASCADE"),
        nullable=False,
        index=True,
        comment="Foreign key to customer",
    )

    # ========================================================================
    # CONVERSATION METADATA
    # ========================================================================

    title = Column(
        String(200),
        nullable=False,
        comment="Conversation title/subject",
    )

    status = Column(
        Enum(ConversationStatus),
        default=ConversationStatus.ACTIVE,
        nullable=False,
        index=True,
        comment="Current conversation status",
    )

    channel = Column(
        Enum(ConversationChannel),
        default=ConversationChannel.WEB,
        nullable=False,
        index=True,
        comment="Communication channel",
    )

    # ========================================================================
    # CONVERSATION DETAILS
    # ========================================================================

    summary = Column(
        Text,
        nullable=True,
        comment="AI-generated conversation summary",
    )

    intent = Column(
        String(100),
        nullable=True,
        index=True,
        comment="Detected customer intent",
    )

    sentiment = Column(
        String(50),
        nullable=True,
        comment="Overall conversation sentiment",
    )

    # ========================================================================
    # METRICS
    # ========================================================================

    message_count = Column(
        Integer,
        default=0,
        nullable=False,
        comment="Total number of messages",
    )

    escalation_reason = Column(
        Text,
        nullable=True,
        comment="Reason for escalation (if escalated)",
    )

    priority = Column(
        String(20),
        nullable=True,
        comment="Priority of escalation (if escalated)",
    )

    # ========================================================================
    # RELATIONSHIPS
    # ========================================================================

    customer = relationship(
        "Customer",
        back_populates="conversations",
        lazy="selectin",  # Eager load customer
    )

    messages = relationship(
        "Message",
        back_populates="conversation",
        lazy="selectin",  # Eager load messages
        cascade="all, delete-orphan",  # Delete messages when conversation deleted
        order_by="Message.created_at",  # Order messages by timestamp
    )

    # ========================================================================
    # INDEXES
    # ========================================================================

    __table_args__ = (
        # Index for customer's conversations
        Index("idx_customer_status", "customer_id", "status"),
        # Index for channel + status queries
        Index("idx_channel_status", "channel", "status"),
        # Index for intent-based filtering
        Index("idx_intent", "intent"),
    )

    # ========================================================================
    # PROPERTIES
    # ========================================================================

    @property
    def is_active(self) -> bool:
        """
        Check if conversation is active.

        Returns:
            bool: True if status is ACTIVE
        """
        return self.status == ConversationStatus.ACTIVE

    @property
    def is_resolved(self) -> bool:
        """
        Check if conversation is resolved.

        Returns:
            bool: True if status is RESOLVED
        """
        return self.status == ConversationStatus.RESOLVED

    @property
    def is_escalated(self) -> bool:
        """
        Check if conversation is escalated.

        Returns:
            bool: True if status is ESCALATED
        """
        return self.status == ConversationStatus.ESCALATED

    # ========================================================================
    # METHODS
    # ========================================================================

    def __repr__(self) -> str:
        """String representation of conversation."""
        return (
            f"<Conversation(id={self.id}, "
            f"customer_id={self.customer_id}, "
            f"status='{self.status.value}', "
            f"messages={self.message_count})>"
        )

    def to_dict(self, include_messages: bool = False, include_customer: bool = False) -> dict:
        """
        Convert conversation to dictionary.

        Args:
            include_messages: Whether to include messages
            include_customer: Whether to include customer data

        Returns:
            dict: Conversation data
        """
        data = {
            "id": self.id,
            "customer_id": self.customer_id,
            "title": self.title,
            "status": self.status.value,
            "channel": self.channel.value,
            "summary": self.summary,
            "intent": self.intent,
            "sentiment": self.sentiment,
            "message_count": self.message_count,
            "escalation_reason": self.escalation_reason,
            "priority": self.priority,
            "created_at": self.created_at.isoformat() if self.created_at else None,
            "updated_at": self.updated_at.isoformat() if self.updated_at else None,
        }

        if include_customer and self.customer:
            data["customer"] = self.customer.to_dict(include_conversations=False)

        if include_messages:
            data["messages"] = [
                msg.to_dict()
                for msg in self.messages
            ]

        return data

    def add_message(self) -> None:
        """
        Increment message count.

        Called when a new message is added to conversation.
        """
        self.message_count += 1

    def mark_resolved(self, summary: str = None) -> None:
        """
        Mark conversation as resolved.

        Args:
            summary: Optional resolution summary
        """
        self.status = ConversationStatus.RESOLVED
        if summary:
            self.summary = summary

    def escalate(self, reason: str, priority: str = None) -> None:
        """
        Escalate conversation to human agent.

        Args:
            reason: Reason for escalation
            priority: Priority of escalation (optional)
        """
        self.status = ConversationStatus.ESCALATED
        self.escalation_reason = reason
        if priority:
            self.priority = priority

    def close(self) -> None:
        """Close conversation."""
        self.status = ConversationStatus.CLOSED


--- START OF FILE: ./app/models/transaction.py ---

"""
Transaction Model
Represents financial transactions on accounts.
"""
from sqlalchemy import Column, String, Numeric, ForeignKey, DateTime
from sqlalchemy.orm import relationship
from datetime import datetime
from app.models import BaseModel

class Transaction(BaseModel):
    __tablename__ = "transactions"

    account_id = Column(ForeignKey("accounts.id"), nullable=False, index=True)
    reference = Column(String(50), unique=True, nullable=False, index=True)
    amount = Column(Numeric(15, 2), nullable=False)
    currency = Column(String(3), default="GBP", nullable=False)
    description = Column(String(255), nullable=False)
    category = Column(String(50), nullable=True, index=True)
    date = Column(DateTime, default=datetime.utcnow, nullable=False, index=True)
    merchant_name = Column(String(100), nullable=True)

    # Relationships
    account = relationship("Account", back_populates="transactions")

    def __repr__(self):
        return f"<Transaction({self.reference}, amount={self.amount})>"


--- START OF FILE: ./app/models/__init__.py ---
"""
Database Models

This module provides base model classes and common utilities
for all database models in the application.
"""

from datetime import datetime,timezone
from sqlalchemy import Column, Integer, DateTime, Boolean
from typing import Any

from app.database import Base


# ============================================================================
# TIMESTAMP MIXIN
# ============================================================================

class TimestampMixin:
    """
    Mixin to add created_at and updated_at timestamps to models.

    Automatically sets timestamps on creation and update.
    """

    created_at = Column(
        DateTime(timezone=True),
        default=datetime.now(timezone.utc),
        nullable=False,
        comment="Record creation timestamp (UTC)",
    )

    updated_at = Column(
        DateTime(timezone=True),
        default=datetime.now(timezone.utc),
        onupdate=datetime.now(timezone.utc),
        nullable=False,
        comment="Record last update timestamp (UTC)",
    )


# ============================================================================
# SOFT DELETE MIXIN
# ============================================================================

class SoftDeleteMixin:
    """
    Mixin to add soft delete functionality to models.

    Instead of deleting records, marks them as deleted with timestamp.
    """

    deleted_at = Column(
        DateTime(timezone=True),
        nullable=True,
        default=None,
        comment="Record deletion timestamp (NULL if not deleted)",
    )

    is_deleted = Column(
        Boolean,
        default=False,
        nullable=False,
        index=True,  # Index for query performance
        comment="Soft delete flag",
    )

    def soft_delete(self) -> None:
        """Mark record as deleted without removing from database."""
        self.is_deleted = True
        self.deleted_at = datetime.now(datetime.timezone.utc)

    def restore(self) -> None:
        """Restore a soft-deleted record."""
        self.is_deleted = False
        self.deleted_at = None


# ============================================================================
# BASE MODEL
# ============================================================================

class BaseModel(Base, TimestampMixin):
    """
    Abstract base model with common fields.

    Provides:
    - Auto-incrementing ID
    - Created/updated timestamps
    - String representation
    - Dictionary conversion

    All application models should inherit from this.
    """

    __abstract__ = True  # Don't create table for this class

    id = Column(
        Integer,
        primary_key=True,
        autoincrement=True,
        comment="Primary key",
    )

    def __repr__(self) -> str:
        """
        String representation of model instance.

        Returns:
            str: Model representation
        """
        return f"<{self.__class__.__name__}(id={self.id})>"

    def to_dict(self, exclude: set = None) -> dict[str, Any]:
        """
        Convert model instance to dictionary.

        Args:
            exclude: Set of column names to exclude

        Returns:
            dict: Model data as dictionary
        """
        exclude = exclude or set()

        return {
            column.name: getattr(self, column.name)
            for column in self.__table__.columns
            if column.name not in exclude
        }

    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> "BaseModel":
        """
        Create model instance from dictionary.

        Args:
            data: Dictionary with model data

        Returns:
            BaseModel: New model instance
        """
        return cls(**data)


# ============================================================================
# EXAMPLE MODEL (for reference)
# ============================================================================

# Example of how to use BaseModel:
#
# from app.models import BaseModel
# from sqlalchemy import Column, String
#
# class Customer(BaseModel):
#     __tablename__ = "customers"
#
#     name = Column(String(100), nullable=False)
#     email = Column(String(255), unique=True, nullable=False)
#     phone = Column(String(20), nullable=True)
#
# This automatically includes:
# - id (primary key)
# - created_at (timestamp)
# - updated_at (timestamp)
# - __repr__() method
# - to_dict() method
# - from_dict() class method


from app.models.customer import Customer
from app.models.conversation import Conversation, ConversationStatus, ConversationChannel
from app.models.message import Message, MessageRole
from app.models.product import Product
from app.models.account import Account, AccountType, AccountStatus
from app.models.transaction import Transaction

__all__ = [
    "Base",
    "Customer",
    "Conversation",
    "ConversationStatus",
    "ConversationChannel",
    "Message",
    "MessageRole",
    "TimestampMixin",
    "SoftDeleteMixin",
    "BaseModel",
    "Product",
    "Account",
    "AccountType",
    "AccountStatus",
    "Transaction"
]


--- START OF FILE: ./app/models/message.py ---
"""
Message Model

Represents a single message in a conversation between customer and AI system.
Tracks message content, sender, and metadata.
"""

from sqlalchemy import Column, String, Integer, ForeignKey, Text, Enum, Boolean, Index
from sqlalchemy.orm import relationship
import enum

from app.models import BaseModel


# ============================================================================
# ENUMS
# ============================================================================

class MessageRole(str, enum.Enum):
    """Message sender role enumeration."""

    CUSTOMER = "customer"      # Message from customer
    AGENT = "agent"            # Message from AI agent
    SYSTEM = "system"          # System message
    HUMAN_AGENT = "human_agent"  # Message from human agent


# ============================================================================
# MESSAGE MODEL
# ============================================================================

class Message(BaseModel):
    """
    Message model.

    Represents a single message in a conversation.
    Contains message content, role, and metadata.
    """

    __tablename__ = "messages"

    # ========================================================================
    # FOREIGN KEYS
    # ========================================================================

    conversation_id = Column(
        Integer,
        ForeignKey("conversations.id", ondelete="CASCADE"),
        nullable=False,
        index=True,
        comment="Foreign key to conversation",
    )

    # ========================================================================
    # MESSAGE CONTENT
    # ========================================================================

    role = Column(
        Enum(MessageRole),
        nullable=False,
        index=True,
        comment="Message sender role",
    )

    content = Column(
        Text,
        nullable=False,
        comment="Message content/text",
    )

    # ========================================================================
    # METADATA
    # ========================================================================

    agent_name = Column(
        String(100),
        nullable=True,
        comment="Name of AI agent that generated message (if role=agent)",
    )

    intent = Column(
        String(100),
        nullable=True,
        index=True,
        comment="Detected intent in customer message",
    )

    sentiment = Column(
        String(50),
        nullable=True,
        comment="Message sentiment (positive, negative, neutral)",
    )

    confidence_score = Column(
        Integer,
        nullable=True,
        comment="Confidence score (0-100) for intent detection",
    )

    # ========================================================================
    # FLAGS
    # ========================================================================

    is_error = Column(
        Boolean,
        default=False,
        nullable=False,
        comment="Whether message represents an error",
    )

    requires_human = Column(
        Boolean,
        default=False,
        nullable=False,
        index=True,
        comment="Whether message requires human agent intervention",
    )

    # ========================================================================
    # ADDITIONAL DATA
    # ========================================================================

    metadata_json = Column(
        Text,
        nullable=True,
        comment="Additional metadata as JSON string",
    )

    # ========================================================================
    # RELATIONSHIPS
    # ========================================================================

    conversation = relationship(
        "Conversation",
        back_populates="messages",
        lazy="selectin",  # Eager load conversation
    )

    # ========================================================================
    # INDEXES
    # ========================================================================

    __table_args__ = (
        # Index for conversation's messages (most common query)
        Index("idx_conversation_created", "conversation_id", "created_at"),
        # Index for role-based filtering
        Index("idx_role", "role"),
        # Index for messages requiring human intervention
        Index("idx_requires_human", "requires_human"),
        # Index for intent-based analytics
        Index("idx_conversation_intent", "conversation_id", "intent"),
    )

    # ========================================================================
    # PROPERTIES
    # ========================================================================

    @property
    def is_customer_message(self) -> bool:
        """
        Check if message is from customer.

        Returns:
            bool: True if role is CUSTOMER
        """
        return self.role == MessageRole.CUSTOMER

    @property
    def is_agent_message(self) -> bool:
        """
        Check if message is from AI agent.

        Returns:
            bool: True if role is AGENT
        """
        return self.role == MessageRole.AGENT

    @property
    def is_system_message(self) -> bool:
        """
        Check if message is system message.

        Returns:
            bool: True if role is SYSTEM
        """
        return self.role == MessageRole.SYSTEM

    @property
    def content_length(self) -> int:
        """
        Get message content length.

        Returns:
            int: Character count
        """
        return len(self.content) if self.content else 0

    # ========================================================================
    # METHODS
    # ========================================================================

    def __repr__(self) -> str:
        """String representation of message."""
        content_preview = self.content[:50] + "..." if len(self.content) > 50 else self.content
        return (
            f"<Message(id={self.id}, "
            f"conversation_id={self.conversation_id}, "
            f"role='{self.role.value}', "
            f"content='{content_preview}')>"
        )

    def to_dict(self, include_conversation: bool = False) -> dict:
        """
        Convert message to dictionary.

        Args:
            include_conversation: Whether to include conversation data

        Returns:
            dict: Message data
        """
        data = {
            "id": self.id,
            "conversation_id": self.conversation_id,
            "role": self.role.value,
            "content": self.content,
            "agent_name": self.agent_name,
            "intent": self.intent,
            "sentiment": self.sentiment,
            "confidence_score": self.confidence_score,
            "is_error": self.is_error,
            "requires_human": self.requires_human,
            "metadata_json": self.metadata_json,
            "created_at": self.created_at.isoformat() if self.created_at else None,
            "updated_at": self.updated_at.isoformat() if self.updated_at else None,
        }

        if include_conversation and self.conversation:
            data["conversation"] = self.conversation.to_dict(
                include_messages=False,
                include_customer=False
            )

        return data


--- START OF FILE: ./app/models/product.py ---
"""
Product Model
Represents financial products (Savings, Credit Cards, Loans).
"""
from sqlalchemy import Column, String, Numeric, Text, Boolean, JSON
from app.models import BaseModel

class Product(BaseModel):
    __tablename__ = "products"

    name = Column(String(100), nullable=False, index=True)
    type = Column(String(50), nullable=False, index=True, comment="savings, credit, loan")
    description = Column(Text, nullable=True)
    interest_rate = Column(Numeric(5, 4), nullable=True, comment="Annual interest rate (decimal)")
    features = Column(JSON, default=list, comment="List of product features")
    requirements = Column(JSON, default=dict, comment="Eligibility requirements")
    is_active = Column(Boolean, default=True, index=True)

    def __repr__(self):
        return f"<Product(name='{self.name}', type='{self.type}')>"


--- START OF FILE: ./app/models/customer.py ---
"""
Customer Model

Represents a customer in the FCA financial services support system.
Stores customer information and links to conversations.
"""

from sqlalchemy import Column, String, Boolean, Text, Index
from sqlalchemy.orm import relationship
from typing import List

from app.models import BaseModel


class Customer(BaseModel):
    """
    Customer model.

    Represents a customer who interacts with the support system.
    Includes personal information, contact details, and relationship
    to conversations.
    """

    __tablename__ = "customers"

    # ========================================================================
    # PERSONAL INFORMATION
    # ========================================================================

    first_name = Column(
        String(100),
        nullable=False,
        comment="Customer first name",
    )

    last_name = Column(
        String(100),
        nullable=False,
        comment="Customer last name",
    )

    email = Column(
        String(255),
        unique=True,
        nullable=False,
        index=True,  # Index for fast lookup
        comment="Customer email address (unique)",
    )

    phone = Column(
        String(20),
        nullable=True,
        comment="Customer phone number",
    )

    # ========================================================================
    # ACCOUNT INFORMATION
    # ========================================================================

    customer_id = Column(
        String(50),
        unique=True,
        nullable=False,
        index=True,  # Index for fast lookup
        comment="External customer ID from core banking system",
    )

    account_number = Column(
        String(50),
        nullable=True,
        comment="Primary account number",
    )

    # ========================================================================
    # STATUS FLAGS
    # ========================================================================

    is_active = Column(
        Boolean,
        default=True,
        nullable=False,
        index=True,
        comment="Whether customer account is active",
    )

    is_verified = Column(
        Boolean,
        default=False,
        nullable=False,
        comment="Whether customer identity is verified",
    )

    is_vip = Column(
        Boolean,
        default=False,
        nullable=False,
        index=True,
        comment="VIP customer flag (premium service)",
    )

    # ========================================================================
    # ADDITIONAL INFORMATION
    # ========================================================================

    notes = Column(
        Text,
        nullable=True,
        comment="Internal notes about customer",
    )

    # ========================================================================
    # RELATIONSHIPS
    # ========================================================================

    conversations = relationship(
        "Conversation",
        back_populates="customer",
        lazy="selectin",  # Eager load conversations
        cascade="all, delete-orphan",  # Delete conversations when customer deleted
    )

    # ========================================================================
    # INDEXES
    # ========================================================================

    __table_args__ = (
        # Composite index for name searches
        Index("idx_customer_name", "first_name", "last_name"),
        # Index for active VIP customers (common query)
        Index("idx_active_vip", "is_active", "is_vip"),
    )

    # ========================================================================
    # PROPERTIES
    # ========================================================================

    @property
    def full_name(self) -> str:
        """
        Get customer's full name.

        Returns:
            str: First name + last name
        """
        return f"{self.first_name} {self.last_name}"

    @property
    def conversation_count(self) -> int:
        """
        Get number of conversations.

        Returns:
            int: Count of conversations
        """
        return len(self.conversations)

    # ========================================================================
    # METHODS
    # ========================================================================

    def __repr__(self) -> str:
        """String representation of customer."""
        return f"<Customer(id={self.id}, name='{self.full_name}', email='{self.email}')>"

    def to_dict(self, include_conversations: bool = False) -> dict:
        """
        Convert customer to dictionary.

        Args:
            include_conversations: Whether to include conversations

        Returns:
            dict: Customer data
        """
        data = {
            "id": self.id,
            "customer_id": self.customer_id,
            "first_name": self.first_name,
            "last_name": self.last_name,
            "full_name": self.full_name,
            "email": self.email,
            "phone": self.phone,
            "account_number": self.account_number,
            "is_active": self.is_active,
            "is_verified": self.is_verified,
            "is_vip": self.is_vip,
            "notes": self.notes,
            "created_at": self.created_at.isoformat() if self.created_at else None,
            "updated_at": self.updated_at.isoformat() if self.updated_at else None,
        }

        if include_conversations:
            data["conversations"] = [
                conv.to_dict(include_messages=False)
                for conv in self.conversations
            ]
            data["conversation_count"] = self.conversation_count

        return data


--- START OF FILE: ./app/models/account.py ---
"""
Account Model
Represents a customer's bank account.
"""
from sqlalchemy import Column, String, Numeric, ForeignKey, Enum as SAEnum
from sqlalchemy.orm import relationship
import enum
from app.models import BaseModel

class AccountType(str, enum.Enum):
    CURRENT = "current"
    SAVINGS = "savings"
    LOAN = "loan"
    CREDIT = "credit"

class AccountStatus(str, enum.Enum):
    ACTIVE = "active"
    FROZEN = "frozen"
    CLOSED = "closed"

class Account(BaseModel):
    __tablename__ = "accounts"

    account_number = Column(String(20), unique=True, nullable=False, index=True)
    customer_id = Column(String(50), nullable=False, index=True, comment="External Link")
    product_id = Column(ForeignKey("products.id"), nullable=True)

    type = Column(SAEnum(AccountType), nullable=False, default=AccountType.CURRENT)
    status = Column(SAEnum(AccountStatus), nullable=False, default=AccountStatus.ACTIVE)
    currency = Column(String(3), default="GBP", nullable=False)
    balance = Column(Numeric(15, 2), default=0.00, nullable=False)
    available_balance = Column(Numeric(15, 2), default=0.00, nullable=False)

    # Relationships
    product = relationship("Product")
    # Using string reference to avoid circular imports
    transactions = relationship("Transaction", back_populates="account", cascade="all, delete-orphan")

    def __repr__(self):
        return f"<Account({self.account_number}, type={self.type}, balance={self.balance})>"


--- START OF FILE: ./app/api/__init__.py ---
from app.api.routes.messages import router as messages_router

__all__ = ["messages_router"]


--- START OF FILE: ./app/api/routes/messages.py ---
"""
Message Router API

FastAPI endpoints for agent message processing.
Handles customer messages and returns coordinated responses.
"""

from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
from typing import Optional, Dict, Any
import logging

from app.coordinator.agent_coordinator import AgentCoordinator

router = APIRouter(prefix="/api/v1", tags=["messages"])
coordinator = AgentCoordinator()
logger = logging.getLogger(__name__)


# ============================================================================
# REQUEST/RESPONSE MODELS
# ============================================================================

class MessageRequest(BaseModel):
    """Incoming message request."""
    message: str
    customer_id: int
    conversation_id: int


class AgentMetadata(BaseModel):
    """Agent response metadata."""
    agent: str
    intent: str
    confidence: float
    turn_count: int
    escalated: bool
    escalation_id: Optional[str] = None


class MessageResponse(BaseModel):
    """API response."""
    response: str
    metadata: Dict[str, Any]
    status: str = "success"


class ConversationHistoryItem(BaseModel):
    """Single conversation turn."""
    timestamp: str
    message: str
    agent: str
    intent: str
    response: str


class ConversationHistory(BaseModel):
    """Conversation history response."""
    conversation_id: int
    history: list[ConversationHistoryItem]


class ConversationStats(BaseModel):
    """Conversation statistics."""
    total_conversations: int
    total_messages: int
    escalated_conversations: int
    avg_messages_per_conversation: float
    agent_distribution: Dict[str, int]
    intent_distribution: Dict[str, int]


# ============================================================================
# MESSAGE ENDPOINTS
# ============================================================================

@router.post("/messages/process", response_model=MessageResponse)
async def process_message(request: MessageRequest) -> MessageResponse:
    """
    Process customer message through agent system.

    Args:
        request: MessageRequest with message, customer_id, conversation_id

    Returns:
        MessageResponse with agent response and metadata

    Example:
        POST /api/v1/messages/process
        {
            "message": "What's my account balance?",
            "customer_id": 101,
            "conversation_id": 1
        }
    """
    try:
        logger.info(f"Processing message for customer {request.customer_id}")

        # Process through coordinator
        response = await coordinator.process_message(
            message=request.message,
            customer_id=request.customer_id,
            conversation_id=request.conversation_id,
        )

        return MessageResponse(
            response=response["response"],
            metadata={
                "agent": response["agent"],
                "intent": response["intent"],
                "confidence": response["confidence"],
                "turn_count": response["turn_count"],
                "escalated": response["escalated"],
                "escalation_id": response.get("escalation_id"),
            }
        )

    except ValueError as e:
        logger.error(f"Validation error: {e}")
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        logger.error(f"Processing error: {e}")
        raise HTTPException(status_code=500, detail="Error processing message")


# ============================================================================
# CONVERSATION ENDPOINTS
# ============================================================================

@router.get("/conversations/{conversation_id}/history", response_model=ConversationHistory)
async def get_conversation_history(
    conversation_id: int,
    limit: int = 10,
) -> ConversationHistory:
    """
    Get conversation history.

    Args:
        conversation_id: ID of conversation
        limit: Max messages to return

    Returns:
        ConversationHistory with message turns
    """
    try:
        history = coordinator.get_conversation_history(conversation_id, limit)

        if history is None:
            raise HTTPException(status_code=404, detail="Conversation not found")

        return ConversationHistory(
            conversation_id=conversation_id,
            history=history,
        )

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"History retrieval error: {e}")
        raise HTTPException(status_code=500, detail="Error retrieving history")


@router.get("/customers/{customer_id}/conversations")
async def get_customer_conversations(customer_id: int) -> Dict[str, Any]:
    """
    Get all conversations for a customer.

    Args:
        customer_id: Customer ID

    Returns:
        List of conversations with metadata
    """
    try:
        conversations = coordinator.get_all_conversations(customer_id)

        return {
            "customer_id": customer_id,
            "conversations": [
                {
                    "conversation_id": conv.conversation_id,
                    "message_count": len(conv.messages),
                    "created_at": conv.created_at.isoformat(),
                    "is_escalated": conv.is_escalated,
                    "escalation_id": conv.escalation_id,
                    "last_intent": conv.last_intent,
                }
                for conv in conversations
            ]
        }

    except Exception as e:
        logger.error(f"Error retrieving conversations: {e}")
        raise HTTPException(status_code=500, detail="Error retrieving conversations")


# ============================================================================
# ESCALATION ENDPOINTS
# ============================================================================

@router.get("/escalations")
async def get_escalated_conversations() -> Dict[str, Any]:
    """
    Get all escalated conversations.

    Returns:
        List of escalated conversations with details
    """
    try:
        escalated = coordinator.get_escalated_conversations()

        return {
            "escalated_count": len(escalated),
            "escalations": escalated,
        }

    except Exception as e:
        logger.error(f"Error retrieving escalations: {e}")
        raise HTTPException(status_code=500, detail="Error retrieving escalations")


@router.post("/escalations/{conversation_id}/resolve")
async def resolve_escalation(
    conversation_id: int,
    resolution_notes: str,
) -> Dict[str, Any]:
    """
    Mark escalation as resolved.

    Args:
        conversation_id: Conversation ID
        resolution_notes: Resolution details

    Returns:
        Success confirmation
    """
    try:
        resolved = coordinator.resolve_escalation(conversation_id, resolution_notes)

        if not resolved:
            raise HTTPException(status_code=404, detail="Conversation not escalated")

        return {
            "status": "resolved",
            "conversation_id": conversation_id,
        }

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error resolving escalation: {e}")
        raise HTTPException(status_code=500, detail="Error resolving escalation")


# ============================================================================
# STATISTICS ENDPOINTS
# ============================================================================

@router.get("/statistics", response_model=ConversationStats)
async def get_statistics() -> ConversationStats:
    """
    Get coordinator statistics.

    Returns:
        ConversationStats with metrics
    """
    try:
        stats = coordinator.get_statistics()

        return ConversationStats(**stats)

    except Exception as e:
        logger.error(f"Error retrieving statistics: {e}")
        raise HTTPException(status_code=500, detail="Error retrieving statistics")


@router.get("/info")
async def get_coordinator_info() -> Dict[str, Any]:
    """
    Get coordinator information.

    Returns:
        Coordinator capabilities and status
    """
    try:
        info = coordinator.get_coordinator_info()
        return info

    except Exception as e:
        logger.error(f"Error retrieving info: {e}")
        raise HTTPException(status_code=500, detail="Error retrieving info")


# ============================================================================
# HEALTH CHECK
# ============================================================================

@router.get("/health")
async def health_check() -> Dict[str, str]:
    """
    Health check endpoint.

    Returns:
        Status confirmation
    """
    return {
        "status": "healthy",
        "service": "message-router",
        "version": "1.0.0",
    }


--- START OF FILE: ./app/services/transaction_service.py ---
from typing import List
from sqlalchemy.ext.asyncio import AsyncSession
from app.services.base import BaseService
from app.repositories.transaction import TransactionRepository
from app.models.transaction import Transaction

class TransactionService(BaseService):
    def __init__(self, db: AsyncSession = None):
        super().__init__(db)
        if self.db:
            self.repo = TransactionRepository(self.db)

    async def __aenter__(self):
        await super().__aenter__()
        self.repo = TransactionRepository(self.db)
        return self

    async def get_transactions_by_account(self, account_id: int, limit: int = 10) -> List[Transaction]:
        """Get recent transactions for an account."""
        return await self.repo.get_by_account_id(account_id, limit)


--- START OF FILE: ./app/services/conversation.py ---
"""
Conversation Service

Business logic for conversation operations.
"""

from typing import Optional, List
from sqlalchemy.ext.asyncio import AsyncSession

from app.services.base import BaseService
from app.repositories.conversation import ConversationRepository
from app.repositories.customer import CustomerRepository
from app.models.conversation import Conversation, ConversationStatus, ConversationChannel


class ConversationService(BaseService):
    """
    Conversation service.

    Handles conversation business logic and operations.
    """

    def __init__(self, db: AsyncSession = None):
        """Initialize conversation service."""
        super().__init__(db)
        self.repo = None
        self.customer_repo = None

    async def __aenter__(self):
        """Enter async context."""
        await super().__aenter__()
        self.repo = ConversationRepository(self.db)
        self.customer_repo = CustomerRepository(self.db)
        return self

    async def start_conversation(
        self,
        customer_id: int,
        title: str,
        channel: ConversationChannel = ConversationChannel.WEB
    ) -> Conversation:
        """
        Start new conversation.

        Args:
            customer_id: Customer ID
            title: Conversation title
            channel: Communication channel

        Returns:
            Conversation: Created conversation

        Raises:
            ValueError: If customer not found
        """
        # Verify customer exists
        customer = await self.customer_repo.get_by_id(customer_id)
        if not customer:
            raise ValueError(f"Customer {customer_id} not found")

        # Create conversation
        data = {
            "customer_id": customer_id,
            "title": title,
            "channel": channel,
            "status": ConversationStatus.ACTIVE,
            "message_count": 0,
        }

        conversation = await self.repo.create(data)
        await self.commit()

        return conversation

    async def get_conversation(self, conversation_id: int) -> Optional[Conversation]:
        """
        Get conversation by ID.

        Args:
            conversation_id: Conversation ID

        Returns:
            Conversation or None: Conversation if found
        """
        return await self.repo.get_by_id(conversation_id)

    async def get_customer_conversations(
        self,
        customer_id: int,
        page: int = 1,
        page_size: int = 100
    ) -> List[Conversation]:
        """
        Get conversations for customer.

        Args:
            customer_id: Customer ID
            page: Page number (1-indexed)
            page_size: Items per page

        Returns:
            List[Conversation]: Customer conversations
        """
        skip = (page - 1) * page_size
        return await self.repo.get_by_customer(
            customer_id,
            skip=skip,
            limit=page_size
        )

    async def resolve_conversation(
        self,
        conversation_id: int,
        summary: str = None
    ) -> Optional[Conversation]:
        """
        Mark conversation as resolved.

        Args:
            conversation_id: Conversation ID
            summary: Resolution summary

        Returns:
            Conversation or None: Resolved conversation
        """
        conversation = await self.repo.get_by_id(conversation_id)
        if not conversation:
            return None

        conversation.mark_resolved(summary=summary)
        await self.commit()

        return conversation

    async def escalate_conversation(
        self,
        conversation_id: int,
        reason: str,
        priority: str = None
    ) -> Optional[Conversation]:
        """
        Escalate conversation to human agent.

        Args:
            conversation_id: Conversation ID
            reason: Escalation reason
            priority: Escalation priority (optional)

        Returns:
            Conversation or None: Escalated conversation
        """
        conversation = await self.repo.get_by_id(conversation_id)
        if not conversation:
            return None

        conversation.escalate(reason=reason, priority=priority)
        await self.commit()

        return conversation


--- START OF FILE: ./app/services/account_service.py ---
from typing import List, Optional
from sqlalchemy.ext.asyncio import AsyncSession
from app.services.base import BaseService
from app.repositories.account import AccountRepository
from app.models.account import Account

class AccountService(BaseService):
    def __init__(self, db: AsyncSession = None):
        super().__init__(db)
        if self.db:
            self.repo = AccountRepository(self.db)

    async def __aenter__(self):
        await super().__aenter__()
        self.repo = AccountRepository(self.db)
        return self

    async def get_accounts_by_customer(self, customer_id: str) -> List[Account]:
        """Get all accounts for a customer ID."""
        return await self.repo.get_by_customer_id(customer_id)

    async def get_account_balance(self, account_number: str) -> Optional[float]:
        """Get balance for a specific account."""
        account = await self.repo.get_by_account_number(account_number)
        return float(account.balance) if account else None


--- START OF FILE: ./app/services/__init__.py ---
"""
Services Package

Business logic layer for all models.
"""

from app.services.base import BaseService
from app.services.customer import CustomerService
from app.services.conversation import ConversationService
from app.services.message import MessageService
from app.services.product_service import ProductService
from app.services.account_service import AccountService
from app.services.transaction_service import TransactionService

__all__ = [
    "BaseService",
    "CustomerService",
    "ConversationService",
    "MessageService",
    "ProductService",
    "AccountService",
    "TransactionService"
]


--- START OF FILE: ./app/services/message.py ---
"""
Message Service

Business logic for message operations.
"""

from typing import Optional, List
from sqlalchemy.ext.asyncio import AsyncSession

from app.services.base import BaseService
from app.repositories.message import MessageRepository
from app.repositories.conversation import ConversationRepository
from app.models.message import Message, MessageRole


class MessageService(BaseService):
    """
    Message service.

    Handles message business logic and operations.
    """

    def __init__(self, db: AsyncSession = None):
        """Initialize message service."""
        super().__init__(db)
        self.repo = None
        self.conversation_repo = None

    async def __aenter__(self):
        """Enter async context."""
        await super().__aenter__()
        self.repo = MessageRepository(self.db)
        self.conversation_repo = ConversationRepository(self.db)
        return self

    async def add_message(
        self,
        conversation_id: int,
        role: MessageRole,
        content: str,
        agent_name: str = None,
        intent: str = None,
        sentiment: str = None,
        confidence_score: int = None
    ) -> Message:
        """
        Add message to conversation.

        Args:
            conversation_id: Conversation ID
            role: Message role
            content: Message content
            agent_name: AI agent name (if role=AGENT)
            intent: Detected intent
            sentiment: Message sentiment
            confidence_score: Confidence score (0-100)

        Returns:
            Message: Created message

        Raises:
            ValueError: If conversation not found
        """
        # Verify conversation exists
        conversation = await self.conversation_repo.get_by_id(conversation_id)
        if not conversation:
            raise ValueError(f"Conversation {conversation_id} not found")

        # Create message
        data = {
            "conversation_id": conversation_id,
            "role": role,
            "content": content,
            "agent_name": agent_name,
            "intent": intent,
            "sentiment": sentiment,
            "confidence_score": confidence_score,
        }

        message = await self.repo.create(data)

        # Update conversation message count
        conversation.add_message()

        await self.commit()

        return message

    async def get_conversation_messages(
        self,
        conversation_id: int,
        page: int = 1,
        page_size: int = 100
    ) -> List[Message]:
        """
        Get messages for conversation.

        Args:
            conversation_id: Conversation ID
            page: Page number (1-indexed)
            page_size: Items per page

        Returns:
            List[Message]: Conversation messages
        """
        skip = (page - 1) * page_size
        return await self.repo.get_by_conversation(
            conversation_id,
            skip=skip,
            limit=page_size
        )


--- START OF FILE: ./app/services/customer.py ---
"""
Customer Service

Business logic for customer operations.
"""

from typing import Optional, List, Dict, Any
from sqlalchemy.ext.asyncio import AsyncSession

from app.services.base import BaseService
from app.repositories.customer import CustomerRepository
from app.models.customer import Customer


class CustomerService(BaseService):
    """
    Customer service.

    Handles customer business logic and operations.
    """

    def __init__(self, db: AsyncSession = None):
        """Initialize customer service."""
        super().__init__(db)
        # Initialize repo immediately if DB session exists
        if self.db:
            self.repo = CustomerRepository(self.db)
        else:
            self.repo = None

    async def __aenter__(self):
        """Enter async context."""
        await super().__aenter__()
        self.repo = CustomerRepository(self.db)
        return self

    # ========================================================================
    # CREATE OPERATIONS
    # ========================================================================

    async def create_customer(
        self,
        customer_id: str,
        first_name: str,
        last_name: str,
        email: str,
        phone: str = None,
        account_number: str = None,
        is_vip: bool = False
    ) -> Customer:
        """
        Create new customer.

        Args:
            customer_id: External customer ID
            first_name: First name
            last_name: Last name
            email: Email address
            phone: Phone number (optional)
            account_number: Account number (optional)
            is_vip: VIP status (default False)

        Returns:
            Customer: Created customer

        Raises:
            ValueError: If email already exists
        """
        # Check if email exists
        existing = await self.repo.get_by_email(email)
        if existing:
            raise ValueError(f"Customer with email {email} already exists")

        # Check if customer_id exists
        existing = await self.repo.get_by_customer_id(customer_id)
        if existing:
            raise ValueError(f"Customer with ID {customer_id} already exists")

        # Create customer
        data = {
            "customer_id": customer_id,
            "first_name": first_name,
            "last_name": last_name,
            "email": email,
            "phone": phone,
            "account_number": account_number,
            "is_vip": is_vip,
            "is_active": True,
            "is_verified": False,
        }

        customer = await self.repo.create(data)
        await self.commit()

        return customer

    # ========================================================================
    # READ OPERATIONS
    # ========================================================================

    async def get_customer(self, customer_id: int) -> Optional[Customer]:
        """
        Get customer by ID.

        Args:
            customer_id: Customer ID

        Returns:
            Customer or None: Customer if found
        """
        return await self.repo.get_by_id(customer_id)

    async def get_customer_by_email(self, email: str) -> Optional[Customer]:
        """
        Get customer by email.

        Args:
            email: Email address

        Returns:
            Customer or None: Customer if found
        """
        return await self.repo.get_by_email(email)

    async def get_active_customers(
        self,
        page: int = 1,
        page_size: int = 100
    ) -> List[Customer]:
        """
        Get active customers with pagination.

        Args:
            page: Page number (1-indexed)
            page_size: Items per page

        Returns:
            List[Customer]: Active customers
        """
        skip = (page - 1) * page_size
        return await self.repo.get_active_customers(skip=skip, limit=page_size)

    async def search_customers(
        self,
        name: str,
        page: int = 1,
        page_size: int = 100
    ) -> List[Customer]:
        """
        Search customers by name.

        Args:
            name: Name to search for
            page: Page number (1-indexed)
            page_size: Items per page

        Returns:
            List[Customer]: Matching customers
        """
        skip = (page - 1) * page_size
        return await self.repo.search_by_name(name, skip=skip, limit=page_size)

    # ========================================================================
    # UPDATE OPERATIONS
    # ========================================================================

    async def update_customer(
        self,
        customer_id: int,
        data: Dict[str, Any]
    ) -> Optional[Customer]:
        """
        Update customer.

        Args:
            customer_id: Customer ID
            data: Fields to update

        Returns:
            Customer or None: Updated customer
        """
        customer = await self.repo.update(customer_id, data)
        if customer:
            await self.commit()
        return customer

    async def verify_customer(self, customer_id: int) -> Optional[Customer]:
        """
        Verify customer identity.

        Args:
            customer_id: Customer ID

        Returns:
            Customer or None: Verified customer
        """
        return await self.update_customer(customer_id, {"is_verified": True})

    async def make_vip(self, customer_id: int) -> Optional[Customer]:
        """
        Upgrade customer to VIP.

        Args:
            customer_id: Customer ID

        Returns:
            Customer or None: VIP customer
        """
        return await self.update_customer(customer_id, {"is_vip": True})

    async def deactivate_customer(self, customer_id: int) -> Optional[Customer]:
        """
        Deactivate customer account.

        Args:
            customer_id: Customer ID

        Returns:
            Customer or None: Deactivated customer
        """
        return await self.update_customer(customer_id, {"is_active": False})

    # ========================================================================
    # DELETE OPERATIONS
    # ========================================================================

    async def delete_customer(self, customer_id: int) -> bool:
        """
        Delete customer (and all conversations/messages via CASCADE).

        Args:
            customer_id: Customer ID

        Returns:
            bool: True if deleted
        """
        success = await self.repo.delete(customer_id)
        if success:
            await self.commit()
        return success


--- START OF FILE: ./app/services/product_service.py ---
from typing import List
from sqlalchemy.ext.asyncio import AsyncSession
from app.services.base import BaseService
from app.repositories.product import ProductRepository
from app.models.product import Product

class ProductService(BaseService):
    def __init__(self, db: AsyncSession = None):
        super().__init__(db)
        if self.db:
            self.repo = ProductRepository(self.db)

    async def __aenter__(self):
        await super().__aenter__()
        self.repo = ProductRepository(self.db)
        return self

    async def get_all_products(self) -> List[Product]:
        return await self.repo.get_active_products()

    async def get_products_by_category(self, category: str) -> List[Product]:
        return await self.repo.get_by_type(category)


--- START OF FILE: ./app/services/base.py ---
"""
Base Service

Provides common service functionality.
All model-specific services should inherit from this.
"""

from sqlalchemy.ext.asyncio import AsyncSession
from app.database import AsyncSessionLocal


class BaseService:
    """
    Base service class.

    Provides database session management and common functionality.
    """

    def __init__(self, db: AsyncSession = None):
        """
        Initialize service.

        Args:
            db: Optional database session (created if not provided)
        """
        self.db = db
        self._owns_session = db is None

    async def __aenter__(self):
        """Enter async context."""
        if self._owns_session:
            self.db = AsyncSessionLocal()
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """Exit async context."""
        if self._owns_session and self.db:
            if exc_type is not None:
                await self.db.rollback()
            await self.db.close()

    async def commit(self):
        """Commit current transaction."""
        await self.db.commit()

    async def rollback(self):
        """Rollback current transaction."""
        await self.db.rollback()


--- START OF FILE: ./tests/conftest.py ---
"""
Pytest Configuration and Fixtures

This module provides test configuration and reusable fixtures
for all test modules.
"""
import pytest_asyncio
import pytest
import asyncio
from typing import AsyncGenerator, Generator
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession, async_sessionmaker
from httpx import AsyncClient

from app.main import app
from app.database import Base
from app.config import settings

# ============================================================================
# PYTEST CONFIGURATION
# ============================================================================

# Use async event loop for all tests
@pytest.fixture(scope="session")
def event_loop() -> Generator:
    """
    Create an instance of the default event loop for the test session.
    """
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)
    yield loop
    loop.close()

# ============================================================================
# DATABASE FIXTURES
# ============================================================================

@pytest_asyncio.fixture(scope="session")
async def test_engine():
    """
    Create test database engine.
    Uses separate test database to avoid affecting development data.
    """
    # Use test database URL (ensure this replaces the DB name correctly)
    # This replaces 'fca_support' with 'fca_support_test' in the connection string
    test_db_url = settings.database_url.replace("fca_support", "fca_support_test")

    # Create test engine
    engine = create_async_engine(
        test_db_url,
        echo=False,  # Don't log SQL in tests
        future=True,
    )

    # Create tables
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.drop_all) # Start clean
        await conn.run_sync(Base.metadata.create_all)

    yield engine

    # Drop tables and dispose engine
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.drop_all)

    await engine.dispose()


@pytest_asyncio.fixture
async def db_session(test_engine) -> AsyncGenerator[AsyncSession, None]:
    """
    Create database session for testing.

    Yields:
        AsyncSession: Database session
    """
    # Create session maker
    async_session = async_sessionmaker(
        test_engine,
        class_=AsyncSession,
        expire_on_commit=False,
    )

    async with async_session() as session:
        yield session
        await session.rollback()

    # CRITICAL FIX: Clean up data after each test
    # Because service methods call .commit(), data persists even after session.rollback()
    # We must explicitly delete data to prevent "already exists" errors in subsequent tests
    async with test_engine.begin() as conn:
        # Delete data from all tables in reverse order of dependency
        for table in reversed(Base.metadata.sorted_tables):
            await conn.execute(table.delete())


# ============================================================================
# APPLICATION FIXTURES
# ============================================================================

@pytest_asyncio.fixture
async def client():
    """
    Create an async test client for testing FastAPI endpoints.
    """
    async with AsyncClient(app=app, base_url="http://test") as ac:
        yield ac

# ============================================================================
# UTILITY FIXTURES
# ============================================================================

@pytest.fixture
def anyio_backend():
    """
    Specify async backend for anyio.
    """
    return "asyncio"


--- START OF FILE: ./tests/__init__.py ---
"""
Test Package

This package contains all test modules for the FCA Multi-Agent Support System.
"""


--- START OF FILE: ./tests/test_customer.py ---
"""
Customer Tests

Tests for Customer model and CustomerService.
"""

import pytest
from sqlalchemy.ext.asyncio import AsyncSession

from app.services.customer import CustomerService
from app.models.customer import Customer


# ============================================================================
# CREATE TESTS
# ============================================================================

@pytest.mark.asyncio
async def test_create_customer(db_session: AsyncSession):
    """Test creating a customer."""
    service = CustomerService(db=db_session)

    customer = await service.create_customer(
        customer_id="CUST-003",
        first_name="John",
        last_name="Smith",
        email="john4@example.com",
        phone="+44123456789"
    )

    assert customer.id is not None
    assert customer.customer_id == "CUST-003"
    assert customer.first_name == "John"
    assert customer.last_name == "Smith"
    assert customer.email == "john4@example.com"
    assert customer.phone == "+44123456789"
    assert customer.is_active is True
    assert customer.is_verified is False
    assert customer.is_vip is False


@pytest.mark.asyncio
async def test_create_customer_duplicate_email(db_session: AsyncSession):
    """Test creating customer with duplicate email raises error."""
    service = CustomerService(db=db_session)

    # Create first customer
    await service.create_customer(
        customer_id="CUST-003",
        first_name="John",
        last_name="Smith",
        email="john4@example.com"
    )

    # Try to create second customer with same email
    with pytest.raises(ValueError, match="already exists"):
        await service.create_customer(
            customer_id="CUST-003",
            first_name="Jane",
            last_name="Doe",
            email="john4@example.com"
        )


# ============================================================================
# READ TESTS
# ============================================================================

@pytest.mark.asyncio
async def test_get_customer(db_session: AsyncSession):
    """Test getting customer by ID."""
    service = CustomerService(db=db_session)

    # Create customer
    created = await service.create_customer(
        customer_id="CUST-006",
        first_name="John",
        last_name="Smith",
        email="john6@example.com"
    )

    # Get customer
    customer = await service.get_customer(created.id)

    assert customer is not None
    assert customer.id == created.id
    assert customer.email == "john6@example.com"


@pytest.mark.asyncio
async def test_get_customer_by_email(db_session: AsyncSession):
    """Test getting customer by email."""
    service = CustomerService(db=db_session)

    # Create customer
    await service.create_customer(
        customer_id="CUST-001",
        first_name="John",
        last_name="Smith",
        email="john@example.com"
    )

    # Get by email
    customer = await service.get_customer_by_email("john@example.com")

    assert customer is not None
    assert customer.email == "john@example.com"


@pytest.mark.asyncio
async def test_search_customers(db_session: AsyncSession):
    """Test searching customers by name."""
    service = CustomerService(db=db_session)

    # Create customers
    await service.create_customer(
        customer_id="CUST-001",
        first_name="John",
        last_name="Smith",
        email="john@example.com"
    )

    await service.create_customer(
        customer_id="CUST-002",
        first_name="Jane",
        last_name="Johnson",
        email="jane@example.com"
    )

    # Search for "john"
    results = await service.search_customers("john")

    assert len(results) == 2  # Matches "John" and "Johnson"
    assert any(c.first_name == "John" for c in results)
    assert any(c.last_name == "Johnson" for c in results)


# ============================================================================
# UPDATE TESTS
# ============================================================================

@pytest.mark.asyncio
async def test_update_customer(db_session: AsyncSession):
    """Test updating customer."""
    service = CustomerService(db=db_session)

    # Create customer
    customer = await service.create_customer(
        customer_id="CUST-001",
        first_name="John",
        last_name="Smith",
        email="john@example.com"
    )

    # Update customer
    updated = await service.update_customer(
        customer.id,
        {"first_name": "Jane", "phone": "+44123456789"}
    )

    assert updated is not None
    assert updated.first_name == "Jane"
    assert updated.phone == "+44123456789"
    assert updated.last_name == "Smith"  # Unchanged


@pytest.mark.asyncio
async def test_verify_customer(db_session: AsyncSession):
    """Test verifying customer."""
    service = CustomerService(db=db_session)

    # Create customer
    customer = await service.create_customer(
        customer_id="CUST-001",
        first_name="John",
        last_name="Smith",
        email="john@example.com"
    )

    assert customer.is_verified is False

    # Verify customer
    verified = await service.verify_customer(customer.id)

    assert verified is not None
    assert verified.is_verified is True


@pytest.mark.asyncio
async def test_make_vip(db_session: AsyncSession):
    """Test making customer VIP."""
    service = CustomerService(db=db_session)

    # Create customer
    customer = await service.create_customer(
        customer_id="CUST-001",
        first_name="John",
        last_name="Smith",
        email="john@example.com"
    )

    assert customer.is_vip is False

    # Make VIP
    vip = await service.make_vip(customer.id)

    assert vip is not None
    assert vip.is_vip is True


# ============================================================================
# DELETE TESTS
# ============================================================================

@pytest.mark.asyncio
async def test_delete_customer(db_session: AsyncSession):
    """Test deleting customer."""
    service = CustomerService(db=db_session)

    # Create customer
    customer = await service.create_customer(
        customer_id="CUST-001",
        first_name="John",
        last_name="Smith",
        email="john@example.com"
    )

    customer_id = customer.id

    # Delete customer
    success = await service.delete_customer(customer_id)

    assert success is True

    # Verify deleted
    deleted = await service.get_customer(customer_id)
    assert deleted is None


# ============================================================================
# PROPERTY TESTS
# ============================================================================

@pytest.mark.asyncio
async def test_customer_full_name(db_session: AsyncSession):
    """Test customer full_name property."""
    service = CustomerService(db=db_session)

    customer = await service.create_customer(
        customer_id="CUST-001",
        first_name="John",
        last_name="Smith",
        email="john@example.com"
    )

    assert customer.full_name == "John Smith"


--- START OF FILE: ./tests/test_health.py ---
"""
Health Check Endpoint Tests

Tests for health check, ping, readiness, and liveness endpoints.
"""

import pytest
from httpx import AsyncClient


# ============================================================================
# HEALTH CHECK TESTS
# ============================================================================

@pytest.mark.asyncio
async def test_health_check_success(client: AsyncClient):
    """
    Test health check endpoint returns success.

    Verifies:
    - Status code 200 OK
    - Response structure
    - All required fields present
    - Health status is healthy
    """
    response = await client.get("/api/v1/health")

    # Check status code
    assert response.status_code == 200

    # Parse response
    data = response.json()

    # Check required fields
    assert "status" in data
    assert "timestamp" in data
    assert "version" in data
    assert "environment" in data
    assert "checks" in data

    # Check status is healthy
    assert data["status"] == "healthy"

    # Check version
    assert data["version"] == "0.1.0"

    # Check checks structure
    checks = data["checks"]
    assert "database" in checks
    assert "redis" in checks
    assert "groq_ai" in checks

    # Check database check
    db_check = checks["database"]
    assert "status" in db_check
    assert "type" in db_check
    assert db_check["type"] == "postgresql"


@pytest.mark.asyncio
async def test_health_check_database_status(client: AsyncClient):
    """
    Test health check includes database status.

    Verifies:
    - Database check exists
    - Database status is healthy
    - Pool size is reported
    """
    response = await client.get("/api/v1/health")
    data = response.json()

    db_check = data["checks"]["database"]

    # Check database status
    assert db_check["status"] == "healthy"
    assert "pool_size" in db_check
    assert db_check["pool_size"] > 0


# ============================================================================
# PING TESTS
# ============================================================================

@pytest.mark.asyncio
async def test_ping_success(client: AsyncClient):
    """
    Test ping endpoint returns success.

    Verifies:
    - Status code 200 OK
    - Response structure
    - Quick response time
    """
    response = await client.get("/api/v1/ping")

    # Check status code
    assert response.status_code == 200

    # Parse response
    data = response.json()

    # Check required fields
    assert "status" in data
    assert "timestamp" in data

    # Check status is ok
    assert data["status"] == "ok"


# ============================================================================
# READINESS TESTS
# ============================================================================

@pytest.mark.asyncio
async def test_readiness_success(client: AsyncClient):
    """
    Test readiness endpoint returns ready.

    Verifies:
    - Status code 200 OK
    - Response indicates ready
    """
    response = await client.get("/api/v1/ready")

    # Check status code
    assert response.status_code == 200

    # Parse response
    data = response.json()

    # Check status
    assert "status" in data
    assert data["status"] == "ready"


# ============================================================================
# LIVENESS TESTS
# ============================================================================

@pytest.mark.asyncio
async def test_liveness_success(client: AsyncClient):
    """
    Test liveness endpoint returns alive.

    Verifies:
    - Status code 200 OK
    - Response indicates alive
    """
    response = await client.get("/api/v1/live")

    # Check status code
    assert response.status_code == 200

    # Parse response
    data = response.json()

    # Check status
    assert "status" in data
    assert data["status"] == "alive"


# ============================================================================
# ROOT ENDPOINT TESTS
# ============================================================================

@pytest.mark.asyncio
async def test_root_endpoint(client: AsyncClient):
    """
    Test root endpoint returns API information.

    Verifies:
    - Status code 200 OK
    - Response structure
    - API metadata present
    """
    response = await client.get("/")

    # Check status code
    assert response.status_code == 200

    # Parse response
    data = response.json()

    # Check required fields
    assert "name" in data
    assert "version" in data
    assert "status" in data
    assert "environment" in data

    # Check values
    assert data["status"] == "operational"
    assert data["version"] == "0.1.0"


--- START OF FILE: ./tests/integration/test_integration.py ---
"""
Integration Tests

End-to-end testing of multi-agent system.
Tests workflow, coordinator, and API together.
"""

import asyncio
import pytest
from app.workflows.message_workflow import MessageWorkflow
from app.coordinator.agent_coordinator import AgentCoordinator


@pytest.fixture
def coordinator():
    """Provide coordinator instance."""
    return AgentCoordinator()


@pytest.fixture
def workflow():
    """Provide workflow instance."""
    return MessageWorkflow()


class TestAccountInquiry:
    """Test account inquiry flows."""

    @pytest.mark.asyncio
    async def test_balance_inquiry(self, coordinator):
        """Test balance inquiry."""
        response = await coordinator.process_message(
            message="What's my account balance?",
            customer_id=101,
            conversation_id=1,
        )

        assert response["agent"] == "account"
        assert response["intent"] == "account_inquiry"
        assert response["confidence"] > 0.8
        assert "balance" in response["response"].lower()

    @pytest.mark.asyncio
    async def test_transaction_history(self, coordinator):
        """Test transaction history request."""
        response = await coordinator.process_message(
            message="Show me my recent transactions",
            customer_id=101,
            conversation_id=1,
        )

        assert response["agent"] == "account"
        assert "transaction" in response["response"].lower()


class TestGeneralInquiry:
    """Test general inquiry flows."""

    @pytest.mark.asyncio
    async def test_faq_match(self, coordinator):
        """Test FAQ matching."""
        response = await coordinator.process_message(
            message="How do I open an account?",
            customer_id=102,
            conversation_id=2,
        )

        assert response["agent"] == "general"
        assert response["intent"] == "general_inquiry"
        assert "account" in response["response"].lower()

    @pytest.mark.asyncio
    async def test_support_info(self, coordinator):
        """Test support information."""
        response = await coordinator.process_message(
            message="How do I contact support?",
            customer_id=102,
            conversation_id=2,
        )

        assert response["agent"] == "general"
        assert "support" in response["response"].lower()


class TestEscalation:
    """Test escalation flows."""

    @pytest.mark.asyncio
    async def test_complaint_escalation(self, coordinator):
        """Test complaint escalation."""
        response = await coordinator.process_message(
            message="I'm not happy with your service!",
            customer_id=103,
            conversation_id=3,
        )

        assert response["agent"] == "human"
        assert response["intent"] == "complaint"
        assert response["escalated"]
        assert response["escalation_id"] is not None

    @pytest.mark.asyncio
    async def test_urgent_escalation(self, coordinator):
        """Test urgent escalation."""
        response = await coordinator.process_message(
            message="My card was stolen! I need immediate help!",
            customer_id=104,
            conversation_id=4,
        )

        assert response["agent"] == "human"
        assert response["escalated"]


class TestMultiTurn:
    """Test multi-turn conversations."""

    @pytest.mark.asyncio
    async def test_conversation_history(self, coordinator):
        """Test multi-turn conversation."""
        conv_id = 5
        customer_id = 105

        # Turn 1
        response1 = await coordinator.process_message(
            message="What's my balance?",
            customer_id=customer_id,
            conversation_id=conv_id,
        )
        assert response1["turn_count"] == 1

        # Turn 2
        response2 = await coordinator.process_message(
            message="Show transactions",
            customer_id=customer_id,
            conversation_id=conv_id,
        )
        assert response2["turn_count"] == 2

        # Turn 3
        response3 = await coordinator.process_message(
            message="I need a statement",
            customer_id=customer_id,
            conversation_id=conv_id,
        )
        assert response3["turn_count"] == 3

        # Verify history
        history = coordinator.get_conversation_history(conv_id)
        assert len(history) == 3


class TestStatistics:
    """Test statistics tracking."""

    @pytest.mark.asyncio
    async def test_agent_distribution(self, coordinator):
        """Test agent distribution statistics."""

        # Create messages for different agents
        await coordinator.process_message(
            message="What's my balance?",
            customer_id=101,
            conversation_id=10,
        )

        await coordinator.process_message(
            message="How do I open account?",
            customer_id=102,
            conversation_id=11,
        )

        await coordinator.process_message(
            message="I'm unhappy",
            customer_id=103,
            conversation_id=12,
        )

        # Check statistics
        stats = coordinator.get_statistics()
        assert stats["total_conversations"] > 0
        assert "account" in stats["agent_distribution"]
        assert "general" in stats["agent_distribution"]
        assert "human" in stats["agent_distribution"]



--- START OF FILE: ./alembic/env.py ---
"""
Alembic Environment Configuration

Configures Alembic to work with our SQLAlchemy models and async engine.
"""

from logging.config import fileConfig
import asyncio
from sqlalchemy import pool
from sqlalchemy.engine import Connection
from sqlalchemy.ext.asyncio import async_engine_from_config
from alembic import context

# Import application configuration
from app.config import settings
from app.database import Base

# Import all models to ensure they're registered
from app.models import Customer, Conversation, Message

# this is the Alembic Config object
config = context.config

# Interpret the config file for Python logging.
if config.config_file_name is not None:
    fileConfig(config.config_file_name)

# Set SQLAlchemy URL from settings
config.set_main_option("sqlalchemy.url", settings.database_url)

# Add your model's MetaData object here for 'autogenerate' support
target_metadata = Base.metadata


def run_migrations_offline() -> None:
    """
    Run migrations in 'offline' mode.

    This configures the context with just a URL and not an Engine,
    though an Engine is also acceptable here. By skipping the Engine
    creation we don't even need a DBAPI to be available.

    Calls to context.execute() here emit the given string to the
    script output.
    """
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )

    with context.begin_transaction():
        context.run_migrations()


def do_run_migrations(connection: Connection) -> None:
    """
    Run migrations with given connection.

    Args:
        connection: SQLAlchemy connection
    """
    context.configure(
        connection=connection,
        target_metadata=target_metadata,
        compare_type=True,  # Detect column type changes
        compare_server_default=True,  # Detect default value changes
    )

    with context.begin_transaction():
        context.run_migrations()


async def run_async_migrations() -> None:
    """
    Run migrations in async mode.

    Creates an async engine and runs migrations.
    """
    # Create async engine from config
    connectable = async_engine_from_config(
        config.get_section(config.config_ini_section, {}),
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
    )

    async with connectable.connect() as connection:
        # Run migrations in sync context
        await connection.run_sync(do_run_migrations)

    # Dispose engine
    await connectable.dispose()


def run_migrations_online() -> None:
    """
    Run migrations in 'online' mode.

    In this scenario we need to create an Engine and associate
    a connection with the context.
    """
    asyncio.run(run_async_migrations())


# Determine offline vs online mode
if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()


--- START OF FILE: ./alembic/versions/f57c936ded09_initial_migration_create_customers_.py ---
"""Initial migration: create customers, conversations, messages tables

Revision ID: f57c936ded09
Revises:
Create Date: 2025-12-14 18:31:52.625606

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = 'f57c936ded09'
down_revision: Union[str, None] = None
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('customers',
    sa.Column('first_name', sa.String(length=100), nullable=False, comment='Customer first name'),
    sa.Column('last_name', sa.String(length=100), nullable=False, comment='Customer last name'),
    sa.Column('email', sa.String(length=255), nullable=False, comment='Customer email address (unique)'),
    sa.Column('phone', sa.String(length=20), nullable=True, comment='Customer phone number'),
    sa.Column('customer_id', sa.String(length=50), nullable=False, comment='External customer ID from core banking system'),
    sa.Column('account_number', sa.String(length=50), nullable=True, comment='Primary account number'),
    sa.Column('is_active', sa.Boolean(), nullable=False, comment='Whether customer account is active'),
    sa.Column('is_verified', sa.Boolean(), nullable=False, comment='Whether customer identity is verified'),
    sa.Column('is_vip', sa.Boolean(), nullable=False, comment='VIP customer flag (premium service)'),
    sa.Column('notes', sa.Text(), nullable=True, comment='Internal notes about customer'),
    sa.Column('id', sa.Integer(), autoincrement=True, nullable=False, comment='Primary key'),
    sa.Column('created_at', sa.DateTime(timezone=True), nullable=False, comment='Record creation timestamp (UTC)'),
    sa.Column('updated_at', sa.DateTime(timezone=True), nullable=False, comment='Record last update timestamp (UTC)'),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index('idx_active_vip', 'customers', ['is_active', 'is_vip'], unique=False)
    op.create_index('idx_customer_name', 'customers', ['first_name', 'last_name'], unique=False)
    op.create_index(op.f('ix_customers_customer_id'), 'customers', ['customer_id'], unique=True)
    op.create_index(op.f('ix_customers_email'), 'customers', ['email'], unique=True)
    op.create_index(op.f('ix_customers_is_active'), 'customers', ['is_active'], unique=False)
    op.create_index(op.f('ix_customers_is_vip'), 'customers', ['is_vip'], unique=False)
    op.create_table('conversations',
    sa.Column('customer_id', sa.Integer(), nullable=False, comment='Foreign key to customer'),
    sa.Column('title', sa.String(length=200), nullable=False, comment='Conversation title/subject'),
    sa.Column('status', sa.Enum('ACTIVE', 'RESOLVED', 'ESCALATED', 'CLOSED', name='conversationstatus'), nullable=False, comment='Current conversation status'),
    sa.Column('channel', sa.Enum('WEB', 'MOBILE', 'API', 'WHATSAPP', 'SMS', name='conversationchannel'), nullable=False, comment='Communication channel'),
    sa.Column('summary', sa.Text(), nullable=True, comment='AI-generated conversation summary'),
    sa.Column('intent', sa.String(length=100), nullable=True, comment='Detected customer intent'),
    sa.Column('sentiment', sa.String(length=50), nullable=True, comment='Overall conversation sentiment'),
    sa.Column('message_count', sa.Integer(), nullable=False, comment='Total number of messages'),
    sa.Column('escalation_reason', sa.Text(), nullable=True, comment='Reason for escalation (if escalated)'),
    sa.Column('id', sa.Integer(), autoincrement=True, nullable=False, comment='Primary key'),
    sa.Column('created_at', sa.DateTime(timezone=True), nullable=False, comment='Record creation timestamp (UTC)'),
    sa.Column('updated_at', sa.DateTime(timezone=True), nullable=False, comment='Record last update timestamp (UTC)'),
    sa.ForeignKeyConstraint(['customer_id'], ['customers.id'], ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index('idx_channel_status', 'conversations', ['channel', 'status'], unique=False)
    op.create_index('idx_customer_status', 'conversations', ['customer_id', 'status'], unique=False)
    op.create_index('idx_intent', 'conversations', ['intent'], unique=False)
    op.create_index(op.f('ix_conversations_channel'), 'conversations', ['channel'], unique=False)
    op.create_index(op.f('ix_conversations_customer_id'), 'conversations', ['customer_id'], unique=False)
    op.create_index(op.f('ix_conversations_intent'), 'conversations', ['intent'], unique=False)
    op.create_index(op.f('ix_conversations_status'), 'conversations', ['status'], unique=False)
    op.create_table('messages',
    sa.Column('conversation_id', sa.Integer(), nullable=False, comment='Foreign key to conversation'),
    sa.Column('role', sa.Enum('CUSTOMER', 'AGENT', 'SYSTEM', 'HUMAN_AGENT', name='messagerole'), nullable=False, comment='Message sender role'),
    sa.Column('content', sa.Text(), nullable=False, comment='Message content/text'),
    sa.Column('agent_name', sa.String(length=100), nullable=True, comment='Name of AI agent that generated message (if role=agent)'),
    sa.Column('intent', sa.String(length=100), nullable=True, comment='Detected intent in customer message'),
    sa.Column('sentiment', sa.String(length=50), nullable=True, comment='Message sentiment (positive, negative, neutral)'),
    sa.Column('confidence_score', sa.Integer(), nullable=True, comment='Confidence score (0-100) for intent detection'),
    sa.Column('is_error', sa.Boolean(), nullable=False, comment='Whether message represents an error'),
    sa.Column('requires_human', sa.Boolean(), nullable=False, comment='Whether message requires human agent intervention'),
    sa.Column('metadata_json', sa.Text(), nullable=True, comment='Additional metadata as JSON string'),
    sa.Column('id', sa.Integer(), autoincrement=True, nullable=False, comment='Primary key'),
    sa.Column('created_at', sa.DateTime(timezone=True), nullable=False, comment='Record creation timestamp (UTC)'),
    sa.Column('updated_at', sa.DateTime(timezone=True), nullable=False, comment='Record last update timestamp (UTC)'),
    sa.ForeignKeyConstraint(['conversation_id'], ['conversations.id'], ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index('idx_conversation_created', 'messages', ['conversation_id', 'created_at'], unique=False)
    op.create_index('idx_conversation_intent', 'messages', ['conversation_id', 'intent'], unique=False)
    op.create_index('idx_requires_human', 'messages', ['requires_human'], unique=False)
    op.create_index('idx_role', 'messages', ['role'], unique=False)
    op.create_index(op.f('ix_messages_conversation_id'), 'messages', ['conversation_id'], unique=False)
    op.create_index(op.f('ix_messages_intent'), 'messages', ['intent'], unique=False)
    op.create_index(op.f('ix_messages_requires_human'), 'messages', ['requires_human'], unique=False)
    op.create_index(op.f('ix_messages_role'), 'messages', ['role'], unique=False)
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_index(op.f('ix_messages_role'), table_name='messages')
    op.drop_index(op.f('ix_messages_requires_human'), table_name='messages')
    op.drop_index(op.f('ix_messages_intent'), table_name='messages')
    op.drop_index(op.f('ix_messages_conversation_id'), table_name='messages')
    op.drop_index('idx_role', table_name='messages')
    op.drop_index('idx_requires_human', table_name='messages')
    op.drop_index('idx_conversation_intent', table_name='messages')
    op.drop_index('idx_conversation_created', table_name='messages')
    op.drop_table('messages')
    op.drop_index(op.f('ix_conversations_status'), table_name='conversations')
    op.drop_index(op.f('ix_conversations_intent'), table_name='conversations')
    op.drop_index(op.f('ix_conversations_customer_id'), table_name='conversations')
    op.drop_index(op.f('ix_conversations_channel'), table_name='conversations')
    op.drop_index('idx_intent', table_name='conversations')
    op.drop_index('idx_customer_status', table_name='conversations')
    op.drop_index('idx_channel_status', table_name='conversations')
    op.drop_table('conversations')
    op.drop_index(op.f('ix_customers_is_vip'), table_name='customers')
    op.drop_index(op.f('ix_customers_is_active'), table_name='customers')
    op.drop_index(op.f('ix_customers_email'), table_name='customers')
    op.drop_index(op.f('ix_customers_customer_id'), table_name='customers')
    op.drop_index('idx_customer_name', table_name='customers')
    op.drop_index('idx_active_vip', table_name='customers')
    op.drop_table('customers')
    # ### end Alembic commands ###
    # Drop ENUM types (PostgreSQL only)
    op.execute("DROP TYPE IF EXISTS conversationstatus CASCADE;")
    op.execute("DROP TYPE IF EXISTS conversationchannel CASCADE;")
    op.execute("DROP TYPE IF EXISTS messagerole CASCADE;")


--- START OF FILE: ./alembic/versions/20260114_add_priority_to_conversations.py ---
import os

# Create a single file containing all your code
with open("full_project.txt", "w", encoding="utf-8") as outfile:
    for root, dirs, files in os.walk("."):
        # Skip hidden folders like .git or venv
        if any(x in root for x in [".git", "venv", "__pycache__", "node_modules"]):
            continue

        for file in files:
            if file.endswith(".py"):  # Only grab python files
                path = os.path.join(root, file)
                outfile.write(f"\n\n--- START OF FILE: {path} ---\n")
                try:
                    with open(path, "r", encoding="utf-8") as infile:
                        outfile.write(infile.read())
                except Exception as e:
                    outfile.write(f"# Could not read file: {e}")

print("Done! Upload 'full_project.txt' to Gemini.")
