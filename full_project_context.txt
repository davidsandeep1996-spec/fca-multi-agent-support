PROJECT CONTEXT: fca-support-agent
INCLUDES: Python, Docker, Configs, and CI/CD Workflows.
==================================================

FILE PATH: ./test_general_agent.py
--------------------
"""
General Agent Test
"""

import asyncio
from app.agents.general_agent import GeneralAgent

async def test_general_agent():
    """Test general agent."""

    agent = GeneralAgent()

    # Test FAQ queries
    faq_queries = [
        "How do I open an account?",
        "What are your fees?",
        "Is my money safe?",
        "How do I contact support?",
        "What interest rates do you offer?",
    ]

    # Test general queries
    general_queries = [
        "Tell me about your mortgage options",
        "Do you have any special promotions?",
        "How long does transfers take?",
    ]

    print("="*60)
    print("FAQ MATCHING TESTS")
    print("="*60)

    for query in faq_queries:
        print(f"\nQuery: {query}")
        response = await agent.process({"message": query})
        print(f"Source: {response.metadata.get('source')}")
        print(f"Response preview: {response.content[:100]}...")

    print("\n" + "="*60)
    print("GENERAL QUERY TESTS (LLM-based)")
    print("="*60)

    for query in general_queries:
        print(f"\nQuery: {query}")
        response = await agent.process({"message": query})
        print(f"Source: {response.metadata.get('source')}")
        print(f"Response preview: {response.content[:100]}...")

if __name__ == "__main__":
    asyncio.run(test_general_agent())


FILE PATH: ./verify_productagent.py
--------------------
# File: app/verify_agent.py
import asyncio
from app.services.product_service import ProductService
from app.agents.product_recommender import ProductRecommenderAgent
from app.database import AsyncSessionLocal

async def main():
    print("\n" + "="*60)
    print("ðŸ” VERIFYING PRODUCT AGENT (DB CONNECTIVITY)")
    print("="*60)

    async with AsyncSessionLocal() as session:
        # 1. Initialize Service (Connected to DB)
        product_service = ProductService(db=session)

        # 2. Initialize Agent (With Service Injected)
        agent = ProductRecommenderAgent(product_service=product_service)

        # 3. Test Scenarios
        queries = [
            {"intent": "loan_inquiry", "message": "I want a personal loan"},
            {"intent": "savings_inquiry", "message": "Show me savings accounts"},
        ]

        for q in queries:
            print(f"\nðŸ¤– User asks: '{q['message']}'")

            # Run the agent
            response = await agent.process(q)

            # Print results
            print(f"âœ… Agent Response Preview: {response.content[:100]}...")

            # Verify data source (Metadata should contain product names from DB)
            found_products = response.metadata.get('products', [])
            print(f"ðŸ“¦ DB Products Found: {found_products}")

            if not found_products:
                print("âŒ WARNING: No products found! Check DB seeding.")
            else:
                print("âœ… SUCCESS: Data fetched from Database.")

if __name__ == "__main__":
    asyncio.run(main())


FILE PATH: ./test_product_recommender.py
--------------------
import asyncio
from app.agents.product_recommender import ProductRecommenderAgent

async def test_recommender():
    # Create agent
    agent = ProductRecommenderAgent()

    # Test scenarios
    scenarios = [
        {
            "input": {
                "intent": "loan_inquiry",
                "message": "I'm a first-time buyer looking for a mortgage"
            },
            "context": {
                "customer": {"is_vip": False}
            }
        },
        {
            "input": {
                "intent": "savings_inquiry",
                "message": "I want to save for a house deposit over 3 years"
            },
            "context": {
                "customer": {"is_vip": True}
            }
        },
    ]

    for i, scenario in enumerate(scenarios, 1):
        print(f"\n{'='*60}")
        print(f"Scenario {i}")
        print(f"{'='*60}")
        print(f"Intent: {scenario['input']['intent']}")
        print(f"Message: {scenario['input']['message']}")
        print(f"VIP: {scenario['context']['customer']['is_vip']}")

        response = await agent.process(
            scenario["input"],
            scenario["context"]
        )

        print(f"\nResponse:\n{response.content}")
        print(f"\nConfidence: {response.confidence}")
        print(f"Products: {[p['name'] for p in response.metadata['products']]}")

if __name__ == "__main__":
    asyncio.run(test_recommender())


FILE PATH: ./test_human_agent.py
--------------------
"""
Human Agent Test
"""

import asyncio
from app.agents.human_agent import HumanAgent

async def test_human_agent():
    """Test human agent."""

    agent = HumanAgent()

    # Test escalation scenarios
    test_cases = [
        {
            "message": "My card was stolen and I need immediate help!",
            "expected_priority": "urgent",
        },
        {
            "message": "I'm not happy with your service. I want to lodge a complaint.",
            "expected_priority": "high",
        },
        {
            "message": "I'd like to speak to someone about changing my account type.",
            "expected_priority": "medium",
        },
        {
            "message": "Can someone help me with my account?",
            "expected_priority": "low",
        },
    ]

    print("="*60)
    print("ESCALATION TESTS")
    print("="*60)

    for case in test_cases:
        print(f"\nMessage: {case['message']}")
        print(f"Expected Priority: {case['expected_priority'].upper()}")

        response = await agent.process({
            "message": case["message"],
            "customer_id": 1,
            "conversation_id": 1,
        })

        actual_priority = response.metadata.get("priority")
        print(f"Actual Priority: {actual_priority.upper()}")
        print(f"Escalation ID: {response.metadata.get('escalation_id')}")
        print(f"Response Preview: {response.content[:80]}...")

if __name__ == "__main__":
    asyncio.run(test_human_agent())


FILE PATH: ./Dockerfile
--------------------
# ============================================================================
# STAGE 1: Base
# ============================================================================

FROM python:3.11-slim as base

# Set environment variables
ENV PYTHONUNBUFFERED=1 \
    PYTHONDONTWRITEBYTECODE=1 \
    PIP_NO_CACHE_DIR=1 \
    PIP_DISABLE_PIP_VERSION_CHECK=1

# Install system dependencies
RUN apt-get update && apt-get install -y \
    gcc \
    postgresql-client \
    && rm -rf /var/lib/apt/lists/*

# Create app user (don't run as root)
RUN useradd -m -u 1000 appuser

# Set working directory
WORKDIR /app

# ============================================================================
# STAGE 2: Dependencies
# ============================================================================

FROM base as dependencies

# Copy requirements
COPY requirements.txt .

# Install Python dependencies
RUN pip install --no-cache-dir -r requirements.txt

# ============================================================================
# STAGE 3: Application
# ============================================================================

FROM dependencies as application

# Copy application code
COPY --chown=appuser:appuser . .

# Switch to non-root user
USER appuser

# Expose port
EXPOSE 8000

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
    CMD python -c "import requests; requests.get('http://localhost:8000/api/v1/health')" || exit 1

# Run application
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]


FILE PATH: ./com31.py
--------------------
from app.database import AsyncSessionLocal
from app.repositories import CustomerRepository

# Create session and repository
async def test():
    async with AsyncSessionLocal() as session:
        repo = CustomerRepository(session)

        # Create customer
        data = {
            "customer_id": "CUST-001",
            "first_name": "John",
            "last_name": "Smith",
            "email": "john@example.com"
        }
        customer = await repo.create(data)
        await session.commit()

        print(f"Created: {customer}")
        print(f"ID: {customer.id}")

        # Get by email
        found = await repo.get_by_email("john@example.com")
        print(f"Found: {found}")

import asyncio
asyncio.run(test())


FILE PATH: ./test_coordinator.py
--------------------
"""
Agent Coordinator Test
"""

import asyncio
from app.coordinator.agent_coordinator import AgentCoordinator

async def test_coordinator():
    """Test agent coordinator."""

    coordinator = AgentCoordinator()

    print("\n" + "="*60)
    print("AGENT COORDINATOR TEST")
    print("="*60)

    # Simulate multi-turn conversation
    conversations = [
        {
            "conv_id": 1,
            "customer_id": 101,
            "messages": [
                "What's my account balance?",
                "Show me recent transactions",
                "I need a statement",
            ]
        },
        {
            "conv_id": 2,
            "customer_id": 102,
            "messages": [
                "How do I open an account?",
                "What fees do you charge?",
            ]
        },
        {
            "conv_id": 3,
            "customer_id": 103,
            "messages": [
                "I'm not happy with your service!",
                "I want to escalate this issue",
            ]
        },
    ]

    # Process conversations
    for conv_data in conversations:
        conv_id = conv_data["conv_id"]
        customer_id = conv_data["customer_id"]

        print(f"\n--- Conversation {conv_id} (Customer {customer_id}) ---")

        for msg in conv_data["messages"]:
            response = await coordinator.process_message(
                message=msg,
                customer_id=customer_id,
                conversation_id=conv_id,
            )

            print(f"\nMessage: {msg}")
            print(f"Agent: {response['agent']}")
            print(f"Intent: {response['intent']}")
            print(f"Turn: {response['turn_count']}")
            if response.get('escalation_id'):
                print(f"âš ï¸ Escalated: {response['escalation_id']}")

    # Print statistics
    print("\n" + "="*60)
    print("STATISTICS")
    print("="*60)
    stats = coordinator.get_statistics()
    print(f"Total Conversations: {stats['total_conversations']}")
    print(f"Total Messages: {stats['total_messages']}")
    print(f"Escalated: {stats['escalated_conversations']}")
    print(f"Avg Messages/Conversation: {stats['avg_messages_per_conversation']:.1f}")
    print("\nAgent Distribution:")
    for agent, count in stats['agent_distribution'].items():
        print(f"  {agent}: {count}")
    print("\nIntent Distribution:")
    for intent, count in stats['intent_distribution'].items():
        print(f"  {intent}: {count}")

    # Get conversation history
    print("\n" + "="*60)
    print("CONVERSATION HISTORY (Conv 1)")
    print("="*60)
    history = coordinator.get_conversation_history(1)
    for i, turn in enumerate(history, 1):
        print(f"\nTurn {i}:")
        print(f"  User: {turn['message']}")
        print(f"  Agent: {turn['agent']}")
        print(f"  Intent: {turn['intent']}")

if __name__ == "__main__":
    asyncio.run(test_coordinator())


FILE PATH: ./pyproject.toml
--------------------
[build-system]
requires = ["setuptools>=45", "setuptools-scm[toml]>=6.2"]
build-backend = "setuptools.build_meta"

[project]
name = "fca-multi-agent-support"
version = "0.1.0"
description = "FCA-compliant multi-agent AI support system for UK financial services"
readme = "README.md"
requires-python = ">=3.11"
license = {text = "MIT"}
authors = [
    {name = "David Sandeep", email = "davidsandeep1996@gmail.com"}
]
keywords = ["ai", "multi-agent", "fca", "compliance", "support"]
classifiers = [
    "Development Status :: 3 - Alpha",
    "Intended Audience :: Developers",
    "License :: OSI Approved :: MIT License",
    "Programming Language :: Python :: 3.11",
    "Framework :: FastAPI",
]

[project.urls]
Homepage = "https://github.com/yourusername/fca-multi-agent-support"
Repository = "https://github.com/yourusername/fca-multi-agent-support"
Documentation = "https://github.com/yourusername/fca-multi-agent-support/docs"

# ============================================================================
# TOOL CONFIGURATION
# ============================================================================

[tool.black]
line-length = 100
target-version = ['py311']
include = '\.pyi?$'
extend-exclude = '''
/(
  # directories
  \.eggs
  | \.git
  | \.hg
  | \.mypy_cache
  | \.tox
  | \.venv
  | build
  | dist
)/
'''

[tool.isort]
profile = "black"
line_length = 100
multi_line_output = 3
include_trailing_comma = true
force_grid_wrap = 0
use_parentheses = true
ensure_newline_before_comments = true

[tool.pytest.ini_options]
minversion = "7.0"
testpaths = ["tests"]
python_files = ["test_*.py"]
python_classes = ["Test*"]
python_functions = ["test_*"]
addopts = """
    -v
    --strict-markers
    --strict-config
    --cov=app
    --cov-report=term-missing
    --cov-report=html
"""
markers = [
    "asyncio: marks tests as async (deselect with '-m \"not asyncio\"')",
    "integration: marks tests as integration tests",
    "unit: marks tests as unit tests",
]

[tool.mypy]
python_version = "3.11"
warn_return_any = true
warn_unused_configs = true
disallow_untyped_defs = false
disallow_incomplete_defs = false
check_untyped_defs = true
disallow_untyped_decorators = false
no_implicit_optional = true
warn_redundant_casts = true
warn_unused_ignores = true
warn_no_return = true
follow_imports = "normal"
ignore_missing_imports = true

[[tool.mypy.overrides]]
module = ["tests.*"]
ignore_errors = true

[tool.coverage.run]
source = ["app"]
omit = [
    "*/tests/*",
    "*/migrations/*",
    "*/__init__.py",
]

[tool.coverage.report]
exclude_lines = [
    "pragma: no cover",
    "def __repr__",
    "raise AssertionError",
    "raise NotImplementedError",
    "if __name__ == .__main__.:",
    "if TYPE_CHECKING:",
    "class .*\\bProtocol\\):",
    "@(abc\\.)?abstractmethod",
]


FILE PATH: ./test_account_agent.py
--------------------
import asyncio
from app.agents.account_agent import AccountAgent

async def test_account_agent():
    agent = AccountAgent()

    test_messages = [
        "What's my account balance?",
        "Show me my recent transactions",
        "I need a statement",
        "Tell me about my account",
    ]

    for message in test_messages:
        print("\n" + "="*60)
        print(f"Query: {message}")
        print("="*60)

        response = await agent.process(
            {
                "customer_id": 1,
                "message": message,
            },
            context=None,  # no services needed
        )

        print(f"Response: {response.content}")
        print(f"Query Type: {response.metadata.get('query_type')}")

if __name__ == "__main__":
    asyncio.run(test_account_agent())


FILE PATH: ./com50.py
--------------------
import asyncio

from app.database import AsyncSessionLocal
from app.services.account_service import AccountService
from app.services.customer import CustomerService
from app.services.transaction_service import TransactionService
from app.services.product_service import ProductService
from app.services.conversation import ConversationService  # if this exists in your project

from app.agents.account_agent import AccountAgent
from app.agents.product_recommender import ProductRecommenderAgent
from app.agents.general_agent import GeneralAgent
from app.agents.human_agent import HumanAgent


async def main():
    async with AsyncSessionLocal() as session:
        # DB-backed services
        account_svc = AccountService(db=session)
        customer_svc = CustomerService(db=session)
        txn_svc = TransactionService(db=session)
        product_svc = ProductService(db=session)

        # Agents
        account_agent = AccountAgent(
            account_service=account_svc,
            customer_service=customer_svc,
            transaction_service=txn_svc,
        )

        product_agent = ProductRecommenderAgent(product_service=product_svc)  # requires injection [file:243]

        # For a true DB test, update GeneralAgent to accept injected ProductService (recommended)
        general_agent = GeneralAgent(product_service=product_svc)  # only works if you implement injection [file:245]

        human_agent = HumanAgent(conversation_service=ConversationService(db=session))  # if your ConversationService supports db

        customer_id = 2210
        conversation_id = 1

        print("\n--- AccountAgent (balance) ---")
        print((await account_agent.process({"customer_id": customer_id, "message": "What is my balance?"})).to_dict())

        print("\n--- AccountAgent (transactions) ---")
        print((await account_agent.process({"customer_id": customer_id, "message": "Show my recent transactions"})).to_dict())

        print("\n--- ProductRecommenderAgent (DB products + LLM) ---")
        # Note: this will also call Groq; if you want DB-only, modify ProductRecommenderAgent to fetch products from product_svc
        print((await product_agent.process({"customer_id": customer_id, "message": "I want a credit card"})).to_dict())

        print("\n--- GeneralAgent (should hit FAQ, not DB unless you add DB usage) ---")
        print((await general_agent.process({"message": "What are your fees?"})).to_dict())

        print("\n--- HumanAgent escalation (DB only if ConversationService saves) ---")
        ctx = {"conversation_service": human_agent.conversation_service}
        print((await human_agent.process(
            {"message": "I want to make a complaint", "customer_id": customer_id, "conversation_id": conversation_id},
            context=ctx,
        )).to_dict())

if __name__ == "__main__":
    asyncio.run(main())


FILE PATH: ./debug_faq.py
--------------------
"""
DEBUG SCRIPT: FAQ Data Layer
Usage: docker compose exec web python -m app.debug_faq
"""
import asyncio
from sqlalchemy import select, text
from app.database import AsyncSessionLocal
from app.models.faq import FAQ
from app.repositories.faq import FAQRepository

async def main():
    print("\n" + "="*50)
    print("ðŸž FAQ DATA FORENSICS")
    print("="*50)

    async with AsyncSessionLocal() as session:
        # TEST 1: RAW SQL COUNT
        # Check if the table even has rows
        result = await session.execute(text("SELECT count(*) FROM faqs"))
        count = result.scalar()
        print(f"ðŸ“Š Total Rows in 'faqs' table: {count}")

        if count == 0:
            print("âŒ CRITICAL: Table is empty! You must run the seed script again.")
            return

        # TEST 2: RAW CONTENT DUMP
        # Let's see exactly what is inside the first row
        result = await session.execute(select(FAQ).limit(1))
        first_faq = result.scalar()
        print(f"\nðŸ“ First FAQ Sample:")
        print(f"   - ID: {first_faq.id}")
        print(f"   - Question: '{first_faq.question}'")
        print(f"   - Keywords: '{first_faq.keywords}'")

        # TEST 3: REPOSITORY SEARCH (Simple Keyword)
        # We search for just "account" to prove the mechanism works
        print("\nðŸ” Testing Repository Search (Keyword: 'account')...")
        repo = FAQRepository(session)
        results = await repo.search("account")

        if results:
            print(f"   âœ… FOUND {len(results)} matches!")
            print(f"   - Match 1: {results[0].question}")
        else:
            print("   âŒ SEARCH FAILED for simple keyword.")

        # TEST 4: REPOSITORY SEARCH (Full Sentence)
        # This is what failed in your previous test
        query = "How do I open an account?"
        print(f"\nðŸ” Testing Repository Search (Full Sentence: '{query}')...")
        results_full = await repo.search(query)

        if results_full:
             print(f"   âœ… FOUND match!")
        else:
             print(f"   âŒ SEARCH FAILED for full sentence.")
             print("   ðŸ‘‰ Diagnosis: The search logic (ilike) might be too strict for full sentences.")

if __name__ == "__main__":
    asyncio.run(main())


FILE PATH: ./README.md
--------------------
# FCA Multi-Agent Support System

[![Python 3.11](https://img.shields.io/badge/python-3.11-blue.svg)](https://www.python.org/downloads/)
[![FastAPI](https://img.shields.io/badge/FastAPI-0.104.1-green.svg)](https://fastapi.tiangolo.com/)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](LICENSE)

**FCA-compliant multi-agent AI support system for UK financial services.**

An intelligent customer support system using LangGraph multi-agent orchestration with FCA Consumer Duty compliance validation.

---

## âœ¨ Features

ðŸ¤– **Multi-Agent Architecture**
- Intent classification for smart routing
- Specialized agents (FAQ, Account, Payment, Compliance, Escalation)
- LangGraph workflow orchestration

ðŸ›¡ï¸ **FCA Consumer Duty Compliance**
- Automated compliance checking
- Vulnerable customer identification
- Fair treatment validation
- Clear communication standards

ðŸš€ **Production-Ready**
- FastAPI async framework
- PostgreSQL database with SQLAlchemy ORM
- Redis caching (optional)
- Comprehensive testing
- Docker support

ðŸ“Š **Monitoring & Audit**
- Complete audit trail
- Agent performance metrics
- Conversation analytics
- Request tracking

---

## ðŸ—ï¸ Architecture

```
User â†’ FastAPI â†’ LangGraph Workflow
                      â†“
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚   Intent Classifier     â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â†“
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚  FAQ | Account | Payment      â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â†“
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚   Compliance Checker      â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â†“
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚   Escalation Agent        â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ðŸ“‹ Prerequisites

- **Python 3.11+**
- **PostgreSQL 15+**
- **Docker** (optional, recommended)
- **Groq API Key** (free at https://console.groq.com)

---

## ðŸš€ Quick Start

### 1. Clone Repository

```bash
git clone https://github.com/yourusername/fca-multi-agent-support.git
cd fca-multi-agent-support
```

### 2. Set Up Environment

```bash
# Create virtual environment
python -m venv venv

# Activate (Windows)
venv\Scripts\activate

# Activate (Mac/Linux)
source venv/bin/activate

# Install dependencies
pip install -r requirements.txt
```

### 3. Configure Environment Variables

```bash
# Copy template
cp .env.example .env

# Edit .env with your settings
# REQUIRED: Add your Groq API key
notepad .env  # Windows
nano .env     # Mac/Linux
```

### 4. Start Database (Docker)

```bash
docker-compose up -d db redis
```

### 5. Initialize Database

```bash
python scripts/init_db.py create
```

### 6. Run Application

```bash
uvicorn app.main:app --reload
```

Visit: http://localhost:8000/docs

---

## ðŸ“ Project Structure

```
fca-multi-agent-support/
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ agents/          # AI agent implementations
â”‚   â”œâ”€â”€ graph/           # LangGraph workflows
â”‚   â”œâ”€â”€ models/          # Database models
â”‚   â”œâ”€â”€ routers/         # API endpoints
â”‚   â”œâ”€â”€ services/        # Business logic
â”‚   â”œâ”€â”€ middleware/      # HTTP middleware
â”‚   â”œâ”€â”€ config.py        # Configuration
â”‚   â”œâ”€â”€ database.py      # Database setup
â”‚   â”œâ”€â”€ logger.py        # Logging
â”‚   â””â”€â”€ main.py          # FastAPI app
â”‚
â”œâ”€â”€ tests/               # Test suite
â”œâ”€â”€ docs/                # Documentation
â”œâ”€â”€ scripts/             # Utility scripts
â”œâ”€â”€ .github/workflows/   # CI/CD pipelines
â”‚
â”œâ”€â”€ docker-compose.yml   # Docker orchestration
â”œâ”€â”€ Dockerfile           # Container definition
â”œâ”€â”€ requirements.txt     # Python dependencies
â”œâ”€â”€ pyproject.toml       # Tool configuration
â”œâ”€â”€ .env.example         # Environment template
â””â”€â”€ README.md            # This file
```

---

## ðŸ§ª Testing

```bash
# Run all tests
pytest

# Run with coverage
pytest --cov=app --cov-report=html

# Run specific test file
pytest tests/test_agents.py

# Run integration tests only
pytest -m integration
```

---

## ðŸ³ Docker

### Using Docker Compose (Recommended)

```bash
# Start all services (app, database, redis)
docker-compose up -d

# View logs
docker-compose logs -f

# Stop services
docker-compose down

# Rebuild after code changes
docker-compose up -d --build
```

### Manual Docker Build

```bash
# Build image
docker build -t fca-support .

# Run container
docker run -p 8000:8000 --env-file .env fca-support
```

---

## ðŸ“Š API Endpoints

### Chat
- `POST /api/v1/chat` - Send message and get response
- `GET /api/v1/conversation/{id}` - Get conversation history

### Health
- `GET /api/v1/health` - System health check
- `GET /api/v1/ping` - Simple ping

### Documentation
- `GET /docs` - Swagger UI
- `GET /redoc` - ReDoc UI

---

## ðŸ”§ Development

### Code Formatting

```bash
# Format code with black
black app/

# Sort imports
isort app/

# Lint with flake8
flake8 app/

# Type checking
mypy app/
```

### Database Migrations

```bash
# Create migration
alembic revision -m "description"

# Apply migrations
alembic upgrade head

# Rollback
alembic downgrade -1
```

---

## ðŸ“ˆ Monitoring

### Logs

Logs are written to `logs/app.log` in JSON format:

```bash
# View logs
tail -f logs/app.log

# Parse JSON logs
cat logs/app.log | jq
```

### Metrics

Agent performance metrics tracked in `agent_metrics` table.

---

## ðŸ›¡ï¸ Security

- âœ… Environment variables for secrets
- âœ… SQL injection prevention (SQLAlchemy ORM)
- âœ… Input validation (Pydantic)
- âœ… Rate limiting
- âœ… CORS configuration
- âœ… Request size limits

---

## ðŸ“ Configuration

Key environment variables (see `.env.example`):

| Variable | Description | Required |
|----------|-------------|----------|
| `GROQ_API_KEY` | Groq AI API key | âœ… Yes |
| `DATABASE_URL` | PostgreSQL connection | âœ… Yes |
| `SECRET_KEY` | Encryption key | âœ… Yes |
| `REDIS_URL` | Redis connection | âŒ Optional |
| `LOG_LEVEL` | Logging verbosity | âŒ Optional |

---

## ðŸ¤ Contributing

1. Fork the repository
2. Create feature branch (`git checkout -b feature/amazing-feature`)
3. Commit changes (`git commit -m 'Add amazing feature'`)
4. Push to branch (`git push origin feature/amazing-feature`)
5. Open Pull Request

### Code Standards

- Follow PEP 8 (enforced by black)
- Add tests for new features
- Update documentation
- Keep commits atomic

---

## ðŸ“œ License

This project is licensed under the MIT License - see [LICENSE](LICENSE) file.

---

## ðŸ™ Acknowledgments

- **LangChain & LangGraph** - AI agent framework
- **FastAPI** - Web framework
- **Groq** - Fast LLM inference
- **FCA** - Consumer Duty principles

---

## ðŸ“ž Support

- **Issues**: [GitHub Issues](https://github.com/davidsandeep1996-spec/fca-multi-agent-support/issues)

- **Email**: davidsandeep1996@gmail.com

---

## ðŸ—ºï¸ Roadmap

- [x] Phase 1: Project setup
- [x] Phase 2: Core application
- [x] Phase 3: Database layer
- [x] Phase 4: Multi-agent system
- [x] Phase 5: API & services
- [ ] Phase 6: WebSocket support
- [ ] Phase 7: Admin dashboard
- [ ] Phase 8: Production deployment


## Progress

### âœ… Phase 1: Project Setup (Complete)
- Git repository initialized
- Directory structure created
- Configuration files (.gitignore, .env.example, etc.)
- Docker setup (Dockerfile, docker-compose.yml)
- CI/CD pipeline (.github/workflows/ci.yml)
- Development environment (VS Code settings)
- Documentation (README, CONTRIBUTING, Architecture)

### âœ… Phase 2: Core Application (Complete)
- FastAPI application structure
- Configuration management (Pydantic Settings)
- Structured logging (JSON format)
- Database connection (SQLAlchemy async)
- Base models and mixins
- Health check endpoints
- Test infrastructure (pytest)
- Basic test coverage

### âœ… Phase 3: Database Layer (Complete)
- Customer model
- Conversation model
- Message model
- Repository pattern
- Service layer

### â³ Phase 4: Multi-Agent System (In Progress)
- Agent base classes
- Intent classifier
- Product recommender
- Compliance checker
- LangGraph workflow

### â³ Phase 5: API & Services
- Conversation endpoints
- Message endpoints
- WebSocket support
- Real-time chat

---

**Made with â¤ï¸ for UK Financial Services**


FILE PATH: ./test_intent.py
--------------------
import asyncio
from app.agents.intent_classifier import IntentClassifierAgent

async def test_classifier():
    # Create agent
    agent = IntentClassifierAgent()

    # Test messages
    messages = [
        "I want to apply for a mortgage",
        "What is my account balance?",
        "I'm not happy with the service",
        "Hello, can you help me?",
    ]

    for msg in messages:
        print(f"\nMessage: {msg}")

        response = await agent.process({"message": msg})

        print(f"Intent: {response.metadata['intent']}")
        print(f"Confidence: {response.confidence}")
        print(f"Sentiment: {response.metadata['sentiment']}")
        print(f"Routing: {response.metadata['routing']}")
        print(f"Explanation: {response.metadata['explanation']}")

if __name__ == "__main__":
    asyncio.run(test_classifier())


FILE PATH: ./test_workflow.py
--------------------
"""
Message Workflow Test
"""

import asyncio
from app.workflows.message_workflow import MessageWorkflow

async def test_workflow():
    """Test message workflow."""

    workflow = MessageWorkflow()

    # Print workflow info
    print("\n" + "="*60)
    print("WORKFLOW STRUCTURE")
    print("="*60)
    info = workflow.get_workflow_info()
    for line in info["flow"]:
        print(line)

    # Test scenarios
    test_cases = [
        {
            "message": "i want a credit card?",
            "expected_agent": "account",
        },
        {
            "message": "i want a mortgage?",
            "expected_agent": "general",
        },
        {
            "message": "I'm not happy with your service!",
            "expected_agent": "human",
        },
    ]

    for case in test_cases:
        print("\n" + "="*60)
        print(f"Test: {case['message']}")
        print("="*60)

        response = await workflow.process_message(
            message=case["message"],
            customer_id=1,
            conversation_id=1,
        )

        print(f"Agent: {response.get('agent')}")
        print(f"Intent: {response.get('intent')}")
        print(f"Confidence: {response.get('confidence'):.2f}")
        print(f"\nResponse:\n{response.get('message')[:150]}...")

if __name__ == "__main__":
    asyncio.run(test_workflow())


FILE PATH: ./CONTRIBUTING.md
--------------------
# Contributing to FCA Multi-Agent Support System

Thank you for your interest in contributing! This document provides guidelines for contributing to this project.

## Development Setup

1. Fork repository
2. Clone your fork
3. Create virtual environment
4. Install dependencies
5. Create feature branch

Detailed instructions in README.md

## Code Standards

### Python Style
- **PEP 8** - Follow Python style guide
- **black** - Auto-format with black
- **100 chars** - Max line length
- **Type hints** - Add type annotations
- **Docstrings** - Document all functions

### Git Commits
- **Atomic** - One logical change per commit
- **Descriptive** - Clear commit messages
- **Conventional** - Use conventional commit format

Example:
```
feat: Add customer vulnerability detection
fix: Correct database connection timeout
docs: Update API documentation
test: Add compliance checker tests
```

### Testing
- Write tests for new features
- Maintain >80% code coverage
- Run full test suite before PR

## Pull Request Process

1. **Create branch** - `feature/your-feature-name`
2. **Make changes** - Implement feature
3. **Add tests** - Ensure coverage
4. **Update docs** - README, docstrings
5. **Run checks** - Tests, linting, formatting
6. **Create PR** - Clear description
7. **Address feedback** - Respond to reviews

## Questions?

Open an issue or discussion on GitHub.


FILE PATH: ./com32.py
--------------------
from app.services import CustomerService, ConversationService
from app.models.conversation import ConversationChannel
import asyncio

async def test():
    # Create customer
    async with CustomerService() as service:
        customer = await service.create_customer(
            customer_id="CUST-002",
            first_name="John",
            last_name="Smith",
            email="john1@example.com"
        )
        print(f"Created customer: {customer.id}")

    # Start conversation
    async with ConversationService() as service:
        conv = await service.start_conversation(
            customer_id=customer.id,
            title="Loan Inquiry",
            channel=ConversationChannel.WEB
        )
        print(f"Started conversation: {conv.id}")

asyncio.run(test())

asyncio.run(test())


FILE PATH: ./com36.py
--------------------
from app.agents.base import BaseAgent, AgentConfig, AgentResponse

# Test AgentConfig
config = AgentConfig(temperature=0.5, max_tokens=512)
config.to_dict()
{'model_name': 'mixtral-8x7b-32768', 'temperature': 0.5, 'max_tokens': 512, 'timeout': 30}

# Test AgentResponse
response = AgentResponse(
    content="Test response",
    confidence=0.9,
    agent_name="test_agent"
)
response.to_dict()
{'content': 'Test response', 'metadata': {}, 'confidence': 0.9, }

# Test abstract class (should fail)
try:
    agent = BaseAgent("test")
except TypeError as e:
    print(f"Expected error: {e}")


FILE PATH: ./docker-compose.yml
--------------------
version: '3.8'

# ============================================================================
# SERVICES
# ============================================================================

services:
  # PostgreSQL Database
  db:
    image: postgres:15-alpine
    container_name: fca-postgres
    restart: unless-stopped
    environment:
      POSTGRES_USER: fca_user
      POSTGRES_PASSWORD: fca_password
      POSTGRES_DB: fca_support
      POSTGRES_INITDB_ARGS: "--encoding=UTF8 --lc-collate=en_US.UTF-8 --lc-ctype=en_US.UTF-8"
    ports:
      - "5433:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: [ "CMD-SHELL", "pg_isready -U fca_user -d fca_support" ]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 10s
    networks:
      - fca-network

  # Redis Cache
  redis:
    image: redis:7-alpine
    container_name: fca-redis
    restart: unless-stopped
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    command: redis-server --appendonly yes --maxmemory 256mb --maxmemory-policy allkeys-lru
    healthcheck:
      test: [ "CMD", "redis-cli", "ping" ]
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - fca-network

  # FastAPI Application
  web:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: fca-app
    restart: unless-stopped
    ports:
      - "8000:8000"
    environment:
      # Application
      APP_NAME: FCA Multi-Agent Support System
      APP_VERSION: 0.1.0
      ENVIRONMENT: development
      DEBUG: "true"

      # Database
      DATABASE_URL: postgresql+asyncpg://fca_user:fca_password@db:5432/fca_support
      DATABASE_ECHO: "false"

      # Redis
      REDIS_URL: redis://redis:6379/0
      REDIS_ENABLED: "true"

      # Groq AI (from .env file)
      GROQ_API_KEY: ${GROQ_API_KEY}
      GROQ_MODEL: mixtral-8x7b-32768
      GROQ_TEMPERATURE: "0.7"
      GROQ_MAX_TOKENS: "1024"
      GROQ_TIMEOUT: "30"

      # Security
      SECRET_KEY: ${SECRET_KEY:-secret-key-change-in-production}
      CORS_ORIGINS: '["http://localhost:3000","http://localhost:8000"]'

      # Logging
      LOG_LEVEL: INFO
      LOG_FILE: logs/app.log
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy
    volumes:
      - ./logs:/app/logs
      - ./app:/app/app          # <---  THIS (Syncs python code)
      - ./alembic:/app/alembic  # <---  THIS (Syncs migrations)
      - ./tests:/app/tests    # <---  THIS (Syncs tests)
    networks:
      - fca-network
    command: uvicorn app.main:app --host 0.0.0.0 --port 8000 --reload

# ============================================================================
# VOLUMES
# ============================================================================

volumes:
  postgres_data:
    driver: local
  redis_data:
    driver: local

# ============================================================================
# NETWORKS
# ============================================================================

networks:
  fca-network:
    driver: bridge


FILE PATH: ./test_api.py
--------------------
"""
Message Router API Test
"""

import asyncio
from fastapi.testclient import TestClient
from app.main import app  # Assuming FastAPI app in app/main.py

def test_message_api():
    """Test message API endpoints."""

    client = TestClient(app)

    print("\n" + "="*60)
    print("MESSAGE ROUTER API TEST")
    print("="*60)

    # Test health check
    print("\n1ï¸âƒ£ Health Check")
    response = client.get("/api/v1/health")
    print(f"Status: {response.status_code}")
    print(f"Response: {response.json()}")

    # Test message processing
    print("\n2ï¸âƒ£ Process Message")
    response = client.post(
        "/api/v1/messages/process",
        json={
            "message": "What's my account balance?",
            "customer_id": 101,
            "conversation_id": 1,
        }
    )
    print(f"Status: {response.status_code}")
    result = response.json()
    print(f"Response: {result['response'][:100]}...")
    print(f"Agent: {result['metadata']['agent']}")
    print(f"Intent: {result['metadata']['intent']}")

    # Test conversation history
    print("\n3ï¸âƒ£ Get Conversation History")
    response = client.get("/api/v1/conversations/1/history")
    if response.status_code == 200:
        print(f"Status: {response.status_code}")
        data = response.json()
        print(f"Conversation: {data['conversation_id']}")
        print(f"Messages: {len(data['history'])}")

    # Test statistics
    print("\n4ï¸âƒ£ Get Statistics")
    response = client.get("/api/v1/statistics")
    if response.status_code == 200:
        print(f"Status: {response.status_code}")
        stats = response.json()
        print(f"Total Conversations: {stats['total_conversations']}")
        print(f"Total Messages: {stats['total_messages']}")
        print(f"Escalations: {stats['escalated_conversations']}")

if __name__ == "__main__":
    test_message_api()


FILE PATH: ./.env.example
--------------------
# ============================================================================
# APPLICATION SETTINGS
# ============================================================================

APP_NAME=FCA Multi-Agent Support System
APP_VERSION=0.1.0
ENVIRONMENT=development
DEBUG=true

# ============================================================================
# DATABASE CONFIGURATION
# ============================================================================

# PostgreSQL connection string
# Format: postgresql+asyncpg://user:password@host:port/database
DATABASE_URL=postgresql+asyncpg://fca_user:fca_password@localhost:5432/fca_support
DATABASE_ECHO=false

# ============================================================================
# REDIS CONFIGURATION
# ============================================================================

# Redis connection string (for caching in Phase 6)
REDIS_URL=redis://localhost:6379/0
REDIS_ENABLED=false

# ============================================================================
# GROQ AI API CONFIGURATION
# ============================================================================

# Get your API key from: https://console.groq.com
GROQ_API_KEY=your_groq_api_key_here
GROQ_MODEL=mixtral-8x7b-32768
GROQ_TEMPERATURE=0.7
GROQ_MAX_TOKENS=1024
GROQ_TIMEOUT=30

# ============================================================================
# SECURITY
# ============================================================================

# Change this in production! Generate with: openssl rand -hex 32
SECRET_KEY=your-secret-key-change-in-production

# CORS allowed origins (JSON array)
CORS_ORIGINS=["http://localhost:3000","http://localhost:8000"]

# ============================================================================
# RATE LIMITING
# ============================================================================

# Max requests per time period
RATE_LIMIT_CALLS=10
RATE_LIMIT_PERIOD=60

# ============================================================================
# LOGGING
# ============================================================================

# Log levels: DEBUG, INFO, WARNING, ERROR, CRITICAL
LOG_LEVEL=INFO
LOG_FILE=logs/app.log
LOG_FORMAT=json

# ============================================================================
# REQUEST VALIDATION
# ============================================================================

# Max request body size (10 MB in bytes)
MAX_BODY_SIZE=10485760

FILE PATH: ./test general.py
--------------------
"""
Script to verify General Agent DB Connection.
Usage: docker compose exec web python -m app.verify_general_agent
"""
import asyncio
from app.database import AsyncSessionLocal
from app.services.faq_service import FAQService
from app.agents.general_agent import GeneralAgent

async def main():
    print("\n" + "="*60)
    print("ðŸ” VERIFYING GENERAL AGENT (FAQ DB LOOKUP)")
    print("="*60)

    async with AsyncSessionLocal() as session:
        # 1. Initialize Service (Connected to Real DB)
        faq_service = FAQService(db=session)

        # 2. Initialize Agent (With Service Injected)
        # Note: We don't pass 'config' here so it defaults to basic settings
        agent = GeneralAgent(faq_service=faq_service)

        # 3. Test Scenarios
        # These questions match keywords in our seeded DB
        queries = [
            "How do I open an account?",   # Matches category: account
            "Is my money safe?",           # Matches category: security
            "What can I do in the app?",   # Matches category: digital
            "Tell me a joke",              # Should fail DB and fallback to LLM
        ]

        for question in queries:
            print(f"\nâ“ User asks: '{question}'")

            # Run the agent
            response = await agent.process({"message": question})

            # Analyze Result
            source = response.metadata.get("source", "unknown")
            confidence = response.metadata.get("confidence", 0.0)

            print(f"   ðŸ‘‰ Source: {source.upper()}")
            print(f"   ðŸ‘‰ Confidence: {confidence}")
            print(f"   ðŸ‘‰ Answer Preview: {response.content[:80]}...")

            # Validation Logic
            if source == "faq_db":
                print("   âœ… SUCCESS: Fetched from Database")
            elif source == "llm_fallback":
                print("   âš ï¸ NOTE: Fallback to LLM (Expected for non-FAQ queries)")
            else:
                print("   âŒ FAILURE: Unknown source")

if __name__ == "__main__":
    asyncio.run(main())


FILE PATH: ./test_compliance.py
--------------------
import asyncio
from app.agents.compliance_checker import ComplianceCheckerAgent

async def test_compliance():
    # Create agent
    agent = ComplianceCheckerAgent()

    # Test scenarios
    scenarios = [
        {
            "name": "Compliant message",
            "content": "Our Fixed Rate Mortgage offers rates from 3.99% APR. "
                      "Subject to status and affordability assessment.",
            "product_type": "loan",
        },
        {
            "name": "Non-compliant (guaranteed)",
            "content": "Guaranteed returns with zero risk! Can't lose!",
            "product_type": "investment",
        },
        {
            "name": "Missing disclaimer",
            "content": "Apply for a credit card today! Low interest rates.",
            "product_type": "credit",
        },
        {
            "name": "Sensitive topic",
            "content": "If you're struggling with debt, we can help.",
            "product_type": "loan",
        },
    ]

    for scenario in scenarios:
        print(f"\n{'='*60}")
        print(f"Test: {scenario['name']}")
        print(f"{'='*60}")
        print(f"Content: {scenario['content']}")
        print(f"Product Type: {scenario['product_type']}")

        response = await agent.process(
            {"content": scenario["content"]},
            {"product_type": scenario["product_type"]}
        )

        print(f"\nResult:\n{response.content}")
        print(f"\nCompliant: {response.metadata['is_compliant']}")

        if response.metadata['issues']:
            print(f"Issues: {response.metadata['issues']}")

        if response.metadata['required_disclaimers']:
            print(f"Required Disclaimers:")
            for disclaimer in response.metadata['required_disclaimers']:
                print(f"  - {disclaimer}")

if __name__ == "__main__":
    asyncio.run(test_compliance())


FILE PATH: ./test_db_smoke.py
--------------------
import asyncio
from sqlalchemy import select, func

from app.database import AsyncSessionLocal
from app.models.customer import Customer
from app.models.account import Account
from app.models.transaction import Transaction

from app.services.customer import CustomerService
from app.services.account_service import AccountService
from app.services.transaction_service import TransactionService


async def main():
    async with AsyncSessionLocal() as session:
        # --- Raw DB sanity ---
        cust_count = (await session.execute(select(func.count(Customer.id)))).scalar_one()
        acct_count = (await session.execute(select(func.count(Account.id)))).scalar_one()
        txn_count = (await session.execute(select(func.count(Transaction.id)))).scalar_one()
        print("Counts:", {"customers": cust_count, "accounts": acct_count, "transactions": txn_count})

        # pick a real customer id
        customer_id = (await session.execute(select(Customer.id).order_by(Customer.id).limit(1))).scalar_one()
        print("Using customer_id:", customer_id)

        # --- Service sanity ---
        customer_svc = CustomerService(db=session)
        account_svc = AccountService(db=session)
        txn_svc = TransactionService(db=session)

        customer = await customer_svc.get_customer(customer_id)
        print("Customer exists:", bool(customer), "external_customer_id:", getattr(customer, "customer_id", None))

        external_customer_id = getattr(customer, "customer_id", None)
        accounts = await account_svc.get_accounts_by_customer(external_customer_id)
        print("Accounts found:", len(accounts))

        if accounts:
            acct = accounts[0]
            print("First account:", {"id": acct.id, "account_number": acct.account_number, "type": acct.type})

            # NOTE: your TransactionService expects account_id (despite name)
            txns = await txn_svc.get_transactions_by_customer(acct.id, limit=5)
            print("Recent transactions:", len(txns))

if __name__ == "__main__":
    asyncio.run(main())


FILE PATH: ./app/config.py
--------------------
"""
Configuration Management

This module handles all application configuration using Pydantic Settings.
Settings are loaded from environment variables with validation and type checking.
"""

from pydantic_settings import BaseSettings, SettingsConfigDict
from pydantic import Field, field_validator
from typing import List, Literal
import json


class Settings(BaseSettings):
    """
    Application settings loaded from environment variables.

    All settings are loaded from .env file and environment variables.
    Type validation is automatic via Pydantic.
    """

    # ========================================================================
    # APPLICATION SETTINGS
    # ========================================================================

    app_name: str = Field(
        default="FCA Multi-Agent Support System",
        description="Application name",
    )

    app_version: str = Field(
        default="0.1.0",
        description="Application version (semantic versioning)",
    )

    environment: Literal["development", "staging", "production"] = Field(
        default="development",
        description="Current environment",
    )

    debug: bool = Field(
        default=False,
        description="Enable debug mode (detailed errors, API docs)",
    )

    # ========================================================================
    # DATABASE SETTINGS
    # ========================================================================

    database_url: str = Field(
        default="postgresql+asyncpg://fca_user:fca_password@localhost:5432/fca_support",
        description="PostgreSQL connection URL",
    )

    database_echo: bool = Field(
        default=False,
        description="Echo SQL queries to console (debugging)",
    )

    database_pool_size: int = Field(
        default=5,
        ge=1,
        le=20,
        description="Database connection pool size",
    )

    database_max_overflow: int = Field(
        default=10,
        ge=0,
        le=50,
        description="Max connections above pool_size",
    )

    # ========================================================================
    # REDIS SETTINGS
    # ========================================================================

    redis_url: str = Field(
        default="redis://localhost:6379/0",
        description="Redis connection URL",
    )

    redis_enabled: bool = Field(
        default=False,
        description="Enable Redis caching",
    )

    # ========================================================================
    # GROQ AI SETTINGS
    # ========================================================================

    groq_api_key: str = Field(
        default="",
        description="Groq AI API key (required for LLM)",
    )

    groq_model: str = Field(
        default="mixtral-8x7b-32768",
        description="Groq AI model name",
    )

    groq_temperature: float = Field(
        default=0.7,
        ge=0.0,
        le=1.0,
        description="LLM temperature (0=deterministic, 1=creative)",
    )

    groq_max_tokens: int = Field(
        default=1024,
        ge=1,
        le=32768,
        description="Maximum tokens in response",
    )

    groq_timeout: int = Field(
        default=30,
        ge=5,
        le=300,
        description="API request timeout (seconds)",
    )

    # ========================================================================
    # SECURITY SETTINGS
    # ========================================================================

    secret_key: str = Field(
        default="your-secret-key-change-in-production",
        min_length=32,
        description="Secret key for encryption (min 32 chars)",
    )

    cors_origins: List[str] = Field(
        default=["http://localhost:3000", "http://localhost:8000"],
        description="Allowed CORS origins",
    )

    # ========================================================================
    # RATE LIMITING SETTINGS
    # ========================================================================

    rate_limit_calls: int = Field(
        default=10,
        ge=1,
        description="Max requests per period",
    )

    rate_limit_period: int = Field(
        default=60,
        ge=1,
        description="Rate limit period (seconds)",
    )

    # ========================================================================
    # LOGGING SETTINGS
    # ========================================================================

    log_level: Literal["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"] = Field(
        default="INFO",
        description="Minimum log level",
    )

    log_file: str = Field(
        default="logs/app.log",
        description="Log file path",
    )

    log_format: Literal["json", "text"] = Field(
        default="json",
        description="Log output format",
    )

    # ========================================================================
    # REQUEST VALIDATION SETTINGS
    # ========================================================================

    max_body_size: int = Field(
        default=10485760,  # 10 MB
        ge=1024,  # Min 1 KB
        le=52428800,  # Max 50 MB
        description="Maximum request body size (bytes)",
    )

    # ========================================================================
    # PYDANTIC CONFIGURATION
    # ========================================================================

    model_config = SettingsConfigDict(
        env_file=".env",
        env_file_encoding="utf-8",
        case_sensitive=False,  # Environment variables are case-insensitive
        extra="ignore",  # Ignore extra environment variables
    )

    # ========================================================================
    # VALIDATORS
    # ========================================================================

    @field_validator("cors_origins", mode="before")
    @classmethod
    def parse_cors_origins(cls, v):
        """
        Parse CORS origins from JSON string or list.

        Supports both:
        - List: ["http://localhost:3000"]
        - JSON string: '["http://localhost:3000"]'

        Args:
            v: Value to parse

        Returns:
            List[str]: Parsed origins
        """
        if isinstance(v, str):
            try:
                return json.loads(v)
            except json.JSONDecodeError:
                return [v]  # Single origin as string
        return v

    @field_validator("secret_key")
    @classmethod
    def validate_secret_key(cls, v, info):
        """
        Validate secret key in production.

        Ensures secret key is changed from default in production.

        Args:
            v: Secret key value
            info: Validation context

        Returns:
            str: Validated secret key

        Raises:
            ValueError: If using default key in production
        """
        environment = info.data.get("environment", "development")

        if environment == "production" and v == "your-secret-key-change-in-production":
            raise ValueError(
                "CRITICAL SECURITY: Must change SECRET_KEY in production! "
                "Generate with: openssl rand -hex 32"
            )

        return v

    @field_validator("groq_api_key")
    @classmethod
    def validate_groq_key(cls, v, info):
        """
        Warn if Groq API key is missing.

        Note: Doesn't raise error to allow app to start,
        but agents won't work without key.

        Args:
            v: API key value
            info: Validation context

        Returns:
            str: API key
        """
        if not v or v == "":
            print("âš ï¸  WARNING: GROQ_API_KEY not set. AI agents will not function.")
            print("   Get free API key: https://console.groq.com")

        return v

    # ========================================================================
    # COMPUTED PROPERTIES
    # ========================================================================

    @property
    def is_production(self) -> bool:
        """Check if running in production environment."""
        return self.environment == "production"

    @property
    def is_development(self) -> bool:
        """Check if running in development environment."""
        return self.environment == "development"

    @property
    def database_url_sync(self) -> str:
        """
        Get synchronous database URL (for Alembic migrations).

        Alembic doesn't support asyncpg, so replace with psycopg2.

        Returns:
            str: Synchronous PostgreSQL URL
        """
        return self.database_url.replace("+asyncpg", "")

    def get_log_config(self) -> dict:
        """
        Get logging configuration dictionary.

        Returns:
            dict: Python logging configuration
        """
        return {
            "version": 1,
            "disable_existing_loggers": False,
            "formatters": {
                "default": {
                    "format": "%(asctime)s - %(name)s - %(levelname)s - %(message)s",
                },
                "json": {
                    "()": "pythonjsonlogger.jsonlogger.JsonFormatter",
                    "format": "%(asctime)s %(name)s %(levelname)s %(message)s",
                },
            },
            "handlers": {
                "console": {
                    "class": "logging.StreamHandler",
                    "formatter": "default" if self.log_format == "text" else "json",
                    "stream": "ext://sys.stdout",
                },
                "file": {
                    "class": "logging.handlers.RotatingFileHandler",
                    "formatter": "json",
                    "filename": self.log_file,
                    "maxBytes": 10485760,  # 10 MB
                    "backupCount": 5,
                },
            },
            "root": {
                "level": self.log_level,
                "handlers": ["console", "file"],
            },
        }


# ============================================================================
# SETTINGS INSTANCE
# ============================================================================

# Create global settings instance
# Loaded once at import time
settings = Settings()


# ============================================================================
# SETTINGS DISPLAY (for debugging)
# ============================================================================

def display_settings():
    """
    Display current settings (for debugging).

    Masks sensitive values like API keys and passwords.
    """
    print("=" * 60)
    print("APPLICATION SETTINGS")
    print("=" * 60)

    print(f"\nApplication:")
    print(f"  Name: {settings.app_name}")
    print(f"  Version: {settings.app_version}")
    print(f"  Environment: {settings.environment}")
    print(f"  Debug: {settings.debug}")

    print(f"\nDatabase:")
    # Mask password in URL
    db_url = settings.database_url
    if "@" in db_url:
        parts = db_url.split("@")
        credentials = parts[0].split("://")[1]
        user = credentials.split(":")[0]
        db_url = f"postgresql+asyncpg://{user}:****@{parts[1]}"
    print(f"  URL: {db_url}")
    print(f"  Echo: {settings.database_echo}")
    print(f"  Pool Size: {settings.database_pool_size}")

    print(f"\nRedis:")
    print(f"  URL: {settings.redis_url}")
    print(f"  Enabled: {settings.redis_enabled}")

    print(f"\nGroq AI:")
    # Mask API key
    key_display = f"{settings.groq_api_key[:8]}****" if settings.groq_api_key else "NOT SET"
    print(f"  API Key: {key_display}")
    print(f"  Model: {settings.groq_model}")
    print(f"  Temperature: {settings.groq_temperature}")

    print(f"\nSecurity:")
    print(f"  Secret Key: {'SET' if settings.secret_key else 'NOT SET'}")
    print(f"  CORS Origins: {settings.cors_origins}")

    print(f"\nLogging:")
    print(f"  Level: {settings.log_level}")
    print(f"  File: {settings.log_file}")
    print(f"  Format: {settings.log_format}")

    print("=" * 60)


if __name__ == "__main__":
    # Display settings when run directly
    display_settings()


FILE PATH: ./app/database.py
--------------------
"""
Database Connection and Session Management

This module configures SQLAlchemy async engine and provides
database session management for the application.
"""

from sqlalchemy.ext.asyncio import (
    create_async_engine,
    AsyncSession,
    async_sessionmaker,
)
from sqlalchemy.orm import declarative_base
from sqlalchemy.pool import NullPool, QueuePool
from sqlalchemy import  text  # Add 'text' here

from typing import AsyncGenerator
import logging

from app.config import settings

logger = logging.getLogger(__name__)

# ============================================================================
# DATABASE ENGINE
# ============================================================================

# Create async engine
engine = create_async_engine(
    settings.database_url,
    echo=settings.database_echo,  # Log SQL queries (debugging)
    future=True,  # Use SQLAlchemy 2.0 style
    pool_size=settings.database_pool_size,  # Connection pool size
    max_overflow=settings.database_max_overflow,  # Max connections above pool_size
    pool_pre_ping=True,  # Verify connections before using
    pool_recycle=3600,  # Recycle connections after 1 hour
    poolclass=QueuePool if not settings.is_production else QueuePool,
)


# ============================================================================
# SESSION MAKER
# ============================================================================

# Create session factory
AsyncSessionLocal = async_sessionmaker(
    engine,
    class_=AsyncSession,
    expire_on_commit=False,  # Don't expire objects after commit
    autocommit=False,  # Explicit commits only
    autoflush=False,  # Explicit flushes only
)


# ============================================================================
# BASE MODEL
# ============================================================================

# Declarative base for ORM models
Base = declarative_base()


# ============================================================================
# SESSION DEPENDENCY
# ============================================================================

async def get_db() -> AsyncGenerator[AsyncSession, None]:
    """
    Database session dependency for FastAPI.

    Provides a database session for each request and ensures
    proper cleanup after the request completes.

    Yields:
        AsyncSession: Database session

    Example:
        @app.get("/users")
        async def get_users(db: AsyncSession = Depends(get_db)):
            result = await db.execute(select(User))
            return result.scalars().all()
    """
    async with AsyncSessionLocal() as session:
        try:
            yield session
            await session.commit()  # Commit if no exceptions
        except Exception:
            await session.rollback()  # Rollback on error
            raise
        finally:
            await session.close()  # Always close session


# ============================================================================
# DATABASE INITIALIZATION
# ============================================================================

async def init_db() -> None:
    """
    Initialize database tables.

    Creates all tables defined in Base metadata.

    Note: In production, use Alembic migrations instead.
    This is for development/testing only.
    """
    async with engine.begin() as conn:
        # Drop all tables (development only!)
        #if settings.is_development:
        #    logger.warning("Dropping all database tables (development mode)")
        #    await conn.run_sync(Base.metadata.drop_all)

        # Create all tables
        logger.info("Creating database tables")
        await conn.run_sync(Base.metadata.create_all)
        logger.info("Database tables created successfully")


async def close_db() -> None:
    """
    Close database connections.

    Should be called on application shutdown to properly
    close all database connections.
    """
    logger.info("Closing database connections")
    await engine.dispose()
    logger.info("Database connections closed")


# ============================================================================
# DATABASE HEALTH CHECK
# ============================================================================

async def check_db_connection() -> bool:
    """
    Check if database connection is healthy.

    Returns:
        bool: True if connection successful, False otherwise
    """
    try:
        async with AsyncSessionLocal() as session:
            # Simple query to test connection
            await session.execute(text("SELECT 1"))
            return True
    except Exception as e:
        logger.error(f"Database connection check failed: {e}")
        return False


# ============================================================================
# TESTING HELPER
# ============================================================================

if __name__ == "__main__":
    import asyncio

    async def test_connection():
        """Test database connection."""
        print("Testing database connection...")

        # Test connection
        is_healthy = await check_db_connection()

        if is_healthy:
            print("âœ… Database connection successful!")
        else:
            print("âŒ Database connection failed!")

        # Close connections
        await close_db()

    # Run test
    asyncio.run(test_connection())


FILE PATH: ./app/debug_wiring.py
--------------------
"""
DEBUG: Agent Wiring Check
Usage: docker compose exec web python -m app.debug_wiring
"""
import asyncio
from app.database import AsyncSessionLocal
from app.repositories.faq import FAQRepository
from app.services.faq_service import FAQService
from app.agents.general_agent import GeneralAgent

async def main():
    print("\n" + "="*50)
    print("ðŸ”Œ AGENT WIRING DIAGNOSTIC")
    print("="*50)

    async with AsyncSessionLocal() as session:
        # --- LINK 1: THE REPOSITORY ---
        print("\n[1] Testing REPOSITORY Layer...")
        repo = FAQRepository(session)
        # We search for "account" because we know it exists
        repo_results = await repo.search("account")
        if repo_results:
            print(f"    âœ… Repository works! Found {len(repo_results)} matches.")
            print(f"       Sample: {repo_results[0].question}")
        else:
            print("    âŒ Repository returned EMPTY list. (Check DB Seed)")
            return

        # --- LINK 2: THE SERVICE ---
        print("\n[2] Testing SERVICE Layer...")
        # We init service with the SAME session
        service = FAQService(db=session)

        # Check if service actually created the repo
        if hasattr(service, 'repo') and service.repo:
            print("    âœ… Service has initialized Repository.")
        else:
            print("    âŒ Service failed to initialize Repository.")
            return

        # Try searching via service
        service_results = await service.search_faqs("account")
        if service_results:
            print(f"    âœ… Service works! Found {len(service_results)} matches.")
        else:
            print("    âŒ Service returned EMPTY list (but Repo worked?).")
            return

        # --- LINK 3: THE AGENT ---
        print("\n[3] Testing AGENT Layer...")
        # Inject the working service into the agent
        agent = GeneralAgent(faq_service=service)

        # Check if agent received the service
        if agent.faq_service:
            print("    âœ… Agent received FAQService.")
        else:
            print("    âŒ Agent.faq_service is None! Injection failed.")
            return

        # Force the specific lookup method (Bypassing process() to test logic)
        print("    ðŸ‘‰ Testing internal lookup logic...")
        direct_lookup = await agent._lookup_faq_db("How do I open an account?")
        if direct_lookup:
            print("    âœ… Internal Lookup Success!")
        else:
            print("    âŒ Internal Lookup returned None.")

        # Full Process Test
        print("    ðŸ‘‰ Testing full process()...")
        response = await agent.process({"message": "How do I open an account?"})
        print(f"    âœ… Final Output Source: {response.metadata.get('source')}")

if __name__ == "__main__":
    asyncio.run(main())


FILE PATH: ./app/__init__.py
--------------------


FILE PATH: ./app/logger.py
--------------------
"""
Structured Logging Configuration

This module sets up structured logging for the application using
Python's logging module with JSON formatting for production.
"""

import logging
import logging.config
import logging.handlers
import sys
from pathlib import Path
from typing import Optional
import json
from datetime import datetime,timezone

from app.config import settings


# ============================================================================
# JSON FORMATTER (Simple Implementation)
# ============================================================================

class JSONFormatter(logging.Formatter):
    """
    Custom JSON formatter for structured logging.

    Formats log records as JSON objects with consistent structure.
    """

    def format(self, record: logging.LogRecord) -> str:
        """
        Format log record as JSON string.

        Args:
            record: Log record to format

        Returns:
            str: JSON-formatted log message
        """
        log_data = {
            "timestamp": datetime.now(timezone.utc).isoformat().replace("+00:00", "Z"),
            "level": record.levelname,
            "logger": record.name,
            "message": record.getMessage(),
            "module": record.module,
            "function": record.funcName,
            "line": record.lineno,
        }

        # Add exception info if present
        if record.exc_info:
            log_data["exception"] = self.formatException(record.exc_info)

        # Add extra fields if present
        if hasattr(record, "extra"):
            log_data.update(record.extra)

        return json.dumps(log_data)


# ============================================================================
# LOGGING SETUP
# ============================================================================

def setup_logging(
    log_level: Optional[str] = None,
    log_file: Optional[str] = None,
    log_format: Optional[str] = None,
) -> None:
    """
    Configure application logging.

    Sets up console and file handlers with appropriate formatters.
    Uses settings from config if parameters not provided.

    Args:
        log_level: Minimum log level (DEBUG, INFO, WARNING, ERROR, CRITICAL)
        log_file: Path to log file
        log_format: Format type ('json' or 'text')
    """
    # Use settings as defaults
    log_level = log_level or settings.log_level
    log_file = log_file or settings.log_file
    log_format = log_format or settings.log_format

    # Create logs directory if it doesn't exist
    log_path = Path(log_file)
    log_path.parent.mkdir(parents=True, exist_ok=True)

    # ========================================================================
    # FORMATTERS
    # ========================================================================

    # Text formatter (human-readable)
    text_formatter = logging.Formatter(
        fmt="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
        datefmt="%Y-%m-%d %H:%M:%S",
    )

    # JSON formatter (structured)
    json_formatter = JSONFormatter()

    # Choose formatter based on log_format setting
    formatter = json_formatter if log_format == "json" else text_formatter

    # ========================================================================
    # HANDLERS
    # ========================================================================

    # Console handler (stdout)
    console_handler = logging.StreamHandler(sys.stdout)
    console_handler.setLevel(logging.DEBUG)
    console_handler.setFormatter(formatter)

    # File handler (rotating)
    file_handler = logging.handlers.RotatingFileHandler(
        filename=log_file,
        maxBytes=10 * 1024 * 1024,  # 10 MB
        backupCount=5,  # Keep 5 backup files
        encoding="utf-8",
    )
    file_handler.setLevel(logging.DEBUG)
    file_handler.setFormatter(json_formatter)  # Always use JSON for file

    # ========================================================================
    # ROOT LOGGER CONFIGURATION
    # ========================================================================

    # Get root logger
    root_logger = logging.getLogger()
    root_logger.setLevel(log_level)

    # Remove existing handlers
    root_logger.handlers.clear()

    # Add our handlers
    root_logger.addHandler(console_handler)
    root_logger.addHandler(file_handler)

    # ========================================================================
    # THIRD-PARTY LOGGER LEVELS
    # ========================================================================

    # Reduce verbosity of third-party loggers
    logging.getLogger("uvicorn").setLevel(logging.INFO)
    logging.getLogger("uvicorn.access").setLevel(logging.WARNING)
    logging.getLogger("sqlalchemy").setLevel(logging.WARNING)
    logging.getLogger("httpx").setLevel(logging.WARNING)

    # Log initialization
    logger = logging.getLogger(__name__)
    logger.info(
        "Logging configured",
        extra={
            "log_level": log_level,
            "log_file": log_file,
            "log_format": log_format,
        },
    )


# ============================================================================
# LOGGING HELPERS
# ============================================================================

def get_logger(name: str) -> logging.Logger:
    """
    Get a logger instance with the specified name.

    Args:
        name: Logger name (usually __name__)

    Returns:
        logging.Logger: Configured logger instance
    """
    return logging.getLogger(name)


def log_request(
    method: str,
    path: str,
    status_code: int,
    duration_ms: float,
    extra: Optional[dict] = None,
) -> None:
    """
    Log HTTP request with consistent format.

    Args:
        method: HTTP method (GET, POST, etc.)
        path: Request path
        status_code: HTTP status code
        duration_ms: Request duration in milliseconds
        extra: Additional fields to log
    """
    logger = get_logger("app.requests")

    log_data = {
        "method": method,
        "path": path,
        "status_code": status_code,
        "duration_ms": duration_ms,
    }

    if extra:
        log_data.update(extra)

    # Log level based on status code
    if status_code >= 500:
        logger.error(f"{method} {path} - {status_code}", extra=log_data)
    elif status_code >= 400:
        logger.warning(f"{method} {path} - {status_code}", extra=log_data)
    else:
        logger.info(f"{method} {path} - {status_code}", extra=log_data)


def log_agent_action(
    agent_name: str,
    action: str,
    conversation_id: str,
    success: bool,
    duration_ms: float,
    extra: Optional[dict] = None,
) -> None:
    """
    Log agent action with consistent format.

    Args:
        agent_name: Name of the agent
        action: Action performed
        conversation_id: Conversation ID
        success: Whether action succeeded
        duration_ms: Action duration in milliseconds
        extra: Additional fields to log
    """
    logger = get_logger(f"app.agents.{agent_name}")

    log_data = {
        "agent": agent_name,
        "action": action,
        "conversation_id": conversation_id,
        "success": success,
        "duration_ms": duration_ms,
    }

    if extra:
        log_data.update(extra)

    if success:
        logger.info(f"Agent {agent_name} - {action}", extra=log_data)
    else:
        logger.error(f"Agent {agent_name} - {action} FAILED", extra=log_data)


def log_database_query(
    operation: str,
    table: str,
    duration_ms: float,
    rows_affected: int = 0,
    extra: Optional[dict] = None,
) -> None:
    """
    Log database query with consistent format.

    Args:
        operation: Operation type (SELECT, INSERT, UPDATE, DELETE)
        table: Table name
        duration_ms: Query duration in milliseconds
        rows_affected: Number of rows affected
        extra: Additional fields to log
    """
    logger = get_logger("app.database")

    log_data = {
        "operation": operation,
        "table": table,
        "duration_ms": duration_ms,
        "rows_affected": rows_affected,
    }

    if extra:
        log_data.update(extra)

    logger.debug(f"DB {operation} {table}", extra=log_data)


# ============================================================================
# TESTING/DEBUG
# ============================================================================

if __name__ == "__main__":
    # Setup logging
    setup_logging(log_level="DEBUG", log_format="text")

    # Test logging at different levels
    logger = get_logger(__name__)

    logger.debug("This is a DEBUG message")
    logger.info("This is an INFO message")
    logger.warning("This is a WARNING message")
    logger.error("This is an ERROR message")
    logger.critical("This is a CRITICAL message")

    # Test helper functions
    log_request("GET", "/api/v1/health", 200, 15.5)
    log_agent_action("intent_classifier", "classify", "conv-123", True, 50.2)
    log_database_query("SELECT", "customers", 5.3, 1)

    # Test with exception
    try:
        raise ValueError("Test exception")
    except Exception:
        logger.exception("Exception occurred")

    print("\nâœ… Logging test complete. Check logs/app.log")


FILE PATH: ./app/verify_full_workflow.py
--------------------
"""
VERIFY FULL WORKFLOW
Tests the complete chain: Coordinator -> Workflow -> Agents -> DB
"""
import asyncio
import os
import logging
from app.coordinator.agent_coordinator import AgentCoordinator

# Configure Logging to see the "Inside Logic"
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("workflow_test")

async def main():
    print("\n" + "="*60)
    print("ðŸš¦ FULL SYSTEM WORKFLOW TEST")
    print("="*60)

    # 1. Initialize Coordinator
    # Note: Coordinator inits its own DB session per request, so we don't need one here.
    coordinator = AgentCoordinator()

    # 2. Define Test Scenarios
    scenarios = [
        {
            "name": "General Inquiry (FAQ)",
            "message": "How do I open an account?",
            "expected_agent": "general",
            "check": lambda res: res['intent'] == "general_inquiry"
        },
        {
            "name": "Product Inquiry (DB Read)",
            "message": "I want a personal loan",
            "expected_agent": "product",
            "check": lambda res: "loan" in str(res['response']).lower()
        },
        {
            "name": "Complaint (Escalation)",
            "message": "I want to file a complaint about a stolen card",
            "expected_agent": "human",
            "check": lambda res: res['escalated'] is True
        },
        {
            "name": "Account Inquiry (DB Read)",
            "message": "What is my account balance?",
            "expected_agent": "account",
            # We assume customer_id=1 has an account from the seed
            "check": lambda res: "balance" in str(res['response']).lower()
        }
    ]

    # 3. Run Tests
    customer_id = 1
    conversation_id = 100

    for i, test in enumerate(scenarios, 1):
        print(f"\nðŸ“ [Test {i}] {test['name']}")
        print(f"   ðŸ‘¤ User: '{test['message']}'")

        try:
            result = await coordinator.process_message(
                message=test['message'],
                customer_id=customer_id,
                conversation_id=conversation_id
            )

            agent_used = result["agent"]
            response_text = result["response"]

            print(f"   ðŸ¤– Agent Used: {agent_used}")
            print(f"   ðŸ“„ Response: {response_text[:80]}...")

            # Validation
            if agent_used == test["expected_agent"]:
                if test["check"](result):
                    print("   âœ… PASS: Routing & Logic Correct")
                else:
                    print("   âš ï¸  PARTIAL PASS: Agent correct, but check logic failed.")
            else:
                print(f"   âŒ FAIL: Routed to {agent_used}, expected {test['expected_agent']}")

        except Exception as e:
            print(f"   âŒ CRASH: {e}")
            import traceback
            traceback.print_exc()

if __name__ == "__main__":
    asyncio.run(main())


FILE PATH: ./app/seed.py
--------------------
"""
Database Seeding Script

Populates database with sample data for development and testing.
"""

import asyncio
import logging
from datetime import datetime
from sqlalchemy import text  # <--- Added import

from app.database import AsyncSessionLocal
from app.services.customer import CustomerService
from app.services.conversation import ConversationService
from app.services.message import MessageService
from app.models.conversation import ConversationChannel, ConversationStatus
from app.models.message import MessageRole

# Setup logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# ============================================================================
# SAMPLE DATA
# ============================================================================

SAMPLE_CUSTOMERS = [
    {
        "customer_id": "CUST-001",
        "first_name": "John",
        "last_name": "Smith",
        "email": "john.smith@example.com",
        "phone": "+44123456789",
        "is_vip": True,
    },
    {
        "customer_id": "CUST-002",
        "first_name": "Jane",
        "last_name": "Doe",
        "email": "jane.doe@example.com",
        "phone": "+44987654321",
        "is_vip": False,
    },
    {
        "customer_id": "CUST-003",
        "first_name": "Robert",
        "last_name": "Johnson",
        "email": "robert.johnson@example.com",
        "phone": "+44111222333",
        "is_vip": True,
    },
]

SAMPLE_CONVERSATIONS = [
    {
        "title": "Mortgage Application Inquiry",
        "channel": ConversationChannel.WEB,
        "intent": "loan_inquiry",
    },
    {
        "title": "Account Balance Question",
        "channel": ConversationChannel.MOBILE,
        "intent": "account_balance",
    },
    {
        "title": "Credit Card Application",
        "channel": ConversationChannel.WEB,
        "intent": "credit_card",
    },
]

SAMPLE_MESSAGES = [
    # Conversation 1 messages
    [
        {
            "role": MessageRole.CUSTOMER,
            "content": "I'm interested in applying for a mortgage. What are the requirements?",
            "intent": "loan_inquiry",
            "sentiment": "neutral",
            "confidence_score": 95,
        },
        {
            "role": MessageRole.AGENT,
            "content": "I'd be happy to help you with your mortgage inquiry. Let me provide you with the key requirements...",
            "agent_name": "product_recommender",
        },
        {
            "role": MessageRole.CUSTOMER,
            "content": "What interest rates do you currently offer?",
            "intent": "loan_inquiry",
            "sentiment": "positive",
            "confidence_score": 92,
        },
    ],
    # Conversation 2 messages
    [
        {
            "role": MessageRole.CUSTOMER,
            "content": "What is my current account balance?",
            "intent": "account_balance",
            "sentiment": "neutral",
            "confidence_score": 98,
        },
        {
            "role": MessageRole.AGENT,
            "content": "I can help you check your account balance. Let me retrieve that information...",
            "agent_name": "account_agent",
        },
    ],
]

# ============================================================================
# SEEDING FUNCTIONS
# ============================================================================

async def seed_customers() -> list:
    """
    Seed sample customers.

    Returns:
        list: Created customer IDs
    """
    logger.info("Seeding customers...")

    customer_ids = []

    async with CustomerService() as service:
        for data in SAMPLE_CUSTOMERS:
            try:
                customer = await service.create_customer(**data)
                customer_ids.append(customer.id)
                logger.info(f"Created customer: {customer.full_name} ({customer.email})")
            except ValueError as e:
                logger.warning(f"Skipped customer {data['email']}: {e}")

    logger.info(f"Seeded {len(customer_ids)} customers")
    return customer_ids

async def seed_conversations(customer_ids: list) -> list:
    """
    Seed sample conversations.

    Args:
        customer_ids: List of customer IDs

    Returns:
        list: Created conversation IDs
    """
    logger.info("Seeding conversations...")

    conversation_ids = []

    async with ConversationService() as service:
        for i, data in enumerate(SAMPLE_CONVERSATIONS):
            # Assign to customers in round-robin fashion
            customer_id = customer_ids[i % len(customer_ids)]

            conversation = await service.start_conversation(
                customer_id=customer_id,
                title=data["title"],
                channel=data["channel"]
            )

            # Update intent if provided
            if "intent" in data:
                async with AsyncSessionLocal() as session:
                    conv = await session.get(type(conversation), conversation.id)
                    conv.intent = data["intent"]
                    await session.commit()

            conversation_ids.append(conversation.id)
            logger.info(f"Created conversation: {conversation.title}")

    logger.info(f"Seeded {len(conversation_ids)} conversations")
    return conversation_ids

async def seed_messages(conversation_ids: list):
    """
    Seed sample messages.

    Args:
        conversation_ids: List of conversation IDs
    """
    logger.info("Seeding messages...")

    message_count = 0

    async with MessageService() as service:
        for i, messages in enumerate(SAMPLE_MESSAGES):
            if i >= len(conversation_ids):
                break

            conversation_id = conversation_ids[i]

            for msg_data in messages:
                message = await service.add_message(
                    conversation_id=conversation_id,
                    **msg_data
                )
                message_count += 1
                logger.info(f"Created message: {msg_data['role'].value} - {msg_data['content'][:50]}...")

    logger.info(f"Seeded {message_count} messages")

async def clear_database():
    """
    Clear all data from database.

    WARNING: This will delete ALL data!
    """
    logger.warning("Clearing database...")

    async with AsyncSessionLocal() as session:
        # Delete in reverse order of foreign keys
        # Wraps SQL strings in text() to avoid SQLAlchemy errors
        await session.execute(text("DELETE FROM messages"))
        await session.execute(text("DELETE FROM conversations"))
        await session.execute(text("DELETE FROM customers"))
        await session.commit()

    logger.info("Database cleared")

# ============================================================================
# MAIN SEEDING FUNCTION
# ============================================================================

async def seed_all(clear_first: bool = False):
    """
    Seed all sample data.

    Args:
        clear_first: Whether to clear existing data first
    """
    try:
        if clear_first:
            await clear_database()

        logger.info("Starting database seeding...")

        # Seed in order of dependencies
        customer_ids = await seed_customers()
        conversation_ids = await seed_conversations(customer_ids)
        await seed_messages(conversation_ids)

        logger.info("âœ… Database seeding completed successfully!")

    except Exception as e:
        logger.error(f"âŒ Error seeding database: {e}", exc_info=True)
        raise

# ============================================================================
# CLI ENTRY POINT
# ============================================================================

if __name__ == "__main__":
    import sys

    # Check for --clear flag
    clear_first = "--clear" in sys.argv

    # Run seeding
    asyncio.run(seed_all(clear_first=clear_first))


FILE PATH: ./app/main.py
--------------------
"""
FastAPI Application Entry Point

This module initializes the FastAPI application, configures middleware,
registers routers, and sets up CORS policies.
"""
from contextlib import asynccontextmanager
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi.middleware.gzip import GZipMiddleware
from fastapi.responses import JSONResponse
import logging

# Import configuration and utilities
from app.config import settings
from app.logger import setup_logging
from app.database import init_db, close_db
from app.api.routes.messages import router as messages_router
from app.routers.admin import router as admin_router


# Import routers
from app.routers import health

# Setup logging
setup_logging()
logger = logging.getLogger(__name__)



@asynccontextmanager
async def lifespan(app: FastAPI):
    """
    Manage application lifespan (startup and shutdown).

    Startup:
    - Initialize logging
    - Initialize database tables (development only)
    - Log startup information

    Shutdown:
    - Close database connections
    - Cleanup resources
    - Log shutdown
    """
    # ========== STARTUP ==========
    logger.info(f"Starting {settings.app_name} v{settings.app_version}")
    logger.info(f"Environment: {settings.environment}")
    logger.info(f"Debug mode: {settings.debug}")

    # Initialize database (development only)
    if settings.is_development:
        logger.info("Initializing database tables (development mode)")
        try:
            await init_db()
        except Exception as e:
            logger.error(f"Database initialization failed: {e}", exc_info=True)

    logger.info("Application startup complete")

    yield  # Application runs here

    # ========== SHUTDOWN ==========
    logger.info("Shutting down application")

    # Close database connections
    try:
        await close_db()
    except Exception as e:
        logger.error(f"Error closing database: {e}", exc_info=True)

    logger.info("Application shutdown complete")


# ============================================================================
# APPLICATION FACTORY
# ============================================================================


def create_application() -> FastAPI:
    """
    Create and configure FastAPI application instance.

    Returns:
        FastAPI: Configured application instance
    """

    # Create FastAPI instance
    app = FastAPI(
        title=settings.app_name,
        version=settings.app_version,
        description="FCA-compliant multi-agent AI support system for UK financial services",
        docs_url="/docs" if settings.debug else None,  # Disable docs in production
        redoc_url="/redoc" if settings.debug else None,
        openapi_url="/openapi.json" if settings.debug else None,
        lifespan=lifespan,
        # Metadata for OpenAPI schema
        contact={
            "name": "David Sandeep",
            "email": "davidsandeep1996@gmail.com",
        },
        license_info={
            "name": "MIT",
            "url": "https://opensource.org/licenses/MIT",
        },
    )

    # ========================================================================
    # MIDDLEWARE CONFIGURATION
    # ========================================================================

    # CORS Middleware - Allow cross-origin requests
    app.add_middleware(
        CORSMiddleware,
        allow_origins=settings.cors_origins,
        allow_credentials=True,
        allow_methods=["*"],  # Allow all HTTP methods
        allow_headers=["*"],  # Allow all headers
    )

    # GZip Middleware - Compress responses
    app.add_middleware(
        GZipMiddleware,
        minimum_size=1000,  # Only compress responses > 1KB
    )




    # ========================================================================
    # EXCEPTION HANDLERS
    # ========================================================================

    @app.exception_handler(Exception)
    async def global_exception_handler(request, exc):
        """
        Global exception handler for unhandled errors.

        Args:
            request: FastAPI request object
            exc: Exception that was raised

        Returns:
            JSONResponse with error details
        """
        logger.error(f"Unhandled exception: {exc}", exc_info=True)

        return JSONResponse(
            status_code=500,
            content={
                "error": "Internal Server Error",
                "message": str(exc) if settings.debug else "An unexpected error occurred",
            },
        )

    # ========================================================================
    # ROUTERS
    # ========================================================================

    # Root endpoint
    @app.get("/", tags=["Root"])
    async def root():
        """
        Root endpoint - API information.

        Returns:
            dict: API metadata
        """
        return {
            "name": settings.app_name,
            "version": settings.app_version,
            "status": "operational",
            "environment": settings.environment,
            "docs": "/docs" if settings.debug else "disabled",
        }

    # Register routers
    app.include_router(
        health.router,
        prefix="/api/v1",
        tags=["Health"],
    )

    app.include_router(messages_router)
    app.include_router(admin_router)


    return app


# ============================================================================
# APPLICATION INSTANCE
# ============================================================================

# Create application instance
app = create_application()


# ============================================================================
# MAIN ENTRY POINT (for direct execution)
# ============================================================================

if __name__ == "__main__":
    import uvicorn

    # Run with uvicorn (development only)
    uvicorn.run(
        "app.main:app",
        host="0.0.0.0",
        port=8000,
        reload=True,  # Auto-reload on code changes
        log_level="info",
    )


FILE PATH: ./app/seed_database.py
--------------------
"""
Database Seeding Script - 1000+ Realistic Records with Auto-Table Creation

Populates database with large-scale sample data for development and testing.

Features:
- Auto-creates all tables (idempotent, safe to run multiple times)
- Generates realistic UK customer data via Faker
- Seeds products, accounts, transactions, conversations, and messages
- Optional data clearing (--clear flag)
- Configurable scale (--customers N)
- Expected vs Actual report (variance + success rate)
- FIXED: Proper transaction handling without savepoints
- FIXED: datetime.utcnow() deprecation warning resolved
- FIXED: Better error reporting with full exception details
"""

import asyncio
import logging
from datetime import datetime, timedelta, timezone
from decimal import Decimal

from faker import Faker
from sqlalchemy import text

from app.database import AsyncSessionLocal, engine, Base
from sqlalchemy import delete
from sqlalchemy.ext.asyncio import AsyncSession
from app.services.customer import CustomerService
from app.services.conversation import ConversationService
from app.services.message import MessageService
from app.services import ProductService, AccountService, TransactionService
from app.models.conversation import ConversationChannel
from app.models.message import MessageRole
from app.models.faq import FAQ
from app.models.account import AccountType, AccountStatus


# =============================================================================
# Logging + Faker
# =============================================================================
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)
fake = Faker("en_GB")


# =============================================================================
# Table creation
# =============================================================================
async def create_all_tables() -> None:
    """Create all database tables if they don't exist (idempotent)."""
    logger.info("ðŸ”§ Checking/Creating database tables...")
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)
    logger.info("âœ… All tables created/verified successfully\n")


# =============================================================================
# Data generation
# =============================================================================
def generate_customers(count: int = 100) -> list[dict]:
    customers: list[dict] = []
    for i in range(1, count + 1):
        customers.append(
            {
                "customer_id": f"CUST-{i:06d}",
                "first_name": fake.first_name(),
                "last_name": fake.last_name(),
                "email": fake.unique.email(),
                "phone": fake.phone_number(),
                "is_vip": fake.random_element([True, False, False, False]),  # ~25% VIP
            }
        )
    return customers


# app/seed_database.py

from decimal import Decimal

SAMPLE_PRODUCTS = [
    # --- MORTGAGES ---
    {
        "name": "Fixed Rate Mortgage",
        "type": "loan",  # DB uses generic 'loan' type or you can add 'mortgage' to Enum
        "description": "Interest rate stays the same for agreed period",
        "interest_rate": Decimal("3.99"),
        "features": ["2, 3, 5, or 10 year fixed terms", "Suitable for first time buyers", "Stability"],
        "requirements": {"min_deposit": 0.05, "min_income": 25000},
        "is_active": True,
    },
    {
        "name": "Tracker Mortgage",
        "type": "loan",
        "description": "Interest rate tracks Bank of England base rate (Base + 1.5%)",
        "interest_rate": Decimal("5.50"),  # Approx 4.0 base + 1.5
        "features": ["Flexible terms", "Tracks base rate", "Lower early repayment charges"],
        "requirements": {"min_deposit": 0.10},
        "is_active": True,
    },

    # --- SAVINGS ---
    {
        "name": "Instant Access Savings",
        "type": "savings",
        "description": "Access your money anytime without penalties",
        "interest_rate": Decimal("4.25"),
        "features": ["No fixed term", "Withdraw anytime", "Interest paid monthly"],
        "requirements": {"min_balance": 1},
        "is_active": True,
    },
    {
        "name": "Fixed Rate Bond",
        "type": "savings",
        "description": "Fixed interest rate for set period (1-5 years)",
        "interest_rate": Decimal("5.10"),
        "features": ["Guaranteed return", "Higher interest rate", "Funds locked for term"],
        "requirements": {"min_balance": 1000},
        "is_active": True,
    },

    # --- CREDIT CARDS ---
    {
        "name": "Cashback Credit Card",
        "type": "credit",
        "description": "Earn cashback on everyday purchases",
        "interest_rate": Decimal("21.9"),  # APR
        "features": ["Up to 1% cashback", "No annual fee", "Fraud protection"],
        "requirements": {"min_income": 20000},
        "is_active": True,
    },
    {
        "name": "Balance Transfer Card",
        "type": "credit",
        "description": "0% interest on transferred balances for 24 months",
        "interest_rate": Decimal("0.0"),  # Promotional rate
        "features": ["0% for 24 months", "3% transfer fee", "Debt consolidation tool"],
        "requirements": {"credit_score": 700},
        "is_active": True,
    },

    # --- LOANS ---
    {
        "name": "Personal Loan",
        "type": "loan",
        "description": "Unsecured loan for any purpose",
        "interest_rate": Decimal("6.9"),
        "features": ["Borrow Â£1k - Â£35k", "Terms 1-7 years", "Instant decision"],
        "requirements": {"min_income": 20000},
        "is_active": True,
    },

    # --- CURRENT ACCOUNTS (Keep this from original seed) ---
    {
        "name": "Current Account",
        "type": "current",
        "description": "Everyday banking made easy",
        "interest_rate": Decimal("0.00"),
        "features": ["Debit card", "Online banking", "Direct deposits"],
        "requirements": {"age": 16},
        "is_active": True,
    },
]

SAMPLE_FAQS = [
    {
        "question": "How do I open an account?",
        "answer": (
            "To open an account with us:\n"
            "1. Visit our website or mobile app\n"
            "2. Click 'Open Account'\n"
            "3. Provide personal information\n"
            "4. Verify your identity\n"
            "5. Fund your account\n\n"
            "The process takes about 10 minutes."
        ),
        "category": "account",
        "keywords": "open, join, register, new account"
    },
    {
        "question": "How do I contact support?",
        "answer": (
            "You can contact our support team at:\n"
            "ðŸ“ž Phone: +44-20-XXXX-XXXX\n"
            "ðŸ“§ Email: support@fca-bank.com\n"
            "ðŸ’¬ Live Chat: Available 9am-6pm weekdays\n"
            "ðŸ• Hours: Monday-Friday, 9am-6pm GMT\n\n"
            "Our team typically responds within 24 hours."
        ),
        "category": "support",
        "keywords": "phone, email, chat, help, contact"
    },
    {
        "question": "What are your account fees?",
        "answer": (
            "We offer fee-free banking:\n"
            "âœ… No monthly account fees\n"
            "âœ… No transfer fees (domestic)\n"
            "âœ… No ATM fees at partner ATMs\n"
            "âš ï¸ International transfers: Â£10 + exchange rate\n"
            "âš ï¸ Overdraft charges apply\n\n"
            "See our full fee schedule at bank.com/fees"
        ),
        "category": "fees",
        "keywords": "cost, charge, free, overdraft, transfer fee"
    },
    {
        "question": "What interest rates do you offer?",
        "answer": (
            "Current Interest Rates:\n"
            "ðŸ’° Savings Account: Up to 4.5% AER\n"
            "ðŸ’° Fixed Bond 1-year: 5.1% AER\n"
            "ðŸ’° Fixed Bond 3-year: 4.8% AER\n"
            "ðŸ’³ Credit Cards: 21.9% APR (representative)\n"
            "ðŸ“Œ Mortgage: From 3.99% APR\n\n"
            "Rates subject to change. See full rates at bank.com/rates"
        ),
        "category": "products",
        "keywords": "rate, interest, apr, aer, mortgage rate"
    },
    {
        "question": "Is my money safe with you?",
        "answer": (
            "Your money is protected:\n"
            "ðŸ”’ FSCS Protected: Up to Â£85,000\n"
            "ðŸ” 256-bit Encryption\n"
            "ðŸ›¡ï¸ Multi-factor Authentication\n"
            "ðŸ“‹ FCA Regulated\n"
            "ðŸ” Regular Security Audits\n\n"
            "We take security seriously."
        ),
        "category": "security",
        "keywords": "safe, secure, fraud, protection, fscs"
    },
    {
        "question": "What can I do in the mobile app?",
        "answer": (
            "Available features:\n"
            "âœ… Check balance and transactions\n"
            "âœ… Transfer money\n"
            "âœ… Pay bills\n"
            "âœ… Apply for products\n"
            "âœ… Contact support\n"
            "âœ… View statements\n"
            "âœ… Manage cards\n\n"
            "Download from App Store or Google Play"
        ),
        "category": "digital",
        "keywords": "app, mobile, features, download, phone"
    },
]

REALISTIC_MERCHANTS = [
    "Tesco", "Sainsbury's", "Asda", "Morrisons", "Waitrose", "Co-op",
    "Lidl", "Aldi", "Iceland", "Marks & Spencer", "Starbucks", "Costa Coffee",
    "Pret A Manger", "Greggs", "McDonald's", "Subway", "Pizza Hut", "KFC",
    "Nando's", "Wagamama", "Netflix", "Spotify", "Amazon", "eBay",
    "Argos", "John Lewis", "Boots", "Uber",
]

TRANSACTION_CATEGORIES = [
    "groceries", "dining", "entertainment", "transport", "utilities", "shopping",
    "subscriptions", "travel", "health", "fitness", "education", "bills",
    "insurance", "fuel", "phone", "internet",
]

SAMPLE_CONVERSATIONS = [
    {"title": "Mortgage Application Inquiry", "channel": ConversationChannel.WEB, "intent": "loan_inquiry"},
    {"title": "Account Balance Question", "channel": ConversationChannel.MOBILE, "intent": "account_balance"},
    {"title": "Credit Card Application", "channel": ConversationChannel.WEB, "intent": "credit_card"},
]


# =============================================================================
# Seeding functions
# =============================================================================
async def seed_customers(count: int = 100) -> list[int]:
    logger.info(f"ðŸŒ± Seeding {count} customers...")
    customer_ids: list[int] = []
    customers_data = generate_customers(count)
    customers_failed = 0

    async with CustomerService() as service:
        for i, data in enumerate(customers_data, start=1):
            try:
                customer = await service.create_customer(**data)
                customer_ids.append(customer.id)
                if i % 10 == 0:
                    logger.info(f"  âœ… Created {i}/{count} customers")
            except Exception as e:
                customers_failed += 1
                await service.rollback()
                logger.debug(f"âš ï¸  Skipped customer {data.get('email')}: {str(e)[:200]}")

        await service.commit()

    logger.info(f"ðŸ“Š Seeded {len(customer_ids)}/{count} customers ({customers_failed} failed)\n")
    return customer_ids

async def seed_faqs(session: AsyncSession):
    """Seed FAQ data."""
    logger.info("ðŸŒ± Seeding FAQs...")
    # Delete existing
    await session.execute(delete(FAQ))

    for f_data in SAMPLE_FAQS:
        faq = FAQ(**f_data)
        session.add(faq)

    await session.commit()
    logger.info(f"âœ… Seeded {len(SAMPLE_FAQS)} FAQs")


async def seed_products() -> list[int]:
    """Seed products and COMMIT each individually (FK requirement for accounts)."""
    logger.info("ðŸŒ± Seeding products...")
    product_ids: list[int] = []
    products_failed = 0

    for data in SAMPLE_PRODUCTS:
        async with ProductService() as service:
            try:
                product = await service.repo.create(data)
                await service.commit()  # Commit EACH product individually
                product_ids.append(product.id)
                logger.info(f"âœ… Created product: {product.name} ({product.type}) id={product.id}")
            except Exception as e:
                products_failed += 1
                try:
                    await service.rollback()
                except Exception:
                    pass
                logger.warning(f"âš ï¸  Skipped product {data.get('name')}: {str(e)[:200]}")

    logger.info(f"ðŸ” {len(product_ids)}/{len(SAMPLE_PRODUCTS)} Products COMMITTED - safe for FK references ({products_failed} failed)\n")
    return product_ids


async def seed_accounts(customer_ids: list[int], product_ids: list[int]) -> list[int]:
    logger.info("ðŸŒ± Seeding accounts (2-3 per customer)...")

    if not product_ids:
        raise RuntimeError("âŒ No products were created; cannot seed accounts safely.")

    logger.info(f"   Available product IDs: {product_ids}\n")

    account_ids: list[int] = []
    account_types = [AccountType.CURRENT, AccountType.SAVINGS, AccountType.CREDIT]
    accounts_failed = 0

    for idx, customer_id in enumerate(customer_ids):
        async with AccountService() as service:
            try:
                async with AsyncSessionLocal() as session:
                    from app.models.customer import Customer

                    customer = await session.get(Customer, customer_id)
                    ext_customer_id = customer.customer_id if customer else f"CUST-{idx+1:06d}"

                num_accounts = 2 + (idx % 2)  # 2 or 3 accounts
                for j in range(num_accounts):
                    try:
                        product_id = product_ids[j % len(product_ids)]
                        account_type = account_types[j % len(account_types)]

                        account_data = {
                            "account_number": f"ACC{ext_customer_id}{j:02d}",
                            "customer_id": ext_customer_id,
                            "product_id": product_id,
                            "type": account_type,
                            "status": AccountStatus.ACTIVE,
                            "currency": "GBP",
                            "balance": Decimal(str(fake.random_int(1000, 500000))),
                            "available_balance": Decimal(str(fake.random_int(500, 500000))),
                        }

                        account = await service.repo.create(account_data)
                        account_ids.append(account.id)
                    except Exception as e:
                        accounts_failed += 1
                        logger.debug(f"âš ï¸  Skipped account {ext_customer_id}:{j}: {str(e)[:200]}")
                        continue

                await service.commit()

            except Exception as e:
                logger.debug(f"âš ï¸  Customer {idx} batch error: {str(e)[:200]}")
                try:
                    await service.rollback()
                except Exception:
                    pass
                continue

            if (idx + 1) % 20 == 0:
                logger.info(f"  âœ… Created {len(account_ids)} accounts for {idx + 1}/{len(customer_ids)} customers ({accounts_failed} failed)")

    logger.info(f"ðŸ“Š Seeded {len(account_ids)} accounts ({accounts_failed} failed)\n")
    return account_ids


async def seed_transactions(account_ids: list[int]) -> int:
    logger.info("ðŸŒ± Seeding transactions (10-20 per account)...")
    logger.info(f"   This will create ~{len(account_ids) * 15:,} transactions...\n")

    transaction_count = 0
    transactions_failed = 0
    first_error_logged = 0

    for acc_idx, account_id in enumerate(account_ids, start=1):
        # FIXED: Create fresh service per account to avoid session issues
        async with TransactionService() as service:
            num_transactions = fake.random_int(10, 20)

            for i in range(num_transactions):
                try:
                    days_ago = fake.random_int(1, 90)
                    # FIXED: Use naive UTC datetime instead of deprecated utcnow()
                    trans_date = datetime.now(timezone.utc).replace(tzinfo=None) - timedelta(days=days_ago)

                    transaction_data = {
                        "account_id": account_id,
                        "reference": f"TXN-{account_id}-{i:04d}",
                        "amount": Decimal(str(fake.random_int(10, 50000) / 100)),
                        "currency": "GBP",
                        "description": fake.sentence(nb_words=4),
                        "category": fake.random_element(TRANSACTION_CATEGORIES),
                        "date": trans_date,
                        "merchant_name": fake.random_element(REALISTIC_MERCHANTS),
                    }

                    # FIXED: Create directly without nested savepoint
                    await service.repo.create(transaction_data)
                    transaction_count += 1

                except Exception as e:
                    transactions_failed += 1
                    # FIXED: Rollback after error to reset session state
                    try:
                        await service.rollback()
                    except Exception:
                        pass

                    # Print detailed error for first few failures
                    if first_error_logged < 5:
                        logger.warning(
                            f"âŒ Transaction failed (account_id={account_id}, i={i}): {type(e).__name__}: {str(e)}"
                        )
                        first_error_logged += 1
                    continue

            # Commit all successful transactions for this account
            try:
                await service.commit()
            except Exception as e:
                logger.warning(f"âŒ Account {account_id} commit failed: {type(e).__name__}: {str(e)}")
                try:
                    await service.rollback()
                except Exception:
                    pass

            if acc_idx % 50 == 0:
                logger.info(f"  âœ… Created {transaction_count:,} transactions for {acc_idx}/{len(account_ids)} accounts ({transactions_failed} failed)")

    logger.info(f"ðŸ“Š Seeded {transaction_count:,} transactions ({transactions_failed} failed)\n")
    return transaction_count


async def seed_conversations(customer_ids: list[int]) -> list[int]:
    logger.info("ðŸŒ± Seeding conversations...")
    conversation_ids: list[int] = []
    conversations_failed = 0

    async with ConversationService() as service:
        for i, data in enumerate(SAMPLE_CONVERSATIONS):
            customer_id = customer_ids[i % len(customer_ids)]
            try:
                conversation = await service.start_conversation(
                    customer_id=customer_id,
                    title=data["title"],
                    channel=data["channel"],
                )
                conversation_ids.append(conversation.id)
                logger.info(f"âœ… Created conversation: {conversation.title}")
            except Exception as e:
                conversations_failed += 1
                await service.rollback()
                logger.warning(f"âš ï¸  Skipped conversation: {str(e)[:200]}")

        await service.commit()

    logger.info(f"ðŸ“Š Seeded {len(conversation_ids)}/{len(SAMPLE_CONVERSATIONS)} conversations ({conversations_failed} failed)\n")
    return conversation_ids


async def seed_messages(conversation_ids: list[int]) -> int:
    logger.info("ðŸŒ± Seeding messages...")

    sample_messages = [
        {
            "role": MessageRole.CUSTOMER,
            "content": "I'm interested in applying for a mortgage. What are the requirements?",
            "intent": "loan_inquiry",
        },
        {
            "role": MessageRole.AGENT,
            "content": "I'd be happy to help you with your mortgage inquiry. Let me provide key requirements...",
            "agent_name": "product_recommender",
        },
        {
            "role": MessageRole.CUSTOMER,
            "content": "What is my current account balance?",
            "intent": "account_balance",
        },
        {
            "role": MessageRole.AGENT,
            "content": "Let me retrieve your current account balance from our system...",
            "agent_name": "account_agent",
        },
    ]

    message_count = 0
    messages_failed = 0

    async with MessageService() as service:
        for i, conversation_id in enumerate(conversation_ids):
            for msg_data in sample_messages[i : i + 2]:
                try:
                    await service.add_message(conversation_id=conversation_id, **msg_data)
                    message_count += 1
                except Exception as e:
                    messages_failed += 1
                    logger.debug(f"âš ï¸  Skipped message: {str(e)[:200]}")

        await service.commit()

    logger.info(f"ðŸ“Š Seeded {message_count} messages ({messages_failed} failed)\n")
    return message_count


async def clear_database() -> None:
    logger.warning("ðŸ—‘ï¸  CLEARING DATABASE - ALL DATA WILL BE DELETED!")
    logger.warning("   âš ï¸  Tables will remain, only data is cleared\n")

    async with AsyncSessionLocal() as session:
        await session.execute(text("DELETE FROM transactions"))
        await session.execute(text("DELETE FROM accounts"))
        await session.execute(text("DELETE FROM products"))
        await session.execute(text("DELETE FROM messages"))
        await session.execute(text("DELETE FROM conversations"))
        await session.execute(text("DELETE FROM customers"))
        await session.commit()

    logger.info("âœ… Database cleared (tables preserved)\n")


# =============================================================================
# Main seeding function + report
# =============================================================================
async def seed_all(clear_first: bool = False, customer_count: int = 100) -> None:
    try:
        logger.info("=" * 70)
        logger.info("ðŸŒ± STARTING DATABASE SEEDING (1000+ RECORDS)")
        logger.info("=" * 70 + "\n")

        logger.info("STEP 1/3: CREATE/VERIFY TABLES")
        logger.info("-" * 70)
        await create_all_tables()

        if clear_first:
            logger.info("STEP 2/3: CLEAR EXISTING DATA (--clear flag used)")
            logger.info("-" * 70)
            await clear_database()
        else:
            logger.info("STEP 2/3: SKIP DATA CLEAR (appending to existing data)")
            logger.info("-" * 70 + "\n")

        logger.info("STEP 3/3: SEED NEW DATA")
        logger.info("-" * 70 + "\n")

        customer_ids = await seed_customers(customer_count)
        product_ids = await seed_products()
        account_ids = await seed_accounts(customer_ids, product_ids)
        trans_count = await seed_transactions(account_ids)
        conv_ids = await seed_conversations(customer_ids)
        message_count = await seed_messages(conv_ids)
        async with AsyncSessionLocal() as session:
            await seed_faqs(session)

        logger.info("=" * 70)
        logger.info("âœ… DATABASE SEEDING COMPLETED SUCCESSFULLY!")
        logger.info("=" * 70 + "\n")

        expected_products = 5
        expected_accounts_per_customer = 2.5
        expected_transactions_per_account = 15
        expected_conversations = 3
        expected_messages_per_conversation = 2

        expected_customers = customer_count
        expected_accounts = int(len(customer_ids) * expected_accounts_per_customer)
        expected_transactions = int(expected_accounts * expected_transactions_per_account)
        expected_messages = expected_conversations * expected_messages_per_conversation
        expected_total = (
            expected_customers
            + expected_products
            + expected_accounts
            + expected_transactions
            + expected_conversations
            + expected_messages
        )

        actual_customers = len(customer_ids)
        actual_products = len(product_ids)
        actual_accounts = len(account_ids)
        actual_transactions = trans_count
        actual_conversations = len(conv_ids)
        actual_messages = message_count
        actual_total = (
            actual_customers
            + actual_products
            + actual_accounts
            + actual_transactions
            + actual_conversations
            + actual_messages
        )

        variance = actual_total - expected_total
        variance_percent = (variance / expected_total * 100) if expected_total > 0 else 0
        success_rate = (actual_total / expected_total * 100) if expected_total > 0 else 0

        logger.info("\nðŸ“Š DETAILED SEEDING REPORT\n")
        logger.info("=" * 75)
        logger.info(f"{'ENTITY':<20} {'EXPECTED':>18} {'ACTUAL':>18} {'VARIANCE':>15}")
        logger.info("=" * 75)
        logger.info(f"{'Customers':<20} {expected_customers:>18,} {actual_customers:>18,} {actual_customers - expected_customers:>+14,}")
        logger.info(f"{'Products':<20} {expected_products:>18,} {actual_products:>18,} {actual_products - expected_products:>+14,}")
        logger.info(f"{'Accounts':<20} {expected_accounts:>18,} {actual_accounts:>18,} {actual_accounts - expected_accounts:>+14,}")
        logger.info(f"{'Transactions':<20} {expected_transactions:>18,} {actual_transactions:>18,} {actual_transactions - expected_transactions:>+14,}")
        logger.info(f"{'Conversations':<20} {expected_conversations:>18,} {actual_conversations:>18,} {actual_conversations - expected_conversations:>+14,}")
        logger.info(f"{'Messages':<20} {expected_messages:>18,} {actual_messages:>18,} {actual_messages - expected_messages:>+14,}")
        logger.info("-" * 75)
        logger.info(f"{'TOTAL RECORDS':<20} {expected_total:>18,} {actual_total:>18,} {variance:>+14,}")
        logger.info("=" * 75)

        logger.info("\nðŸ“ˆ PERFORMANCE METRICS:")
        logger.info(f"  â€¢ Total Expected:     {expected_total:>10,} records")
        logger.info(f"  â€¢ Total Actual:       {actual_total:>10,} records")
        logger.info(f"  â€¢ Variance:           {variance:>+10,} records ({variance_percent:>+.2f}%)")
        logger.info(f"  â€¢ Success Rate:       {success_rate:>10.2f}%")

        logger.info("\n" + "=" * 75)
        logger.info("âœ… COMPLETION STATUS:")
        logger.info("=" * 75)

        if variance >= -5:
            logger.info("  âœ… PASSED - All expected records created successfully!")
            logger.info(f"     Variance within acceptable range: {variance:+,} records")
        elif -50 < variance < -5:
            logger.info("  âš ï¸  WARNING - Minor record creation failures detected")
            logger.info(f"     Variance: {variance:+,} records ({variance_percent:.2f}%)")
            logger.info(f"     Success Rate: {success_rate:.2f}%")
        else:
            logger.info("  âŒ FAILED - Significant record creation failures")
            logger.info(f"     Variance: {variance:+,} records ({variance_percent:.2f}%)")
            logger.info(f"     Success Rate: {success_rate:.2f}%")

        logger.info("=" * 75)
        logger.info("\nâœ¨ SEEDING SESSION SUMMARY:")
        logger.info(f"  â€¢ Session Type:       {'Full Reset' if clear_first else 'Append Mode'}")
        logger.info(f"  â€¢ Customers Seeded:   {actual_customers:,}")
        logger.info(f"  â€¢ Total Records:      {actual_total:,}")
        logger.info("  â€¢ Database Ready:     âœ… YES")
        logger.info("\nðŸŽ¯ Next Steps:")
        logger.info("  1. Verify data in database: psql or database client")
        logger.info("  2. Run API tests: pytest -v")
        logger.info("  3. Start application: python -m uvicorn app.main:app --reload")
        logger.info("\n" + "=" * 75 + "\n")

    except Exception as e:
        logger.error(f"âŒ Error seeding database: {e}", exc_info=True)
        raise


# =============================================================================
# CLI entry point
# =============================================================================
if __name__ == "__main__":
    import sys

    clear_first = "--clear" in sys.argv

    customer_count = 100
    for i, arg in enumerate(sys.argv):
        if arg == "--customers" and i + 1 < len(sys.argv):
            try:
                customer_count = int(sys.argv[i + 1])
            except ValueError:
                pass

    logger.info(f"Starting seed with {customer_count} customers...")
    asyncio.run(seed_all(clear_first=clear_first, customer_count=customer_count))


FILE PATH: ./app/routers/health.py
--------------------
"""
Health Check Router

Provides endpoints for system health monitoring, database status,
and dependency checks.
"""

from fastapi import APIRouter, status
from fastapi.responses import JSONResponse
from pydantic import BaseModel
from typing import Dict, Any
from datetime import datetime,timezone
import logging

from app.config import settings
from app.database import check_db_connection

logger = logging.getLogger(__name__)

# Create router
router = APIRouter()


# ============================================================================
# RESPONSE MODELS
# ============================================================================

class HealthResponse(BaseModel):
    """Health check response model."""

    status: str
    timestamp: str
    version: str
    environment: str
    checks: Dict[str, Any]


class PingResponse(BaseModel):
    """Simple ping response model."""

    status: str
    timestamp: str


# ============================================================================
# ENDPOINTS
# ============================================================================

@router.get(
    "/health",
    response_model=HealthResponse,
    status_code=status.HTTP_200_OK,
    summary="Comprehensive health check",
    description="Check overall system health including database and dependencies",
    tags=["Health"],
)
async def health_check() -> HealthResponse:
    """
    Comprehensive health check endpoint.

    Checks:
    - Database connectivity
    - System configuration
    - Application status

    Returns:
        HealthResponse: Detailed health status
    """
    # Check database
    db_healthy = await check_db_connection()

    # Overall status
    overall_status = "healthy" if db_healthy else "unhealthy"

    # Build response
    health_data = HealthResponse(
        status=overall_status,
        timestamp=datetime.now(timezone.utc).isoformat().replace("+00:00", "Z"),
        version=settings.app_version,
        environment=settings.environment,
        checks={
            "database": {
                "status": "healthy" if db_healthy else "unhealthy",
                "type": "postgresql",
                "pool_size": settings.database_pool_size,
            },
            "redis": {
                "status": "healthy" if settings.redis_enabled else "disabled",
                "enabled": settings.redis_enabled,
            },
            "groq_ai": {
                "status": "configured" if settings.groq_api_key else "not_configured",
                "model": settings.groq_model,
            },
        },
    )

    # Log health check
    logger.info(
        f"Health check: {overall_status}",
        extra={
            "status": overall_status,
            "db_healthy": db_healthy,
        },
    )

    # Return appropriate status code
    if overall_status == "healthy":
        return health_data
    else:
        return JSONResponse(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            content=health_data.model_dump(),
        )


@router.get(
    "/ping",
    response_model=PingResponse,
    status_code=status.HTTP_200_OK,
    summary="Simple ping check",
    description="Quick response check without dependency verification",
    tags=["Health"],
)
async def ping() -> PingResponse:
    """
    Simple ping endpoint.

    Returns immediate response without checking dependencies.
    Useful for basic liveness checks.

    Returns:
        PingResponse: Simple status
    """
    return PingResponse(
        status="ok",
        timestamp=datetime.now(timezone.utc).isoformat().replace("+00:00", "Z"),
    )


@router.get(
    "/ready",
    status_code=status.HTTP_200_OK,
    summary="Readiness check",
    description="Check if application is ready to accept requests",
    tags=["Health"],
)
async def readiness() -> Dict[str, Any]:
    """
    Readiness check endpoint.

    Used by Kubernetes to determine if pod is ready to receive traffic.
    Checks all critical dependencies.

    Returns:
        dict: Readiness status
    """
    # Check database
    db_healthy = await check_db_connection()

    # Application is ready if database is healthy
    is_ready = db_healthy

    if is_ready:
        return {
            "status": "ready",
            "timestamp":datetime.now(timezone.utc).isoformat().replace("+00:00", "Z"),
        }
    else:
        return JSONResponse(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            content={
                "status": "not_ready",
                "reason": "database_unhealthy",
                "timestamp":datetime.now(timezone.utc).isoformat().replace("+00:00", "Z"),
            },
        )


@router.get(
    "/live",
    status_code=status.HTTP_200_OK,
    summary="Liveness check",
    description="Check if application is alive (no dependency checks)",
    tags=["Health"],
)
async def liveness() -> Dict[str, str]:
    """
    Liveness check endpoint.

    Used by Kubernetes to determine if pod is alive and shouldn't be restarted.
    Returns 200 OK if application is running, regardless of dependencies.

    Returns:
        dict: Liveness status
    """
    return {
        "status": "alive",
        "timestamp":datetime.now(timezone.utc).isoformat().replace("+00:00", "Z"),
    }


FILE PATH: ./app/routers/__init__.py
--------------------


FILE PATH: ./app/routers/admin.py
--------------------
"""
Admin Routes

Protected endpoints for administrative tasks including database seeding.
"""

import logging
from fastapi import APIRouter, HTTPException, BackgroundTasks
from pydantic import BaseModel

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/api/v1/admin", tags=["admin"])

# ============================================================================
# MODELS
# ============================================================================

class SeedRequest(BaseModel):
    """Request to seed database."""
    clear_first: bool = False
    customer_count: int = 100  # Allow custom customer count


class SeedResponse(BaseModel):
    """Response from seeding."""
    status: str
    message: str


# ============================================================================
# ENDPOINTS
# ============================================================================

@router.post("/seed-db", response_model=SeedResponse)
async def seed_database(request: SeedRequest, background_tasks: BackgroundTasks):
    """
    Seed database with realistic sample data (1000+ records).

    WARNING: If clear_first=true, all existing data will be deleted!

    Args:
        request: Seed request with options
        background_tasks: FastAPI background tasks

    Returns:
        SeedResponse: Status of seeding operation

    Example:
        POST /api/v1/admin/seed-db
        {
            "clear_first": false,
            "customer_count": 100
        }
    """
    try:
        # Import here to avoid circular imports
        from app.seed_database import seed_all

        # Validate customer count
        customer_count = request.customer_count
        if customer_count < 10 or customer_count > 10000:
            raise ValueError("customer_count must be between 10 and 10000")

        # Run seeding in background
        background_tasks.add_task(
            seed_all,
            clear_first=request.clear_first,
            customer_count=customer_count
        )

        action = "Clearing database and seeding" if request.clear_first else "Seeding"

        return SeedResponse(
            status="started",
            message=f"{action} started with {customer_count} customers. "
                    f"This will generate ~{customer_count * 40:,} total records. Check logs for progress."
        )

    except Exception as e:
        logger.error(f"Failed to start seeding: {e}")
        raise HTTPException(
            status_code=500,
            detail=f"Failed to start seeding: {str(e)}"
        )


@router.get("/health")
async def health_check():
    """Simple health check endpoint."""
    return {
        "status": "healthy",
        "message": "Admin API is operational"
    }


FILE PATH: ./app/middleware/__init__.py
--------------------


FILE PATH: ./app/coordinator/__init__.py
--------------------
"""
Coordinator module - Agent orchestration and persistence
"""

from app.coordinator.agent_coordinator import AgentCoordinator

__all__ = ["AgentCoordinator"]


FILE PATH: ./app/coordinator/agent_coordinator.py
--------------------
"""
Agent Coordinator

Manages conversation state, routing, and persistence.
Coordinates multi-agent responses across conversation turns.
"""

from typing import Dict, Any, Optional, List
from datetime import datetime
import logging

from app.workflows.message_workflow import MessageWorkflow
from app.database import AsyncSessionLocal
from app.services import (
            AccountService,
            CustomerService,
            ProductService,
            ConversationService,
            TransactionService,
            FAQService,
        )
class ConversationMessage:
    """Single message in conversation."""

    def __init__(
        self,
        customer_id: int,
        message: str,
        agent_type: str,
        response: str,
        intent: str,
        confidence: float,
    ):
        self.timestamp = datetime.utcnow()
        self.customer_id = customer_id
        self.message = message
        self.agent_type = agent_type
        self.response = response
        self.intent = intent
        self.confidence = confidence


class ConversationContext:
    """Maintains conversation state and history."""

    def __init__(self, customer_id: int, conversation_id: int):
        self.customer_id = customer_id
        self.conversation_id = conversation_id
        self.messages: List[ConversationMessage] = []
        self.created_at = datetime.utcnow()
        self.last_intent = None
        self.escalation_id = None
        self.is_escalated = False

    def add_message(
        self,
        message: str,
        agent_type: str,
        response: str,
        intent: str,
        confidence: float,
    ) -> None:
        """Add message to conversation history."""
        conv_msg = ConversationMessage(
            customer_id=self.customer_id,
            message=message,
            agent_type=agent_type,
            response=response,
            intent=intent,
            confidence=confidence,
        )
        self.messages.append(conv_msg)
        self.last_intent = intent

    def mark_escalated(self, escalation_id: str) -> None:
        """Mark conversation as escalated."""
        self.is_escalated = True
        self.escalation_id = escalation_id

    def get_history(self, limit: int = 10) -> List[Dict[str, Any]]:
        """Get conversation history."""
        recent = self.messages[-limit:]
        return [
            {
                "timestamp": msg.timestamp.isoformat(),
                "message": msg.message,
                "agent": msg.agent_type,
                "intent": msg.intent,
                "response": msg.response[:100] + "...",
            }
            for msg in recent
        ]


class AgentCoordinator:
    """
    Coordinates multi-agent responses.

    Manages:
    - Conversation state
    - Message routing
    - Escalations
    - Persistence
    """

    def __init__(self,
    account_service=None,
    customer_service=None,
    product_service=None,
    conversation_service=None,
                 ):
        """Initialize coordinator."""
        self.logger = logging.getLogger(__name__)
        self.conversations: Dict[int, ConversationContext] = {}

            # Initialize services


        self.account_service = account_service or AccountService()
        self.customer_service = customer_service or CustomerService()
        self.product_service = product_service or ProductService()
        self.conversation_service = conversation_service or ConversationService()
        self.transaction_service = TransactionService()
        self.faq_service = FAQService()

    # ========================================================================
    # CONVERSATION MANAGEMENT
    # ========================================================================

    def get_or_create_conversation(
        self,
        customer_id: int,
        conversation_id: int,
    ) -> ConversationContext:
        """Get or create conversation context."""

        if conversation_id not in self.conversations:
            self.conversations[conversation_id] = ConversationContext(
                customer_id=customer_id,
                conversation_id=conversation_id,
            )

        return self.conversations[conversation_id]

    async def process_message(self, message: str, customer_id: int, conversation_id: int, context=None):
        self.logger.info(f"\nðŸ”„ Coordinating message for customer {customer_id}")

        conv_context = self.get_or_create_conversation(customer_id, conversation_id)

        if context is None:
            context = {}

        async with AsyncSessionLocal() as session:
            account_service = AccountService(db=session)
            customer_service = CustomerService(db=session)
            transaction_service = TransactionService(db=session)
            product_service = ProductService(db=session)
            conversation_service = ConversationService(db=session)
            # IMPORTANT: initialize faq_service with db session
            faq_service = FAQService(db=session)

            # build workflow WITH db-backed services
            workflow = MessageWorkflow(
                account_service=account_service,
                customer_service=customer_service,
                transaction_service=transaction_service,
                product_service=product_service,
                conversation_service=conversation_service,
                faq_service=faq_service
            )

            # IMPORTANT: update context with the db-backed services (not self.*)
            context.update({
                "account_service": account_service,
                "customer_service": customer_service,
                "transaction_service": transaction_service,
                "product_service": product_service,
                # keep these only if they exist and are DB-safe in your project:
                # "compliance_service": ...,
                "conversation_service": conversation_service,
            })

            # IMPORTANT: call the local workflow, not self.workflow
            workflow_response = await workflow.process_message(
                message=message,
                customer_id=customer_id,
                conversation_id=conversation_id,
                context=context,
            )

        # everything below stays the same (uses workflow_response)
        agent_type = workflow_response.get("agent")
        response_text = workflow_response.get("message")
        intent = workflow_response.get("intent")
        confidence = workflow_response.get("confidence", 0.0)

        conv_context.add_message(
            message=message,
            agent_type=agent_type,
            response=response_text,
            intent=intent,
            confidence=confidence,
        )

        escalation_id = workflow_response.get("metadata", {}).get("escalation_id")
        if escalation_id:
            conv_context.mark_escalated(escalation_id)
            self.logger.info(f"âš ï¸ Escalation detected: {escalation_id}")


        self.logger.info(f"âœ… Message processed: {agent_type} agent, turn #{len(conv_context.messages)}")


        return {
            "response": response_text,
            "agent": agent_type,
            "intent": intent,
            "confidence": confidence,
            "conversation_id": conversation_id,
            "turn_count": len(conv_context.messages),
            "escalated": conv_context.is_escalated,
            "escalation_id": escalation_id,
        }



    # ========================================================================
    # PERSISTENCE & RETRIEVAL
    # ========================================================================

    def get_conversation(self, conversation_id: int) -> Optional[ConversationContext]:
        """Get conversation by ID."""
        return self.conversations.get(conversation_id)

    def get_conversation_history(
        self,
        conversation_id: int,
        limit: int = 10,
    ) -> Optional[List[Dict[str, Any]]]:
        """Get conversation history."""
        conv = self.get_conversation(conversation_id)
        if conv:
            return conv.get_history(limit)
        return None

    def get_all_conversations(self, customer_id: int) -> List[ConversationContext]:
        """Get all conversations for a customer."""
        return [
            conv for conv in self.conversations.values()
            if conv.customer_id == customer_id
        ]

    # ========================================================================
    # ESCALATION MANAGEMENT
    # ========================================================================

    def get_escalated_conversations(self) -> List[Dict[str, Any]]:
        """Get all escalated conversations."""
        escalated = []
        for conv in self.conversations.values():
            if conv.is_escalated:
                escalated.append({
                    "conversation_id": conv.conversation_id,
                    "customer_id": conv.customer_id,
                    "escalation_id": conv.escalation_id,
                    "message_count": len(conv.messages),
                    "created_at": conv.created_at.isoformat(),
                })
        return escalated

    def resolve_escalation(
        self,
        conversation_id: int,
        resolution_notes: str,
    ) -> bool:
        """Mark escalation as resolved."""
        conv = self.get_conversation(conversation_id)
        if conv and conv.is_escalated:
            self.logger.info(f"âœ… Escalation resolved: {conv.escalation_id}")
            return True
        return False

    # ========================================================================
    # STATISTICS & MONITORING
    # ========================================================================

    def get_statistics(self) -> Dict[str, Any]:
        """Get coordination statistics."""
        total_messages = sum(
            len(conv.messages) for conv in self.conversations.values()
        )
        escalated_count = sum(
            1 for conv in self.conversations.values()
            if conv.is_escalated
        )

        # Agent distribution
        agent_counts = {}
        for conv in self.conversations.values():
            for msg in conv.messages:
                agent = msg.agent_type
                agent_counts[agent] = agent_counts.get(agent, 0) + 1

        # Intent distribution
        intent_counts = {}
        for conv in self.conversations.values():
            for msg in conv.messages:
                intent = msg.intent
                intent_counts[intent] = intent_counts.get(intent, 0) + 1

        return {
            "total_conversations": len(self.conversations),
            "total_messages": total_messages,
            "escalated_conversations": escalated_count,
            "agent_distribution": agent_counts,
            "intent_distribution": intent_counts,
            "avg_messages_per_conversation": (
                total_messages / len(self.conversations)
                if self.conversations else 0
            ),
        }

    def get_coordinator_info(self) -> Dict[str, Any]:
        """Get coordinator information."""
        return {
            "type": "AgentCoordinator",
            "workflow": "LangGraph (MessageWorkflow)",
            "agents": 6,
            "conversation_memory": len(self.conversations),
            "features": [
                "Multi-turn conversations",
                "Intent tracking",
                "Escalation management",
                "Conversation history",
                "Statistics & monitoring",
            ],
        }


FILE PATH: ./app/workflows/__init__.py
--------------------
"""
Workflows module - Multi-agent orchestration
"""

from app.workflows.message_workflow import MessageWorkflow

__all__ = ["MessageWorkflow"]


FILE PATH: ./app/workflows/message_workflow.py
--------------------
"""
Message Workflow

Multi-agent orchestration using LangGraph.
Routes messages through Intent Classifier â†’ Specialized Agents.
"""

from typing import Dict, Any, Optional, List
from enum import Enum
import logging

from langgraph.graph import StateGraph, END

from app.agents.intent_classifier import IntentClassifierAgent
from app.agents.account_agent import AccountAgent
from app.agents.general_agent import GeneralAgent
from app.agents.human_agent import HumanAgent
from app.agents.product_recommender import ProductRecommenderAgent
from app.agents.compliance_checker import ComplianceCheckerAgent
from app.services import (
    AccountService,
    CustomerService,
    TransactionService,
    ProductService,
    ConversationService,
    FAQService,
)


class WorkflowState(str, Enum):
    """Workflow states."""
    START = "start"
    CLASSIFY = "classify"
    ACCOUNT = "account"
    GENERAL = "general"
    PRODUCT = "product"
    COMPLIANCE = "compliance"
    HUMAN = "human"
    END = "end"


class MessageWorkflow:
    """
    Multi-agent message workflow.

    Flow:
    1. Intent Classifier â†’ determines intent
    2. Conditional routing:
       - account_inquiry â†’ Account Agent
       - general_inquiry â†’ General Agent
       - product_inquiry â†’ Product Agent â†’ Compliance Check
       - complaint â†’ Human Agent (escalation)
    3. Response formatting
    """

    def __init__(self, *, account_service, customer_service, transaction_service, product_service, conversation_service, faq_service):
        self.intent_classifier = IntentClassifierAgent()
        self.account_agent = AccountAgent(
            account_service=account_service,
            customer_service=customer_service,
            transaction_service=transaction_service,
            faq_service=faq_service
        )
        self.general_agent = GeneralAgent(faq_service=faq_service)
        self.product_agent = ProductRecommenderAgent(product_service=product_service)
        self.compliance_agent = ComplianceCheckerAgent()
        self.human_agent = HumanAgent(conversation_service=conversation_service)
        self.logger = logging.getLogger(__name__)


        # Build LangGraph workflow
        self.graph = self._build_graph()
        self.workflow = self.graph.compile()

    def _build_graph(self):
        """Build LangGraph state machine."""

        # Create state graph
        workflow = StateGraph(dict)

        # Define nodes
        workflow.add_node("classify", self._node_classify)
        workflow.add_node("account", self._node_account)
        workflow.add_node("general", self._node_general)
        workflow.add_node("product", self._node_product)
        workflow.add_node("compliance", self._node_compliance)
        workflow.add_node("human", self._node_human)
        workflow.add_node("end", self._node_end)

        # Entry point
        workflow.set_entry_point("classify")

        # Conditional routing from classifier
        workflow.add_conditional_edges(
            "classify",
            self._route_by_intent,
            {
                "account": "account",
                "general": "general",
                "product": "product",
                "complaint": "human",
                "default": "general",
            }
        )

        # Route product recommendations to compliance check
        workflow.add_edge("product", "compliance")

        # All paths eventually end
        workflow.add_edge("account", "end")
        workflow.add_edge("general", "end")
        workflow.add_edge("compliance", "end")
        workflow.add_edge("human", "end")

        # End state
        workflow.set_finish_point("end")

        return workflow

    # ========================================================================
    # NODE IMPLEMENTATIONS
    # ========================================================================

    async def _node_classify(self, state: Dict[str, Any]) -> Dict[str, Any]:
        """Classify intent."""
        self.logger.info("ðŸ“‹ Classifying message intent...")

        message = state.get("message")
        customer_id = state.get("customer_id")

        # Run intent classifier
        classification = await self.intent_classifier.process({
            "message": message,
        })

        # Extract intent
        intent = classification.metadata.get("intent", "general_inquiry")
        confidence = classification.confidence

        # Update state
        state["intent"] = intent
        state["intent_confidence"] = confidence
        state["classifier_response"] = classification.content

        self.logger.info(f"âœ… Intent: {intent} (confidence: {confidence:.2f})")

        return state

    async def _node_account(self, state: Dict[str, Any]) -> Dict[str, Any]:
        """Handle account inquiries."""
        self.logger.info("ðŸ¦ Processing account inquiry...")

        message = state.get("message")
        customer_id = state.get("customer_id")

        # Run account agent
        response = await self.account_agent.process({
            "customer_id": customer_id,
            "message": message,
        })

        state["agent_type"] = "account"
        state["agent_response"] = response.content
        state["agent_metadata"] = response.metadata
        state["confidence"] = response.confidence

        self.logger.info(f"âœ… Account query handled: {response.metadata.get('query_type')}")

        return state

    async def _node_general(self, state: Dict[str, Any]) -> Dict[str, Any]:
        """Handle general inquiries."""
        self.logger.info("â“ Processing general inquiry...")

        message = state.get("message")

        # Run general agent
        response = await self.general_agent.process({
            "message": message,
        })

        state["agent_type"] = "general"
        state["agent_response"] = response.content
        state["agent_metadata"] = response.metadata
        state["confidence"] = response.confidence

        self.logger.info(f"âœ… General inquiry handled: {response.metadata.get('source')}")

        return state

    async def _node_product(self, state: Dict[str, Any]) -> Dict[str, Any]:
        """Handle product recommendations."""
        self.logger.info("ðŸ’¼ Processing product inquiry...")

        message = state.get("message")
        customer_id = state.get("customer_id")

        # Run product recommender
        response = await self.product_agent.process({
            "customer_id": customer_id,
            "message": message,
        })

        state["agent_type"] = "product"
        state["agent_response"] = response.content
        state["agent_metadata"] = response.metadata
        state["confidence"] = response.confidence

        self.logger.info(f"âœ… Product recommendation generated")

        return state

    async def _node_compliance(self, state: Dict[str, Any]) -> Dict[str, Any]:
        """Check compliance of product recommendations."""
        self.logger.info("âš–ï¸ Checking FCA compliance...")

        agent_response = state.get("agent_response")

        # Run compliance checker
        response = await self.compliance_agent.process({
            "content": agent_response,
            "product_type": state.get("agent_metadata", {}).get("products"),
        })

        state["compliance_check"] = response.content
        state["is_compliant"] = response.metadata.get("is_compliant")
        state["required_disclaimers"] = response.metadata.get("required_disclaimers", [])

        # Append disclaimers to agent response if not compliant
        if not state["is_compliant"]:
            disclaimers = "\n\n".join(state["required_disclaimers"])
            state["agent_response"] = f"{agent_response}\n\nâš ï¸ Important:\n{disclaimers}"

        self.logger.info(f"âœ… Compliance check: {'âœ… PASS' if state['is_compliant'] else 'âŒ NEEDS REVISION'}")

        return state

    async def _node_human(self, state: Dict[str, Any]) -> Dict[str, Any]:
        """Escalate to human agent."""
        self.logger.info("ðŸ‘¤ Escalating to human specialist...")

        message = state.get("message")
        customer_id = state.get("customer_id")
        conversation_id = state.get("conversation_id", 0)

        context = state.get("context", {})




        # Run human agent
        response = await self.human_agent.process({
            "message": message,
            "customer_id": customer_id,
            "conversation_id": conversation_id,

        }, context=context)

        state["agent_type"] = "human"
        state["agent_response"] = response.content
        state["agent_metadata"] = response.metadata
        state["confidence"] = response.confidence

        self.logger.info(f"âœ… Escalation created: {response.metadata.get('escalation_id')}")

        return state

    async def _node_end(self, state: Dict[str, Any]) -> Dict[str, Any]:
        """Final response formatting."""
        self.logger.info("ðŸ“¤ Formatting final response...")

        # Build final response object
        state["final_response"] = {
            "message": state.get("agent_response"),
            "agent": state.get("agent_type"),
            "intent": state.get("intent"),
            "confidence": state.get("confidence"),
            "metadata": {
                "intent_confidence": state.get("intent_confidence"),
                "agent_metadata": state.get("agent_metadata"),
                "is_compliant": state.get("is_compliant", True),
                "escalation_id": state.get("agent_metadata", {}).get("escalation_id"),
            }
        }

        self.logger.info("âœ… Response ready to send")

        return state

    # ========================================================================
    # ROUTING LOGIC
    # ========================================================================

    def _route_by_intent(self, state: Dict[str, Any]) -> str:
        """Route to agent based on intent."""
        intent = state.get("intent", "general_inquiry")

        intent_map = {
            "account_inquiry": "account",
            "general_inquiry": "general",
            "loan_inquiry": "product",
            "credit_card": "product",
            "complaint": "complaint",
        }

        return intent_map.get(intent, "general")

    # ========================================================================
    # PUBLIC INTERFACE
    # ========================================================================

    async def process_message(
        self,
        message: str,
        customer_id: int,
        conversation_id: int = 0,
        context: Optional[Dict[str, Any]] = None,
    ) -> Dict[str, Any]:
        """
        Process message through workflow.

        Args:
            message: Customer message
            customer_id: Customer ID
            conversation_id: Conversation ID
            context: Optional context with services

        Returns:
            dict: Final response with agent info
        """
        self.logger.info(f"\nðŸ”„ Processing message from customer {customer_id}")
        self.logger.info(f"Message: {message[:100]}...")

        # Initial state
        initial_state = {
            "message": message,
            "customer_id": customer_id,
            "conversation_id": conversation_id,
            "context": context or {},
        }

        # Run workflow
        final_state = await self.workflow.ainvoke(initial_state)

        return final_state.get("final_response")

    def get_workflow_info(self) -> Dict[str, Any]:
        """Get workflow information."""
        return {
            "agents": [
                "IntentClassifier",
                "AccountAgent",
                "GeneralAgent",
                "ProductAgent",
                "ComplianceChecker",
                "HumanAgent",
            ],
            "flow": [
                "START",
                "  â†“",
                "CLASSIFY (IntentClassifier)",
                "  â”œâ†’ ACCOUNT (AccountAgent)",
                "  â”œâ†’ GENERAL (GeneralAgent)",
                "  â”œâ†’ PRODUCT (ProductAgent) â†’ COMPLIANCE (ComplianceChecker)",
                "  â””â†’ HUMAN (HumanAgent)",
                "  â†“",
                "END (Response Formatting)",
            ],
            "intents": [
                "account_inquiry",
                "general_inquiry",
                "product_inquiry",
                "complaint",
            ],
        }


FILE PATH: ./app/agents/general_agent.py
--------------------
"""
General Agent (Refactored for DB)
"""
from typing import Dict, Any, Optional, List
from groq import AsyncGroq
from app.agents.base import BaseAgent, AgentConfig, AgentResponse
from app.services.faq_service import FAQService

class GeneralAgent(BaseAgent):
    def __init__(self, config: Optional[AgentConfig] = None, faq_service: FAQService = None, **kwargs):
        super().__init__(name="general_agent", config=config)
        self.client = AsyncGroq(api_key=self.config.api_key)

        # [CRITICAL] This must be here to use the DB
        self.faq_service = faq_service

    async def process(self, input_data: Dict[str, Any], context: Optional[Dict[str, Any]] = None) -> AgentResponse:
        await self.validate_input(input_data)
        message = input_data.get("message", "")

        # 1. Try DB Lookup first
        faq_answer = await self._lookup_faq_db(message)

        if faq_answer:
            # [CRITICAL] This specific metadata tag matches the verify script
            return self.create_response(
                content=faq_answer,
                metadata={"source": "faq_db", "confidence": 1.0},
                confidence=1.0
            )

        # 2. Fallback to LLM
        try:
            response = await self.client.chat.completions.create(
                model=self.config.model_name,
                messages=[
                    {"role": "system", "content": "You are a helpful banking assistant."},
                    {"role": "user", "content": message}
                ],
                temperature=0.7
            )
            return self.create_response(
                content=response.choices[0].message.content,
                metadata={"source": "llm_fallback"},
                confidence=0.7
            )
        except Exception as e:
            return self.create_response(
                content="I'm having trouble connecting right now.",
                metadata={"error": str(e)},
                confidence=0.0
            )

    async def _lookup_faq_db(self, query: str) -> Optional[str]:
        """Search DB for FAQ match."""
        if not self.faq_service:
            return None

        # Search the database
        results = await self.faq_service.search_faqs(query)

        if results:
            return results[0].answer
        return None

    def _get_description(self) -> str: return "Handles general inquiries."
    def _get_capabilities(self) -> List[str]: return ["FAQ lookup"]


FILE PATH: ./app/agents/compliance_checker.py
--------------------
"""
Compliance Checker Agent

Ensures all communications and recommendations comply with FCA regulations.
Validates messages, products, and customer interactions for regulatory compliance.
"""

from typing import Dict, Any, Optional, List
from groq import AsyncGroq

from app.agents.base import BaseAgent, AgentConfig, AgentResponse


class ComplianceCheckerAgent(BaseAgent):
    """
    Compliance checker agent.

    Validates communications and recommendations for FCA compliance.
    """

    # ========================================================================
    # COMPLIANCE RULES
    # ========================================================================

    COMPLIANCE_RULES = {
        "prohibited_words": [
            "guaranteed",
            "risk-free",
            "no risk",
            "can't lose",
            "zero risk",
            "100% safe",
            "definitely",
            "promise",
        ],
        "required_disclaimers": {
            "investment": "Investments can go down as well as up",
            "loan": "Subject to status and affordability assessment",
            "credit": "Representative APR - your rate may differ",
            "savings": "Interest rates are variable and subject to change",
        },
        "sensitive_topics": [
            "debt",
            "bankruptcy",
            "foreclosure",
            "repossession",
            "default",
            "arrears",
        ],
        "mandatory_warnings": {
            "high_risk": "This product carries significant risk",
            "affordability": "Borrow only what you can afford to repay",
            "credit_impact": "Missed payments may affect your credit score",
        },
    }

    # FCA Principles (PRIN)
    FCA_PRINCIPLES = [
        "Integrity: Act with integrity in all dealings",
        "Skill, care and diligence: Exercise due skill, care and diligence",
        "Management and control: Take reasonable care to organize affairs responsibly",
        "Financial prudence: Maintain adequate financial resources",
        "Market conduct: Observe proper standards of market conduct",
        "Customers' interests: Pay due regard to customers' interests",
        "Communications: Pay due regard to information needs and communicate fairly",
        "Conflicts of interest: Manage conflicts of interest fairly",
        "Customers: relationships of trust: Take reasonable care for suitable relationships",
        "Clients' assets: Arrange adequate protection for clients' assets",
        "Relations with regulators: Deal with regulators in open and cooperative way",
    ]

    def __init__(self, config: Optional[AgentConfig] = None):
        """Initialize compliance checker agent."""
        super().__init__(name="compliance_checker", config=config)

        # Initialize Groq client
        self.client = AsyncGroq(api_key=self.config.api_key)

    # ========================================================================
    # ABSTRACT METHOD IMPLEMENTATIONS
    # ========================================================================

    def _get_description(self) -> str:
        """Get agent description."""
        return (
            "Compliance Checker Agent - Validates all communications and "
            "recommendations for FCA regulatory compliance."
        )

    def _get_capabilities(self) -> List[str]:
        """Get agent capabilities."""
        return [
            "FCA compliance validation",
            "Prohibited language detection",
            "Required disclaimer verification",
            "Risk assessment",
            "Regulatory guidance",
        ]

    # ========================================================================
    # CORE PROCESSING
    # ========================================================================

    async def process(
        self,
        input_data: Dict[str, Any],
        context: Optional[Dict[str, Any]] = None,
    ) -> AgentResponse:
        """
        Check content for FCA compliance.

        Args:
            input_data: Must contain 'content' (text to check)
            context: Optional context (product type, customer info)

        Returns:
            AgentResponse: Compliance check result
        """
        # Validate input
        await self.validate_input(input_data)

        # Log request
        self.log_request(input_data)

        # Extract content
        content = input_data.get("content", "")
        if not content:
            raise ValueError("Content is required for compliance check")

        # Extract context
        product_type = context.get("product_type", "") if context else ""

        # Perform compliance check
        compliance_result = await self._check_compliance(content, product_type)

        # Determine if compliant
        is_compliant = compliance_result["is_compliant"]

        # Build response message
        if is_compliant:
            response_content = "âœ… Content is FCA compliant"
        else:
            response_content = f"âš ï¸ Compliance issues detected:\n\n"
            for issue in compliance_result["issues"]:
                response_content += f"- {issue}\n"

        # Create response
        response = self.create_response(
            content=response_content,
            metadata={
                "is_compliant": is_compliant,
                "issues": compliance_result["issues"],
                "warnings": compliance_result["warnings"],
                "suggestions": compliance_result["suggestions"],
                "required_disclaimers": compliance_result["required_disclaimers"],
            },
            confidence=compliance_result["confidence"],
        )

        # Log response
        self.log_response(response)

        return response

    # ========================================================================
    # COMPLIANCE CHECKING LOGIC
    # ========================================================================

    async def _check_compliance(
        self,
        content: str,
        product_type: str,
    ) -> Dict[str, Any]:
        """
        Check content for compliance issues.

        Args:
            content: Text to check
            product_type: Type of product (for context)

        Returns:
            dict: Compliance check results
        """
        # Rule-based checks
        rule_issues = self._check_rules(content)

        # LLM-based deep check
        llm_result = await self._llm_compliance_check(content, product_type)

        # Combine results
        all_issues = rule_issues + llm_result["issues"]

        # Determine compliance
        is_compliant = len(all_issues) == 0

        # Get required disclaimers
        required_disclaimers = self._get_required_disclaimers(content, product_type)

        return {
            "is_compliant": is_compliant,
            "issues": all_issues,
            "warnings": llm_result["warnings"],
            "suggestions": llm_result["suggestions"],
            "required_disclaimers": required_disclaimers,
            "confidence": 0.95 if is_compliant else 0.85,
        }

    def _check_rules(self, content: str) -> List[str]:
        """
        Check content against rule-based compliance.

        Args:
            content: Text to check

        Returns:
            List[str]: List of issues found
        """
        issues = []
        content_lower = content.lower()

        # Check for prohibited words
        for word in self.COMPLIANCE_RULES["prohibited_words"]:
            if word in content_lower:
                issues.append(
                    f"Prohibited language detected: '{word}'. "
                    f"FCA requires balanced, not misleading information."
                )

        return issues

    async def _llm_compliance_check(
        self,
        content: str,
        product_type: str,
    ) -> Dict[str, Any]:
        """
        Deep compliance check using LLM.

        Args:
            content: Text to check
            product_type: Product type

        Returns:
            dict: LLM check results
        """
        # Build prompt
        prompt = self._build_compliance_prompt(content, product_type)

        # Call LLM
        response = await self.client.chat.completions.create(
            model=self.config.model_name,
            messages=[
                {
                    "role": "system",
                    "content": self._get_system_prompt(),
                },
                {
                    "role": "user",
                    "content": prompt,
                },
            ],
            temperature=0.1,  # Very low for consistent compliance checks
            max_tokens=self.config.max_tokens,
        )

        # Parse response
        result = self._parse_compliance_response(response.choices[0].message.content)

        return result

    def _build_compliance_prompt(
        self,
        content: str,
        product_type: str,
    ) -> str:
        """
        Build prompt for compliance check.

        Args:
            content: Text to check
            product_type: Product type

        Returns:
            str: Formatted prompt
        """
        # FCA principles summary
        principles_text = "\n".join([f"- {p}" for p in self.FCA_PRINCIPLES[:7]])

        product_context = ""
        if product_type:
            product_context = f"\nProduct Type: {product_type}"

        prompt = f"""Review the following content for FCA (Financial Conduct Authority) compliance.

Key FCA Principles:
{principles_text}

Content to Review:
"{content}"{product_context}

Check for:
1. Misleading or unclear language
2. Missing risk warnings
3. Unbalanced information (only benefits, no risks)
4. Guarantees or promises that can't be kept
5. Clarity of terms and conditions
6. Appropriate disclaimers
7. Fair treatment of customers

Respond in this format:
COMPLIANT: <YES or NO>
ISSUES: <comma-separated list of issues, or NONE>
WARNINGS: <comma-separated warnings, or NONE>
SUGGESTIONS: <improvements to make content more compliant>

Be strict - FCA compliance is critical for customer protection.
"""

        return prompt

    def _get_system_prompt(self) -> str:
        """
        Get system prompt for LLM.

        Returns:
            str: System prompt
        """
        return """You are an FCA compliance expert for a UK financial services company.

Your role:
- Review all customer-facing content for regulatory compliance
- Identify potential violations of FCA principles
- Ensure clear, fair, and not misleading communications
- Verify appropriate risk warnings and disclaimers
- Protect customer interests

FCA Standards:
- Communications must be clear, fair and not misleading (PRIN 7)
- Customers' interests must be paramount (PRIN 6)
- All material information must be disclosed
- Risk warnings must be prominent and clear
- No guarantees or promises unless absolutely certain
- Representative APR must be disclosed for credit products

Be thorough and strict - compliance violations can result in significant penalties."""

    def _parse_compliance_response(self, response_text: str) -> Dict[str, Any]:
        """
        Parse LLM compliance response.

        Args:
            response_text: Raw LLM response

        Returns:
            dict: Parsed compliance result
        """
        # Extract fields
        compliant = True
        issues = []
        warnings = []
        suggestions = ""

        for line in response_text.strip().split("\n"):
            line = line.strip()

            if line.startswith("COMPLIANT:"):
                compliant_str = line.split(":", 1)[1].strip().upper()
                compliant = compliant_str == "YES"
            elif line.startswith("ISSUES:"):
                issues_str = line.split(":", 1)[1].strip()
                if issues_str != "NONE":
                    issues = [i.strip() for i in issues_str.split(",")]
            elif line.startswith("WARNINGS:"):
                warnings_str = line.split(":", 1)[1].strip()
                if warnings_str != "NONE":
                    warnings = [w.strip() for w in warnings_str.split(",")]
            elif line.startswith("SUGGESTIONS:"):
                suggestions = line.split(":", 1)[1].strip()

        return {
            "compliant": compliant,
            "issues": issues,
            "warnings": warnings,
            "suggestions": suggestions,
        }

    def _get_required_disclaimers(
        self,
        content: str,
        product_type: str,
    ) -> List[str]:
        """
        Get required disclaimers based on content and product type.

        Args:
            content: Message content
            product_type: Product type

        Returns:
            List[str]: Required disclaimers
        """
        disclaimers = []
        content_lower = content.lower()

        # Check product type
        if product_type:
            disclaimer = self.COMPLIANCE_RULES["required_disclaimers"].get(product_type)
            if disclaimer:
                disclaimers.append(disclaimer)

        # Check content for keywords
        if any(word in content_lower for word in ["invest", "return", "profit"]):
            disclaimers.append(self.COMPLIANCE_RULES["required_disclaimers"]["investment"])

        if any(word in content_lower for word in ["loan", "borrow", "mortgage"]):
            disclaimers.append(self.COMPLIANCE_RULES["required_disclaimers"]["loan"])

        if any(word in content_lower for word in ["credit", "apr", "interest rate"]):
            disclaimers.append(self.COMPLIANCE_RULES["required_disclaimers"]["credit"])

        # Check for sensitive topics
        for topic in self.COMPLIANCE_RULES["sensitive_topics"]:
            if topic in content_lower:
                disclaimers.append(
                    "We understand this may be a difficult situation. "
                    "Free debt advice is available from MoneyHelper or StepChange."
                )
                break

        return list(set(disclaimers))  # Remove duplicates

    # ========================================================================
    # HELPER METHODS
    # ========================================================================

    def get_prohibited_words(self) -> List[str]:
        """
        Get list of prohibited words.

        Returns:
            List[str]: Prohibited words
        """
        return self.COMPLIANCE_RULES["prohibited_words"]

    def get_fca_principles(self) -> List[str]:
        """
        Get FCA principles.

        Returns:
            List[str]: FCA principles
        """
        return self.FCA_PRINCIPLES


FILE PATH: ./app/agents/__init__.py
--------------------
"""
Agents Package

Multi-agent system for FCA financial services support.
"""

from app.agents.base import BaseAgent, AgentConfig, AgentResponse
from app.agents.intent_classifier import IntentClassifierAgent
from app.agents.product_recommender import ProductRecommenderAgent
from app.agents.compliance_checker import ComplianceCheckerAgent
from app.agents.general_agent import GeneralAgent
from app.agents.account_agent import AccountAgent
from app.agents.human_agent import HumanAgent

# Services for dependency injection
from app.services import (
    AccountService,
    CustomerService,
    TransactionService,
    ProductService,
    ConversationService,
)

__all__ = [
    # Agents
    "BaseAgent",
    "AgentConfig",
    "AgentResponse",
    "AccountAgent",
    "IntentClassifierAgent",
    "ProductRecommenderAgent",
    "ComplianceCheckerAgent",
    "GeneralAgent",
    "HumanAgent",
    # Services
    "AccountService",
    "CustomerService",
    "TransactionService",
    "ProductService",
    "ConversationService",
]


FILE PATH: ./app/agents/account_agent.py
--------------------
from typing import Dict, Any, Optional, List
from datetime import datetime
from groq import AsyncGroq

from app.agents.base import BaseAgent, AgentConfig, AgentResponse
from app.services import AccountService, CustomerService, TransactionService

class AccountAgent(BaseAgent):
    def __init__(self, config: Optional[AgentConfig] = None
                 ,account_service: AccountService = None,
        customer_service: CustomerService = None,
        transaction_service: TransactionService = None,
        **kwargs):
        super().__init__(name="account_agent", config=config)
        self.client = AsyncGroq(api_key=self.config.api_key)

        if account_service is None or customer_service is None or transaction_service is None:
            raise ValueError("AccountAgent requires DB-backed services (inject AccountService/CustomerService/TransactionService).")

        self.account_service = account_service
        self.customer_service = customer_service
        self.transaction_service = transaction_service

    def _get_description(self) -> str:
        return (
            "Account Agent - Handles customer account inquiries including "
            "balance checks, transaction history, account statements, and operations."
        )

    def _get_capabilities(self) -> List[str]:
        return [
            "Account balance retrieval",
            "Transaction history lookup",
            "Account statement generation",
            "Account detail queries",
            "Natural language account information",
        ]

    async def process(
        self,
        input_data: Dict[str, Any],
        context: Optional[Dict[str, Any]] = None,
    ) -> AgentResponse:
        self.log_request(input_data)

        try:
            await self.validate_input(input_data)

            customer_id = input_data.get("customer_id")
            message = input_data.get("message", "")
            if not customer_id:
                raise ValueError("customer_id is required")

            query_type = self._determine_query_type(message)
            result = await self._fetch_real_data(customer_id, query_type, message)
            response = self.create_response(
                content=result["response"],
                metadata={
                    "query_type": query_type,
                    "account_data": result.get("data"),
                    "data_points": result.get("data_points", []),
                },
                confidence=0.95,
            )
            self.log_response(response)
            return response

        except Exception as e:
            self.logger.error(f"Account query error: {e}")
            return self.create_response(
                content=f"I couldn't retrieve your account information. Error: {str(e)}",
                metadata={"error": str(e)},
                confidence=0.0,
            )

    def _determine_query_type(self, message: str) -> str:
        message_lower = message.lower()
        if any(word in message_lower for word in ["balance", "how much", "account total", "have"]):
            return "balance"
        elif any(word in message_lower for word in ["transaction", "history", "recent", "activity"]):
            return "transactions"
        elif any(word in message_lower for word in ["statement", "download", "pdf", "email"]):
            return "statement"
        elif any(word in message_lower for word in ["details", "information", "account info"]):
            return "details"
        else:
            return "general"

    async def _fetch_real_data(self, customer_id: int, query_type: str, message: str) -> Dict[str, Any]:
        """
        Fetch real data from database services.
        """
        try:
            # 1) Customer lookup uses INTERNAL PK (customers.id: int)
            customer = await self.customer_service.get_customer(customer_id)
            if not customer:
                return {"response": f"Customer {customer_id} not found", "data": {}, "data_points": []}

            # 2) Accounts lookup uses EXTERNAL customer id (accounts.customer_id: varchar)
            external_customer_id = getattr(customer, "customer_id", None)
            if not external_customer_id:
                return {
                    "response": f"Customer {customer_id} is missing external customer_id",
                    "data": {},
                    "data_points": [],
                }

            # Helper: safely pull account fields that differ by schema
            def _account_summary(acct):
                return {
                    "account_number": getattr(acct, "account_number", None),
                    "type": getattr(acct, "type", None),  # <-- real column name is `type`
                    "status": getattr(acct, "status", None),
                    "balance": float(getattr(acct, "balance", 0.0) or 0.0),
                    "created_at": getattr(acct, "created_at", None),
                }

            if query_type == "balance":
                accounts = await self.account_service.get_accounts_by_customer(external_customer_id)
                if not accounts:
                    response = (
                        "Your current account balance is 0.00.\n\n"
                        "Account: N/A\n"
                        "Account Type: N/A\n"
                        f"Last Updated: {datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S')}"
                    )
                    return {
                        "response": response,
                        "data": {"balance": 0.0, "account_number": None, "type": None},
                        "data_points": ["balance", "account_number", "type"],
                    }

                acct = accounts[0]
                acct_num = getattr(acct, "account_number", None)
                acct_type = getattr(acct, "type", None)
                balance = float(getattr(acct, "balance", 0.0) or 0.0)

                response = (
                    f"Your current account balance is {balance:,.2f}.\n\n"
                    f"Account: {acct_num or 'N/A'}\n"
                    f"Account Type: {acct_type or 'N/A'}\n"
                    f"Last Updated: {datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S')}"
                )

                return {
                    "response": response,
                    "data": {"balance": balance, "account_number": acct_num, "type": acct_type},
                    "data_points": ["balance", "account_number", "type"],
                }

            elif query_type == "transactions":
                accounts = await self.account_service.get_accounts_by_customer(external_customer_id)
                if not accounts:
                    return {"response": f"No accounts found for customer {customer_id}", "data": {}, "data_points": []}

                acct = accounts[0]
                account_id = getattr(acct, "id", None)
                if account_id is None:
                    return {"response": "Account record missing id", "data": {}, "data_points": []}

                # Note: this service actually expects account_id (despite method name) in your codebase
                transactions = await self.transaction_service.get_transactions_by_account(account_id, limit=10)

                response = "Your recent transactions (last 10):\n\n"
                for i, txn in enumerate(transactions, 1):
                    response += (
                        f"{i}. {getattr(txn, 'description', 'N/A')}\n"
                        f" Amount: {float(getattr(txn, 'amount', 0.0) or 0.0):,.2f}\n"
                        f" Date: {getattr(txn, 'transaction_date', 'N/A')}\n"
                        f" Balance: {float(getattr(txn, 'balance_after', 0.0) or 0.0):,.2f}\n\n"
                    )

                return {
                    "response": response,
                    "data": {
                        "account": _account_summary(acct),
                        "transactions": [
                            {
                                "description": getattr(t, "description", None),
                                "amount": getattr(t, "amount", None),
                                "date": getattr(t, "transaction_date", None),
                            }
                            for t in transactions
                        ],
                    },
                    "data_points": ["transactions", "dates", "amounts"],
                }

            elif query_type == "statement":
                accounts = await self.account_service.get_accounts_by_customer(external_customer_id)
                acct = accounts[0] if accounts else None
                account_number = getattr(acct, "account_number", None) if acct else None

                response = (
                    f"Statement Request for Account {account_number or 'N/A'}\n\n"
                    "Your account statement has been generated.\n"
                    f"A PDF will be emailed to {getattr(customer, 'email', 'your email')} shortly.\n\n"
                    "You can also download it from your online banking portal:\n"
                    "- Log in to your account\n"
                    "- Go to Documents > Statements\n"
                    "- Select the date range\n"
                    "- Click Download PDF\n\n"
                    "If you need help, contact us at support@bank.com"
                )

                return {
                    "response": response,
                    "data": {"account_number": account_number, "email": getattr(customer, "email", None)},
                    "data_points": ["statement_generated", "email", "account_number"],
                }

            elif query_type == "details":
                accounts = await self.account_service.get_accounts_by_customer(external_customer_id)
                if not accounts:
                    return {"response": f"No accounts found for customer {customer_id}", "data": {}, "data_points": []}

                acct = accounts[0]
                acct_num = getattr(acct, "account_number", None)
                acct_type = getattr(acct, "type", None)
                created_at = getattr(acct, "created_at", None)  # prefer created_at over created_date

                response = (
                    f"Account Details for Customer {customer_id}\n\n"
                    f"Account Number: {acct_num or 'N/A'}\n"
                    f"Account Type: {acct_type or 'N/A'}\n"
                    f"Current Balance: {float(getattr(acct, 'balance', 0.0) or 0.0):,.2f}\n"
                    f"Account Status: {getattr(acct, 'status', 'N/A')}\n"
                    f"Created: {created_at or 'N/A'}\n"
                    f"Last Updated: {datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S')}\n\n"
                    "Contact information on file:\n"
                    f"Email: {getattr(customer, 'email', 'N/A')}\n"
                    f"Phone: {getattr(customer, 'phone', 'N/A')}"
                )

                return {
                    "response": response,
                    "data": {
                        "account_number": acct_num,
                        "type": acct_type,
                        "balance": float(getattr(acct, "balance", 0.0) or 0.0),
                        "status": getattr(acct, "status", None),
                        "created_at": created_at,
                    },
                    "data_points": ["account_number", "type", "balance", "status", "created_at"],
                }

            else:
                accounts = await self.account_service.get_accounts_by_customer(external_customer_id)
                response = f"Account information for customer {customer_id}. How else can I help with your account?"
                return {
                    "response": response,
                    "data": {"account_count": len(accounts) if accounts else 0},
                    "data_points": ["account_info"],
                }

        except Exception as e:
            self.logger.error(f"Error fetching real data: {e}")
            return {"response": f"Error retrieving account information: {str(e)}", "data": {}, "data_points": []}


FILE PATH: ./app/agents/intent_classifier.py
--------------------
"""
Intent Classifier Agent

Classifies customer intent from messages to route to appropriate specialists.
"""

from typing import Dict, Any, Optional, List
from groq import AsyncGroq

from app.agents.base import BaseAgent, AgentConfig, AgentResponse
from app.services import ProductService




class IntentClassifierAgent(BaseAgent):
    """
    Intent classifier agent.

    Analyzes customer messages to determine intent and route appropriately.
    """

    # ========================================================================
    # INTENT CATEGORIES
    # ========================================================================

    INTENTS = {
        "loan_inquiry": {
            "description": "Customer asking about loans (mortgage, personal, business)",
            "examples": [
                "I want to apply for a mortgage",
                "What are your loan interest rates?",
                "Can I get a personal loan?",
            ],
            "routing": "product_recommender",
        },
        "account_inquiry": {
            "description": "Questions about EXISTING account details (balance, transactions, statements)",
            "examples": [
                "What is my account balance?",
                "Show me my recent transactions",
                "I need a bank statement",
                "What's my transaction history?",
                "How much can I spend?",
            ],
            "routing": "account_agent",
        },
        "credit_card": {
            "description": "Credit card related queries",
            "examples": [
                "I want to apply for a credit card",
                "What credit cards do you offer?",
                "Increase my credit limit",
            ],
            "routing": "product_recommender",
        },
        "complaint": {
            "description": "Customer complaints or issues",
            "examples": [
                "I'm not happy with the service",
                "This is taking too long",
                "I want to make a complaint",
                "I'm unhappy with your service",
                "I'm disappointed",
                "My card was stolen!",
                "I need immediate help!",
                "This is urgent!",
                "Emergency! My card is missing!"
            ],
            "routing": "human_agent",
        },
        "general_inquiry": {
            "description": "General questions, FAQs, how-to questions, or help/support contact requests",
            "examples": [
                "How do I open an account?",
                "How do I contact support?",
                "What services do you offer?",
                "How can I create a new account?",
                "How do I get help?",
                "What are your support hours?",
                "How do I reach customer service?",
            ],
            "routing": "general_agent",
        },
    }

    def __init__(self, config: Optional[AgentConfig] = None,
                 product_service: ProductService = None,
    **kwargs):
        """Initialize intent classifier agent."""
        super().__init__(name="intent_classifier", config=config)

        # Initialize Groq client
        self.client = AsyncGroq(api_key=self.config.api_key)
        self.product_service = product_service or ProductService()


    # ========================================================================
    # ABSTRACT METHOD IMPLEMENTATIONS
    # ========================================================================

    def _get_description(self) -> str:
        """Get agent description."""
        return (
            "Intent Classifier Agent - Analyzes customer messages to determine "
            "intent and route to appropriate specialist agents."
        )

    def _get_capabilities(self) -> List[str]:
        """Get agent capabilities."""
        return [
            "Intent classification",
            "Sentiment analysis",
            "Confidence scoring",
            "Multi-language support",
            "Context-aware classification",
        ]

    # ========================================================================
    # CORE PROCESSING
    # ========================================================================

    async def process(
        self,
        input_data: Dict[str, Any],
        context: Optional[Dict[str, Any]] = None,
    ) -> AgentResponse:
        """
        Classify intent from customer message.

        Args:
            input_data: Must contain 'message' key
            context: Optional conversation context

        Returns:
            AgentResponse: Classification result
        """
        # Validate input
        await self.validate_input(input_data)

        # Log request
        self.log_request(input_data)

        # Extract message
        message = input_data.get("message", "")
        if not message:
            raise ValueError("Message is required")

        # Classify intent
        classification = await self._classify_intent(message, context)

        # Create response
        response = self.create_response(
            content=classification["intent"],
            metadata={
                "intent": classification["intent"],
                "sentiment": classification["sentiment"],
                "routing": classification["routing"],
                "explanation": classification["explanation"],
            },
            confidence=classification["confidence"],
        )

        # Log response
        self.log_response(response)

        return response

    # ========================================================================
    # CLASSIFICATION LOGIC
    # ========================================================================

    async def _classify_intent(
        self,
        message: str,
        context: Optional[Dict[str, Any]] = None,
    ) -> Dict[str, Any]:
        """
        Classify intent using LLM.

        Args:
            message: Customer message
            context: Optional context

        Returns:
            dict: Classification result
        """
        # Build prompt
        prompt = self._build_classification_prompt(message, context)

        # Call LLM
        response = await self.client.chat.completions.create(
            model=self.config.model_name,
            messages=[
                {
                    "role": "system",
                    "content": self._get_system_prompt(),
                },
                {
                    "role": "user",
                    "content": prompt,
                },
            ],
            temperature=self.config.temperature,
            max_tokens=self.config.max_tokens,
        )

        # Parse response
        result = self._parse_llm_response(response.choices[0].message.content)

        return result

    def _build_classification_prompt(
        self,
        message: str,
        context: Optional[Dict[str, Any]] = None,
    ) -> str:
        """
        Build prompt for classification.

        Args:
            message: Customer message
            context: Optional context

        Returns:
            str: Formatted prompt
        """
        # Intent descriptions
        intent_descriptions = "\n".join([
            f"- {intent}: {data['description']}"
            for intent, data in self.INTENTS.items()
        ])

        # Build prompt
        prompt = f"""Classify the following customer message into one of these intents:

{intent_descriptions}

Customer Message: "{message}"

Respond in this exact format:
INTENT: <intent_name>
CONFIDENCE: <0.0-1.0>
SENTIMENT: <positive|neutral|negative>
EXPLANATION: <brief explanation>
"""

        # Add context if provided
        if context and context.get("conversation_history"):
            history = "\n".join([
                f"{msg['role']}: {msg['content']}"
                for msg in context["conversation_history"][-3:]  # Last 3 messages
            ])
            prompt += f"\n\nConversation History:\n{history}"

        return prompt

    def _get_system_prompt(self) -> str:
        """
        Get system prompt for LLM.

        Returns:
            str: System prompt
        """
        return """You are an expert intent classifier for a UK financial services company (FCA regulated).

Your job is to analyze customer messages and determine their intent accurately.

Guidelines:
- Be precise and confident in your classifications
- Consider context from conversation history
- Detect sentiment (positive, neutral, negative)
- Provide clear explanations
- Use the exact format requested"""

    def _parse_llm_response(self, response_text: str) -> Dict[str, Any]:
        """
        Parse LLM response into structured format.

        Args:
            response_text: Raw LLM response

        Returns:
            dict: Parsed classification
        """
        # Extract fields
        intent = "general_inquiry"  # Default
        confidence = 0.5
        sentiment = "neutral"
        explanation = ""

        for line in response_text.strip().split("\n"):
            line = line.strip()

            if line.startswith("INTENT:"):
                intent = line.split(":", 1)[1].strip().lower()
            elif line.startswith("CONFIDENCE:"):
                try:
                    confidence = float(line.split(":", 1)[1].strip())
                except:
                    confidence = 0.5
            elif line.startswith("SENTIMENT:"):
                sentiment = line.split(":", 1)[1].strip().lower()
            elif line.startswith("EXPLANATION:"):
                explanation = line.split(":", 1)[1].strip()

        # Get routing
        routing = self.INTENTS.get(intent, {}).get("routing", "general_agent")

        return {
            "intent": intent,
            "confidence": confidence,
            "sentiment": sentiment,
            "explanation": explanation,
            "routing": routing,
        }

    # ========================================================================
    # HELPER METHODS
    # ========================================================================

    def get_supported_intents(self) -> List[str]:
        """
        Get list of supported intents.

        Returns:
            List[str]: Intent names
        """
        return list(self.INTENTS.keys())

    def get_intent_info(self, intent: str) -> Optional[Dict[str, Any]]:
        """
        Get information about specific intent.

        Args:
            intent: Intent name

        Returns:
            dict or None: Intent information
        """
        return self.INTENTS.get(intent)


FILE PATH: ./app/agents/product_recommender.py
--------------------
"""
Product Recommender Agent
Recommends financial products based on customer needs and profile.
"""
from typing import Dict, Any, Optional, List
from groq import AsyncGroq
from app.agents.base import BaseAgent, AgentConfig, AgentResponse
from app.services import ProductService

class ProductRecommenderAgent(BaseAgent):
    def __init__(self, config: Optional[AgentConfig] = None, product_service: ProductService = None, **kwargs):
        super().__init__(name="product_recommender", config=config)
        self.client = AsyncGroq(api_key=self.config.api_key)

        # Enforce DB Service Injection
        if product_service is None:
            raise ValueError("ProductRecommenderAgent requires ProductService injected with a DB session")
        self.product_service = product_service

    async def process(self, input_data: Dict[str, Any], context: Optional[Dict[str, Any]] = None) -> AgentResponse:
        await self.validate_input(input_data)
        self.log_request(input_data)

        intent = input_data.get("intent", "")
        message = input_data.get("message", "")
        customer_profile = context.get("customer", {}) if context else {}

        try:
            recommendations = await self._generate_recommendations(intent, message, customer_profile)

            response = self.create_response(
                content=recommendations["response_text"],
                metadata={
                    "products": [p.name for p in recommendations["products"]],
                    "reasoning": recommendations["reasoning"],
                    "disclaimers": recommendations["disclaimers"],
                },
                confidence=recommendations["confidence"],
            )
            self.log_response(response)
            return response
        except Exception as e:
            self.logger.error(f"Product recommendation error: {e}", exc_info=True)
            return self.create_response(
                content="I apologize, but I'm having trouble retrieving product information right now.",
                metadata={"error": str(e)},
                confidence=0.0
            )

    async def _generate_recommendations(self, intent: str, message: str, customer_profile: Dict[str, Any]) -> Dict[str, Any]:
        # 1. Map intent to DB type (loan, credit, savings, current)
        category = self._determine_category(intent)

        # 2. Fetch from DB
        available_products = await self.product_service.get_products_by_category(category)

        if not available_products:
             return {
                 "response_text": f"I currently don't have any specific {category} products to recommend.",
                 "products": [],
                 "reasoning": "No products found in database.",
                 "disclaimers": [],
                 "confidence": 0.5
             }

        # 3. Build Prompt & Call LLM
        prompt = self._build_recommendation_prompt(intent, message, customer_profile, available_products)
        response = await self.client.chat.completions.create(
            model=self.config.model_name,
            messages=[
                {"role": "system", "content": self._get_system_prompt()},
                {"role": "user", "content": prompt},
            ],
            temperature=0.5,
            max_tokens=self.config.max_tokens,
        )

        return self._parse_recommendation_response(response.choices[0].message.content, available_products)

    def _determine_category(self, intent: str) -> str:
        # Maps Agent Intent -> DB 'type' column
        intent_to_db_type = {
            "loan_inquiry": "loan",
            "mortgage_inquiry": "loan",
            "personal_loan": "loan",
            "savings_inquiry": "savings",
            "credit_card": "credit",
            "account_opening": "current",
        }
        return intent_to_db_type.get(intent, "savings")

    def _build_recommendation_prompt(self, intent: str, message: str, customer_profile: Dict[str, Any], available_products: List[Any]) -> str:
        products_text = ""
        for p in available_products:
            features = ", ".join(p.features) if p.features else "Standard features"
            rate = f"{p.interest_rate}%" if p.interest_rate is not None else "Variable"
            products_text += (
                f"Product: {p.name}\n"
                f"Description: {p.description}\n"
                f"Interest Rate: {rate}\n"
                f"Features: {features}\n\n"
            )

        is_vip = customer_profile.get("is_vip", False) if customer_profile else False
        customer_text = f"\n\nCustomer Profile:\n- VIP Status: {'Yes' if is_vip else 'No'}"

        return f"""Based on the customer's needs, recommend the most suitable financial products.
Customer Intent: {intent}
Customer Message: "{message}"{customer_text}

Available Products (from Database):
{products_text}

Provide recommendations in this format:
RECOMMENDED PRODUCTS: <comma-separated product names>
REASONING: <why suitable>
KEY BENEFITS: <main benefits>
NEXT STEPS: <action items>
CONFIDENCE: <0.0-1.0>
"""

    def _get_system_prompt(self) -> str:
        return "You are a financial product recommendation specialist for a UK bank (FCA regulated). Recommend suitable products, explain benefits clearly, and include risks."

    def _parse_recommendation_response(self, response_text: str, available_products: List[Any]) -> Dict[str, Any]:
        recommended_names = []
        reasoning = ""
        key_benefits = ""
        next_steps = ""
        confidence = 0.8

        for line in response_text.strip().split("\n"):
            line = line.strip()
            if line.startswith("RECOMMENDED PRODUCTS:"):
                products_str = line.split(":", 1)[1].strip()
                recommended_names = [p.strip() for p in products_str.split(",")]
            elif line.startswith("REASONING:"):
                reasoning = line.split(":", 1)[1].strip()
            elif line.startswith("KEY BENEFITS:"):
                key_benefits = line.split(":", 1)[1].strip()
            elif line.startswith("NEXT STEPS:"):
                next_steps = line.split(":", 1)[1].strip()

        matched_products = []
        for name in recommended_names:
            for p in available_products:
                if name.lower() in p.name.lower():
                    matched_products.append(p)
                    break

        final_text = self._format_recommendation_text(matched_products, reasoning, key_benefits, next_steps)

        return {
            "response_text": final_text,
            "products": matched_products,
            "reasoning": reasoning,
            "disclaimers": ["Representative APR quoted - your rate may differ", "Subject to status"],
            "confidence": confidence,
        }

    def _format_recommendation_text(self, products, reasoning, key_benefits, next_steps):
        text = "Based on your needs, I recommend:\n\n"
        for i, p in enumerate(products, 1):
            rate = f"{p.interest_rate}%" if p.interest_rate is not None else "Variable"
            text += f"{i}. **{p.name}**\n   {p.description}\n   Rate: {rate}\n\n"
        if reasoning: text += f"**Why?**\n{reasoning}\n\n"
        if key_benefits: text += f"**Benefits:**\n{key_benefits}\n\n"
        if next_steps: text += f"**Next Steps:**\n{next_steps}\n\n"
        return text

    def _get_description(self) -> str:
        return "Product Recommender - Recommends financial products from the database."

    def _get_capabilities(self) -> List[str]:
        return ["Product recommendation", "Needs analysis"]
    


FILE PATH: ./app/agents/human_agent.py
--------------------
"""
Human Agent

Manages escalation to human specialists.
Handles complaints and complex issues.
"""

from typing import Dict, Any, Optional, List
from datetime import datetime
from enum import Enum

from app.agents.base import BaseAgent, AgentConfig, AgentResponse
from app.services import ConversationService

class EscalationPriority(str, Enum):
    """Escalation priority levels."""
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    URGENT = "urgent"


class HumanAgent(BaseAgent):
    """
    Human agent for escalations.

    Manages:
    - Complaint escalations
    - Complex issue handoff
    - Priority routing
    - Escalation tracking
    """

    def __init__(self, config: Optional[AgentConfig] = None, conversation_service: ConversationService = None,
    **kwargs):
        """Initialize human agent."""
        super().__init__(name="human_agent", config=config)
        self.conversation_service = conversation_service or ConversationService()

    # ========================================================================
    # ABSTRACT METHOD IMPLEMENTATIONS
    # ========================================================================

    def _get_description(self) -> str:
        """Get agent description."""
        return (
            "Human Agent - Manages escalation to human specialists "
            "for complaints, complex issues, and priority support."
        )

    def _get_capabilities(self) -> List[str]:
        """Get agent capabilities."""
        return [
            "Complaint escalation",
            "Complex issue routing",
            "Priority assessment",
            "Specialist assignment",
            "Escalation tracking",
            "Conversation handoff",
        ]

    # ========================================================================
    # CORE PROCESSING
    # ========================================================================

    async def process(
        self,
        input_data: Dict[str, Any],
        context: Optional[Dict[str, Any]] = None,
    ) -> AgentResponse:
        """
        Process escalation request.

        Args:
            input_data: Must contain 'message', 'customer_id', 'conversation_id'
            context: Optional context with conversation_service

        Returns:
            AgentResponse: Escalation confirmation
        """
        self.log_request(input_data)

        try:
            await self.validate_input(input_data)

            message = input_data.get("message", "")
            customer_id = input_data.get("customer_id")
            conversation_id = input_data.get("conversation_id")

            if not all([message, customer_id, conversation_id]):
                raise ValueError(
                    "message, customer_id, and conversation_id are required"
                )

            # Assess escalation priority
            priority = self._assess_priority(message)

            # Create escalation
            escalation = await self._create_escalation(
                customer_id=customer_id,
                conversation_id=conversation_id,
                issue=message,
                priority=priority,
                context=context,
            )

            # Generate response
            response_content = self._generate_escalation_response(
                escalation, priority
            )

            response = self.create_response(
                content=response_content,
                metadata={
                    "escalated": True,
                    "escalation_id": escalation.get("id"),
                    "priority": priority.value,
                    "assigned_to": escalation.get("assigned_to"),
                    "estimated_response": escalation.get("estimated_response"),
                },
                confidence=0.98,
            )

            self.log_response(response)
            return response

        except Exception as e:
            self.logger.error(f"Escalation error: {e}")
            error_response = self.create_response(
                content=(
                    "I've logged your issue and will have a specialist contact you shortly. "
                    "Your case reference is being processed."
                ),
                metadata={"error": str(e)},
                confidence=0.9,
            )
            return error_response

    # ========================================================================
    # ESCALATION PROCESSING
    # ========================================================================

    def _assess_priority(self, message: str) -> EscalationPriority:
        """
        Assess escalation priority from message.

        Args:
            message: Customer message

        Returns:
            EscalationPriority: Priority level
        """
        message_lower = message.lower()

        # Urgent keywords
        urgent_keywords = [
            "urgent", "emergency", "critical", "immediate",
            "lost", "stolen", "fraud", "unauthorized",
            "cannot access", "locked out", "security breach"
        ]

        # High priority keywords
        high_keywords = [
            "complaint", "disappointed", "unhappy", "unacceptable",
            "refused", "denied", "failed", "issue", "problem",
            "wrong", "error", "mistake"
        ]

        # Medium priority keywords
        medium_keywords = [
            "help", "question", "need", "want", "prefer",
            "change", "update", "modify"
        ]

        # Check priority levels
        if any(kw in message_lower for kw in urgent_keywords):
            return EscalationPriority.URGENT
        elif any(kw in message_lower for kw in high_keywords):
            return EscalationPriority.HIGH
        elif any(kw in message_lower for kw in medium_keywords):
            return EscalationPriority.MEDIUM
        else:
            return EscalationPriority.LOW

    async def _create_escalation(
        self,
        customer_id: int,
        conversation_id: int,
        issue: str,
        priority: EscalationPriority,
        context: Optional[Dict[str, Any]] = None,
    ) -> Dict[str, Any]:
        """
        Create escalation record.
        """
        # 1. Get the Service from Context (This has the active DB session)
        # We prioritize the one passed in 'context' because it's fresh.
        conversation_service = None
        if context:
            conversation_service = context.get("conversation_service")

        # Fallback to self.conversation_service (likely empty, but good safety)
        if not conversation_service:
            conversation_service = self.conversation_service

        ticket_id = f"ESC-{customer_id}-{int(datetime.utcnow().timestamp())}"
        assigned_group = self._assign_specialist(priority)

        escalation = {
            "id": ticket_id,
            "customer_id": customer_id,
            "conversation_id": conversation_id,
            "issue": issue,
            "priority": priority.value,
            "status": "open",
            "created_at": datetime.utcnow().isoformat(),
            "assigned_to": assigned_group,
            "estimated_response": self._estimate_response_time(priority),
            "saved": False # Default to False
        }

        # 2. Save to DB (Only if service is valid)
        if conversation_service:
            try:
                # [CRITICAL CHECK] Ensure service has a DB session
                if hasattr(conversation_service, 'db') and conversation_service.db is not None:
                    await conversation_service.escalate_conversation(
                        conversation_id,
                        reason=issue,
                        priority=priority.value,
                        assigned_group=assigned_group,
                        ticket_id=ticket_id
                    )
                    escalation["saved"] = True
                    self.logger.info(f"Escalation saved to DB for conversation {conversation_id}")
                else:
                    self.logger.warning("ConversationService has no DB session. Cannot save escalation.")
            except Exception as e:
                self.logger.warning(f"Could not save escalation: {e}")
        else:
            self.logger.warning("No ConversationService available. Escalation is in-memory only.")

        return escalation

    def _estimate_response_time(self, priority: EscalationPriority) -> str:
        """
        Estimate response time based on priority.

        Args:
            priority: Priority level

        Returns:
            str: Estimated response time
        """
        estimates = {
            EscalationPriority.URGENT: "Within 15 minutes",
            EscalationPriority.HIGH: "Within 1 hour",
            EscalationPriority.MEDIUM: "Within 4 hours",
            EscalationPriority.LOW: "Within 24 hours",
        }
        return estimates.get(priority, "Within 24 hours")

    def _assign_specialist(self, priority: EscalationPriority) -> str:
        """
        Assign specialist based on priority.

        Args:
            priority: Priority level

        Returns:
            str: Specialist team
        """
        teams = {
            EscalationPriority.URGENT: "Security & Fraud Team",
            EscalationPriority.HIGH: "Senior Support Team",
            EscalationPriority.MEDIUM: "Support Specialists",
            EscalationPriority.LOW: "Support Team",
        }
        return teams.get(priority, "Support Team")

    def _generate_escalation_response(
        self, escalation: Dict[str, Any], priority: EscalationPriority
    ) -> str:
        """
        Generate response message for escalation.

        Args:
            escalation: Escalation record
            priority: Priority level

        Returns:
            str: Response message
        """
        response = (
            f"Thank you for bringing this to our attention.\n\n"
            f"We've escalated your issue to our {escalation['assigned_to']}.\n\n"
            f"ðŸ“‹ Reference Number: {escalation['id']}\n"
            f"â±ï¸  Estimated Response: {escalation['estimated_response']}\n"
            f"ðŸ”” Priority: {priority.value.upper()}\n\n"
        )

        if priority == EscalationPriority.URGENT:
            response += (
                "This is marked as urgent. A specialist will contact you "
                "immediately via your preferred contact method.\n"
            )
        else:
            response += (
                "A specialist will review your case and contact you shortly.\n"
            )

        response += (
            "\nYou'll receive:\n"
            "âœ“ Email confirmation of this escalation\n"
            "âœ“ Regular updates on your case\n"
            "âœ“ Direct contact with a specialist\n"
            "âœ“ Resolution timeline\n\n"
            "For immediate assistance, call 0800-123-4567"
        )

        return response

    # ========================================================================
    # HELPER METHODS
    # ========================================================================

    def get_priority_levels(self) -> List[str]:
        """Get available priority levels."""
        return [p.value for p in EscalationPriority]

    def get_escalation_info(self) -> Dict[str, Any]:
        """Get escalation information."""
        return {
            "priorities": self.get_priority_levels(),
            "specialist_teams": [
                "Security & Fraud Team",
                "Senior Support Team",
                "Support Specialists",
                "Support Team",
            ],
            "response_targets": {
                "urgent": "15 minutes",
                "high": "1 hour",
                "medium": "4 hours",
                "low": "24 hours",
            },
        }


FILE PATH: ./app/agents/base.py
--------------------
"""
Base Agent

Abstract base class for all agents in the multi-agent system.
Provides common functionality and interface.
"""

from abc import ABC, abstractmethod
from typing import Dict, Any, Optional, List
from datetime import datetime
import logging

from app.config import settings


class AgentConfig:
    """
    Agent configuration.

    Common configuration shared by all agents.
    """

    def __init__(
        self,
        model_name: str = "llama-3.1-8b-instant",
        temperature: float = 0.7,
        max_tokens: int = 1024,
        timeout: int = 30,
    ):
        """
        Initialize agent configuration.

        Args:
            model_name: LLM model to use
            temperature: Sampling temperature (0-1)
            max_tokens: Maximum tokens in response
            timeout: API timeout in seconds
        """
        self.model_name = model_name
        self.temperature = temperature
        self.max_tokens = max_tokens
        self.timeout = timeout
        self.api_key = settings.groq_api_key

    def to_dict(self) -> Dict[str, Any]:
        """Convert config to dictionary."""
        return {
            "model_name": self.model_name,
            "temperature": self.temperature,
            "max_tokens": self.max_tokens,
            "timeout": self.timeout,
        }


class AgentResponse:
    """
    Agent response wrapper.

    Standardized response format from all agents.
    """

    def __init__(
        self,
        content: str,
        metadata: Optional[Dict[str, Any]] = None,
        confidence: Optional[float] = None,
        agent_name: Optional[str] = None,
    ):
        """
        Initialize agent response.

        Args:
            content: Response content/text
            metadata: Additional metadata
            confidence: Confidence score (0-1)
            agent_name: Name of agent that generated response
        """
        self.content = content
        self.metadata = metadata or {}
        self.confidence = confidence
        self.agent_name = agent_name
        self.timestamp = datetime.utcnow()

    def to_dict(self) -> Dict[str, Any]:
        """Convert response to dictionary."""
        return {
            "content": self.content,
            "metadata": self.metadata,
            "confidence": self.confidence,
            "agent_name": self.agent_name,
            "timestamp": self.timestamp.isoformat(),
        }

    def __repr__(self) -> str:
        """String representation."""
        return (
            f"<AgentResponse("
            f"agent='{self.agent_name}', "
            f"confidence={self.confidence}, "
            f"content='{self.content[:50]}...')>"
        )


class BaseAgent(ABC):
    """
    Base agent class.

    All agents must inherit from this class and implement:
    - process() method for handling requests
    """

    def __init__(
        self,
        name: str,
        config: Optional[AgentConfig] = None,
        services: Optional[Dict[str, Any]] = None
    ):
        """
        Initialize base agent.

        Args:
            name: Agent name
            config: Agent configuration (uses defaults if not provided)
        """
        self.name = name
        self.config = config or AgentConfig()
        self.logger = logging.getLogger(f"agent.{name}")
        self.services = services or {}

        # Agent metadata
        self.description = self._get_description()
        self.capabilities = self._get_capabilities()

        # Initialize agent
        self._initialize()

    # ========================================================================
    # ABSTRACT METHODS (must be implemented by subclasses)
    # ========================================================================

    @abstractmethod
    async def process(
        self,
        input_data: Dict[str, Any],
        context: Optional[Dict[str, Any]] = None,
    ) -> AgentResponse:
        """
        Process input and generate response.

        Args:
            input_data: Input data to process
            context: Optional context (conversation history, customer info, etc.)

        Returns:
            AgentResponse: Agent response
        """
        pass

    @abstractmethod
    def _get_description(self) -> str:
        """
        Get agent description.

        Returns:
            str: Agent description
        """
        pass

    @abstractmethod
    def _get_capabilities(self) -> List[str]:
        """
        Get agent capabilities.

        Returns:
            List[str]: List of capabilities
        """
        pass

    # ========================================================================
    # COMMON METHODS
    # ========================================================================

    def _initialize(self):
        """
        Initialize agent.

        Called after __init__. Override to add custom initialization.
        """
        self.logger.info(f"Initialized {self.name} agent")

    async def validate_input(self, input_data: Dict[str, Any]) -> bool:
        """
        Validate input data.

        Args:
            input_data: Input to validate

        Returns:
            bool: True if valid

        Raises:
            ValueError: If input is invalid
        """
        if not input_data:
            raise ValueError("Input data cannot be empty")

        return True

    def log_request(self, input_data: Dict[str, Any]):
        """
        Log agent request.

        Args:
            input_data: Request input
        """
        self.logger.info(
            f"{self.name} processing request",
            extra={
                "agent": self.name,
                "input_keys": list(input_data.keys()),
            }
        )

    def log_response(self, response: AgentResponse):
        """
        Log agent response.

        Args:
            response: Agent response
        """
        self.logger.info(
            f"{self.name} generated response",
            extra={
                "agent": self.name,
                "confidence": response.confidence,
                "content_length": len(response.content),
            }
        )

    def create_response(
        self,
        content: str,
        metadata: Optional[Dict[str, Any]] = None,
        confidence: Optional[float] = None,
    ) -> AgentResponse:
        """
        Create standardized response.

        Args:
            content: Response content
            metadata: Additional metadata
            confidence: Confidence score

        Returns:
            AgentResponse: Formatted response
        """
        return AgentResponse(
            content=content,
            metadata=metadata,
            confidence=confidence,
            agent_name=self.name,
        )

    def get_info(self) -> Dict[str, Any]:
        """
        Get agent information.

        Returns:
            dict: Agent info
        """
        return {
            "name": self.name,
            "description": self.description,
            "capabilities": self.capabilities,
            "config": self.config.to_dict(),
        }

    def __repr__(self) -> str:
        """String representation."""
        return f"<{self.__class__.__name__}(name='{self.name}')>"


FILE PATH: ./app/repositories/conversation.py
--------------------
"""
Conversation Repository

Data access layer for Conversation model.
"""

from typing import List, Optional
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from app.models.conversation import Conversation, ConversationStatus
from app.repositories.base import BaseRepository


class ConversationRepository(BaseRepository[Conversation]):
    """Conversation repository."""

    def __init__(self, db: AsyncSession):
        """Initialize conversation repository."""
        super().__init__(Conversation, db)

    async def get_by_customer(
        self,
        customer_id: int,
        skip: int = 0,
        limit: int = 100
    ) -> List[Conversation]:
        """
        Get conversations for customer.

        Args:
            customer_id: Customer ID
            skip: Number to skip
            limit: Maximum to return

        Returns:
            List[Conversation]: Customer conversations
        """
        result = await self.db.execute(
            select(Conversation)
            .where(Conversation.customer_id == customer_id)
            .offset(skip)
            .limit(limit)
            .order_by(Conversation.created_at.desc())
        )
        return result.scalars().all()

    async def get_active_conversations(
        self,
        skip: int = 0,
        limit: int = 100
    ) -> List[Conversation]:
        """
        Get active conversations.

        Args:
            skip: Number to skip
            limit: Maximum to return

        Returns:
            List[Conversation]: Active conversations
        """
        result = await self.db.execute(
            select(Conversation)
            .where(Conversation.status == ConversationStatus.ACTIVE)
            .offset(skip)
            .limit(limit)
            .order_by(Conversation.updated_at.desc())
        )
        return result.scalars().all()

    async def get_escalated_conversations(
        self,
        skip: int = 0,
        limit: int = 100
    ) -> List[Conversation]:
        """
        Get escalated conversations.

        Args:
            skip: Number to skip
            limit: Maximum to return

        Returns:
            List[Conversation]: Escalated conversations
        """
        result = await self.db.execute(
            select(Conversation)
            .where(Conversation.status == ConversationStatus.ESCALATED)
            .offset(skip)
            .limit(limit)
            .order_by(Conversation.updated_at.asc())  # Oldest first
        )
        return result.scalars().all()
    async def get_by_ticket_id(self, ticket_id: str) -> Optional[Conversation]:
        """
        [NEW] Fast lookup for when a customer quotes their ticket number.
        Example: repo.get_by_ticket_id("ESC-101-12345")
        """
        query = select(self.model).where(self.model.ticket_id == ticket_id)
        result = await self.session.execute(query)
        return result.scalar_one_or_none()

    async def get_escalated_by_group(self, assigned_group: str) -> List[Conversation]:
        """
        [NEW] Dashboard view for specific teams.
        Example: repo.get_escalated_by_group("Security & Fraud Team")
        """
        query = select(self.model).where(
            self.model.status == ConversationStatus.ESCALATED,
            self.model.assigned_group == assigned_group
        ).order_by(self.model.updated_at.desc()) # Show newest first

        result = await self.session.execute(query)
        return result.scalars().all()


FILE PATH: ./app/repositories/transaction.py
--------------------
from typing import List
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession
from app.models.transaction import Transaction
from app.repositories.base import BaseRepository

class TransactionRepository(BaseRepository[Transaction]):
    def __init__(self, db: AsyncSession):
        super().__init__(Transaction, db)

    async def get_by_account_id(self, account_id: int, limit: int = 50) -> List[Transaction]:
        """Get recent transactions for an account."""
        result = await self.db.execute(
            select(Transaction)
            .where(Transaction.account_id == account_id)
            .order_by(Transaction.date.desc())
            .limit(limit)
        )
        return result.scalars().all()


FILE PATH: ./app/repositories/__init__.py
--------------------
"""
Repositories Package

Data access layer for all models.
"""

from app.repositories.base import BaseRepository
from app.repositories.customer import CustomerRepository
from app.repositories.conversation import ConversationRepository
from app.repositories.message import MessageRepository
from app.repositories.account import AccountRepository
from app.repositories.transaction import TransactionRepository
from app.repositories.product import ProductRepository
from app.repositories.faq import FAQRepository

__all__ = [
    "BaseRepository",
    "CustomerRepository",
    "ConversationRepository",
    "MessageRepository",
    "AccountRepository",
    "TransactionRepository",
    "ProductRepository",
    "FAQRepository"
]


FILE PATH: ./app/repositories/message.py
--------------------
"""
Message Repository

Data access layer for Message model.
"""

from typing import List
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from app.models.message import Message, MessageRole
from app.repositories.base import BaseRepository


class MessageRepository(BaseRepository[Message]):
    """Message repository."""

    def __init__(self, db: AsyncSession):
        """Initialize message repository."""
        super().__init__(Message, db)

    async def get_by_conversation(
        self,
        conversation_id: int,
        skip: int = 0,
        limit: int = 100
    ) -> List[Message]:
        """
        Get messages for conversation.

        Args:
            conversation_id: Conversation ID
            skip: Number to skip
            limit: Maximum to return

        Returns:
            List[Message]: Conversation messages
        """
        result = await self.db.execute(
            select(Message)
            .where(Message.conversation_id == conversation_id)
            .offset(skip)
            .limit(limit)
            .order_by(Message.created_at.asc())  # Chronological order
        )
        return result.scalars().all()

    async def get_requiring_human(
        self,
        skip: int = 0,
        limit: int = 100
    ) -> List[Message]:
        """
        Get messages requiring human intervention.

        Args:
            skip: Number to skip
            limit: Maximum to return

        Returns:
            List[Message]: Messages needing human
        """
        result = await self.db.execute(
            select(Message)
            .where(Message.requires_human == True)
            .offset(skip)
            .limit(limit)
            .order_by(Message.created_at.asc())  # Oldest first
        )
        return result.scalars().all()


FILE PATH: ./app/repositories/product.py
--------------------
"""
Product Repository
Data access layer for Product model.
"""
from typing import List
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession
from app.models.product import Product
from app.repositories.base import BaseRepository

class ProductRepository(BaseRepository[Product]):
    """
    Product repository.
    Handles database operations for financial products.
    """
    def __init__(self, db: AsyncSession):
        super().__init__(Product, db)

    async def get_by_type(self, product_type: str) -> List[Product]:
        """
        Get active products by type (e.g., 'loan', 'savings', 'credit').
        """
        # We filter by type AND ensure the product is active
        result = await self.db.execute(
            select(Product)
            .where(Product.type == product_type)
            .where(Product.is_active == True)
        )
        return result.scalars().all()

    async def get_active_products(self) -> List[Product]:
        """Get all active products."""
        result = await self.db.execute(
            select(Product).where(Product.is_active == True)
        )
        return result.scalars().all()


FILE PATH: ./app/repositories/customer.py
--------------------
"""
Customer Repository

Data access layer for Customer model.
Provides customer-specific query methods.
"""

from typing import Optional, List
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from app.models.customer import Customer
from app.repositories.base import BaseRepository


class CustomerRepository(BaseRepository[Customer]):
    """
    Customer repository.

    Provides customer-specific data access methods.
    """

    def __init__(self, db: AsyncSession):
        """Initialize customer repository."""
        super().__init__(Customer, db)

    async def get_by_email(self, email: str) -> Optional[Customer]:
        """
        Get customer by email.

        Args:
            email: Customer email

        Returns:
            Customer or None: Customer if found
        """
        result = await self.db.execute(
            select(Customer).where(Customer.email == email)
        )
        return result.scalar_one_or_none()

    async def get_by_customer_id(self, customer_id: str) -> Optional[Customer]:
        """
        Get customer by external customer ID.

        Args:
            customer_id: External customer ID

        Returns:
            Customer or None: Customer if found
        """
        result = await self.db.execute(
            select(Customer).where(Customer.customer_id == customer_id)
        )
        return result.scalar_one_or_none()

    async def get_active_customers(
        self,
        skip: int = 0,
        limit: int = 100
    ) -> List[Customer]:
        """
        Get active customers.

        Args:
            skip: Number to skip
            limit: Maximum to return

        Returns:
            List[Customer]: Active customers
        """
        result = await self.db.execute(
            select(Customer)
            .where(Customer.is_active == True)
            .offset(skip)
            .limit(limit)
            .order_by(Customer.created_at.desc())
        )
        return result.scalars().all()

    async def get_vip_customers(
        self,
        skip: int = 0,
        limit: int = 100
    ) -> List[Customer]:
        """
        Get VIP customers.

        Args:
            skip: Number to skip
            limit: Maximum to return

        Returns:
            List[Customer]: VIP customers
        """
        result = await self.db.execute(
            select(Customer)
            .where(Customer.is_vip == True)
            .where(Customer.is_active == True)
            .offset(skip)
            .limit(limit)
            .order_by(Customer.created_at.desc())
        )
        return result.scalars().all()

    async def search_by_name(
        self,
        name: str,
        skip: int = 0,
        limit: int = 100
    ) -> List[Customer]:
        """
        Search customers by name (first or last).

        Args:
            name: Name to search for
            skip: Number to skip
            limit: Maximum to return

        Returns:
            List[Customer]: Matching customers
        """
        search_term = f"%{name}%"

        result = await self.db.execute(
            select(Customer)
            .where(
                (Customer.first_name.ilike(search_term)) |
                (Customer.last_name.ilike(search_term))
            )
            .offset(skip)
            .limit(limit)
            .order_by(Customer.last_name, Customer.first_name)
        )
        return result.scalars().all()


FILE PATH: ./app/repositories/faq.py
--------------------
"""
FAQ Repository
"""
from typing import List
from sqlalchemy import select, or_
from sqlalchemy.ext.asyncio import AsyncSession
from app.models.faq import FAQ
from app.repositories.base import BaseRepository

class FAQRepository(BaseRepository[FAQ]):
    def __init__(self, db: AsyncSession):
        super().__init__(FAQ, db)

    async def search(self, query_text: str) -> List[FAQ]:
        """Simple keyword search."""
        # Clean the query for basic matching
        term = f"%{query_text}%"

        result = await self.db.execute(
            select(FAQ)
            .where(
                or_(
                    FAQ.question.ilike(term),
                    FAQ.keywords.ilike(term),
                    FAQ.category.ilike(term)
                )
            )
            .where(FAQ.is_active == True)
        )
        return result.scalars().all()


FILE PATH: ./app/repositories/base.py
--------------------
"""
Base Repository

Provides common CRUD operations for all repositories.
All model-specific repositories should inherit from this.
"""

from typing import Generic, TypeVar, Type, Optional, List, Dict, Any
from sqlalchemy import select, update, delete, func
from sqlalchemy.ext.asyncio import AsyncSession

from app.models import BaseModel

# Type variable for models
ModelType = TypeVar("ModelType", bound=BaseModel)


class BaseRepository(Generic[ModelType]):
    """
    Base repository with common CRUD operations.

    Provides:
    - Create: Add new records
    - Read: Query records by ID or filters
    - Update: Modify existing records
    - Delete: Remove records (soft delete supported)
    """

    def __init__(self, model: Type[ModelType], db: AsyncSession):
        """
        Initialize repository.

        Args:
            model: SQLAlchemy model class
            db: Database session
        """
        self.model = model
        self.db = db

    # ========================================================================
    # CREATE OPERATIONS
    # ========================================================================

    async def create(self, data: Dict[str, Any]) -> ModelType:
        """
        Create new record.

        Args:
            data: Dictionary with model data

        Returns:
            ModelType: Created instance
        """
        instance = self.model(**data)
        self.db.add(instance)
        await self.db.flush()  # Flush to get ID
        await self.db.refresh(instance)  # Refresh to load relationships
        return instance

    async def create_many(self, data_list: List[Dict[str, Any]]) -> List[ModelType]:
        """
        Create multiple records.

        Args:
            data_list: List of dictionaries with model data

        Returns:
            List[ModelType]: Created instances
        """
        instances = [self.model(**data) for data in data_list]
        self.db.add_all(instances)
        await self.db.flush()

        for instance in instances:
            await self.db.refresh(instance)

        return instances

    # ========================================================================
    # READ OPERATIONS
    # ========================================================================

    async def get_by_id(self, id: int) -> Optional[ModelType]:
        """
        Get record by ID.

        Args:
            id: Record ID

        Returns:
            ModelType or None: Record if found
        """
        result = await self.db.execute(
            select(self.model).where(self.model.id == id)
        )
        return result.scalar_one_or_none()

    async def get_all(
        self,
        skip: int = 0,
        limit: int = 100,
        order_by: str = "id"
    ) -> List[ModelType]:
        """
        Get all records with pagination.

        Args:
            skip: Number of records to skip
            limit: Maximum number of records
            order_by: Column name to order by

        Returns:
            List[ModelType]: List of records
        """
        query = select(self.model).offset(skip).limit(limit)

        # Add ordering
        if hasattr(self.model, order_by):
            query = query.order_by(getattr(self.model, order_by))

        result = await self.db.execute(query)
        return result.scalars().all()

    async def get_by_filters(
        self,
        filters: Dict[str, Any],
        skip: int = 0,
        limit: int = 100
    ) -> List[ModelType]:
        """
        Get records by filters.

        Args:
            filters: Dictionary of column:value filters
            skip: Number of records to skip
            limit: Maximum number of records

        Returns:
            List[ModelType]: Filtered records
        """
        query = select(self.model)

        # Apply filters
        for key, value in filters.items():
            if hasattr(self.model, key):
                query = query.where(getattr(self.model, key) == value)

        query = query.offset(skip).limit(limit)

        result = await self.db.execute(query)
        return result.scalars().all()

    async def count(self, filters: Optional[Dict[str, Any]] = None) -> int:
        """
        Count records.

        Args:
            filters: Optional filters

        Returns:
            int: Number of records
        """
        query = select(func.count(self.model.id))

        if filters:
            for key, value in filters.items():
                if hasattr(self.model, key):
                    query = query.where(getattr(self.model, key) == value)

        result = await self.db.execute(query)
        return result.scalar()

    async def exists(self, id: int) -> bool:
        """
        Check if record exists.

        Args:
            id: Record ID

        Returns:
            bool: True if exists
        """
        query = select(func.count(self.model.id)).where(self.model.id == id)
        result = await self.db.execute(query)
        return result.scalar() > 0

    # ========================================================================
    # UPDATE OPERATIONS
    # ========================================================================

    async def update(self, id: int, data: Dict[str, Any]) -> Optional[ModelType]:
        """
        Update record by ID.

        Args:
            id: Record ID
            data: Dictionary with fields to update

        Returns:
            ModelType or None: Updated record
        """
        # Get existing record
        instance = await self.get_by_id(id)
        if not instance:
            return None

        # Update fields
        for key, value in data.items():
            if hasattr(instance, key):
                setattr(instance, key, value)

        await self.db.flush()
        await self.db.refresh(instance)

        return instance

    async def update_many(
        self,
        filters: Dict[str, Any],
        data: Dict[str, Any]
    ) -> int:
        """
        Update multiple records.

        Args:
            filters: Dictionary of filters
            data: Dictionary with fields to update

        Returns:
            int: Number of updated records
        """
        query = update(self.model)

        # Apply filters
        for key, value in filters.items():
            if hasattr(self.model, key):
                query = query.where(getattr(self.model, key) == value)

        query = query.values(**data)

        result = await self.db.execute(query)
        return result.rowcount

    # ========================================================================
    # DELETE OPERATIONS
    # ========================================================================

    async def delete(self, id: int) -> bool:
        """
        Delete record by ID.

        Args:
            id: Record ID

        Returns:
            bool: True if deleted
        """
        instance = await self.get_by_id(id)
        if not instance:
            return False

        await self.db.delete(instance)
        await self.db.flush()

        return True

    async def delete_many(self, filters: Dict[str, Any]) -> int:
        """
        Delete multiple records.

        Args:
            filters: Dictionary of filters

        Returns:
            int: Number of deleted records
        """
        query = delete(self.model)

        # Apply filters
        for key, value in filters.items():
            if hasattr(self.model, key):
                query = query.where(getattr(self.model, key) == value)

        result = await self.db.execute(query)
        return result.rowcount


FILE PATH: ./app/repositories/account.py
--------------------
from typing import List, Optional
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession
from app.models.account import Account
from app.repositories.base import BaseRepository

class AccountRepository(BaseRepository[Account]):
    def __init__(self, db: AsyncSession):
        super().__init__(Account, db)

    async def get_by_account_number(self, account_number: str) -> Optional[Account]:
        """Get account by account number."""
        result = await self.db.execute(select(Account).where(Account.account_number == account_number))
        return result.scalar_one_or_none()

    async def get_by_customer_id(self, customer_id: str) -> List[Account]:
        """Get all accounts for a customer."""
        result = await self.db.execute(select(Account).where(Account.customer_id == customer_id))
        return result.scalars().all()


FILE PATH: ./app/models/conversation.py
--------------------
"""
Conversation Model

Represents a conversation between a customer and the AI support system.
Links customers to messages and tracks conversation state.
"""

from sqlalchemy import Column, String, Integer, ForeignKey, Text, Enum, Index
from sqlalchemy.orm import relationship
from typing import List
import enum

from app.models import BaseModel


# ============================================================================
# ENUMS
# ============================================================================

class ConversationStatus(str, enum.Enum):
    """Conversation status enumeration."""

    ACTIVE = "active"          # Conversation ongoing
    RESOLVED = "resolved"      # Issue resolved
    ESCALATED = "escalated"    # Escalated to human agent
    CLOSED = "closed"          # Conversation closed


class ConversationChannel(str, enum.Enum):
    """Conversation channel enumeration."""

    WEB = "web"                # Web chat
    MOBILE = "mobile"          # Mobile app
    API = "api"                # API integration
    WHATSAPP = "whatsapp"      # WhatsApp integration
    SMS = "sms"                # SMS integration


# ============================================================================
# CONVERSATION MODEL
# ============================================================================

class Conversation(BaseModel):
    """
    Conversation model.

    Represents a conversation between a customer and the AI system.
    Contains conversation metadata, status, and relationships to
    customer and messages.
    """

    __tablename__ = "conversations"

    # ========================================================================
    # FOREIGN KEYS
    # ========================================================================

    customer_id = Column(
        Integer,
        ForeignKey("customers.id", ondelete="CASCADE"),
        nullable=False,
        index=True,
        comment="Foreign key to customer",
    )

    # ========================================================================
    # CONVERSATION METADATA
    # ========================================================================

    title = Column(
        String(200),
        nullable=False,
        comment="Conversation title/subject",
    )

    status = Column(
        Enum(ConversationStatus),
        default=ConversationStatus.ACTIVE,
        nullable=False,
        index=True,
        comment="Current conversation status",
    )

    channel = Column(
        Enum(ConversationChannel),
        default=ConversationChannel.WEB,
        nullable=False,
        index=True,
        comment="Communication channel",
    )

    # ========================================================================
    # CONVERSATION DETAILS
    # ========================================================================

    summary = Column(
        Text,
        nullable=True,
        comment="AI-generated conversation summary",
    )

    intent = Column(
        String(100),
        nullable=True,
        index=True,
        comment="Detected customer intent",
    )

    sentiment = Column(
        String(50),
        nullable=True,
        comment="Overall conversation sentiment",
    )

    # ========================================================================
    # METRICS
    # ========================================================================

    message_count = Column(
        Integer,
        default=0,
        nullable=False,
        comment="Total number of messages",
    )

    escalation_reason = Column(
        Text,
        nullable=True,
        comment="Reason for escalation (if escalated)",
    )

    priority = Column(
        String(20),
        nullable=True,
        comment="Priority of escalation (if escalated)",
    )

    # [FIX] Add new columns for escalation details
    ticket_id = Column(String, index=True, nullable=True)
    assigned_group = Column(String, nullable=True)

    # ========================================================================
    # RELATIONSHIPS
    # ========================================================================

    customer = relationship(
        "Customer",
        back_populates="conversations",
        lazy="selectin",  # Eager load customer
    )

    messages = relationship(
        "Message",
        back_populates="conversation",
        lazy="selectin",  # Eager load messages
        cascade="all, delete-orphan",  # Delete messages when conversation deleted
        order_by="Message.created_at",  # Order messages by timestamp
    )

    # ========================================================================
    # INDEXES
    # ========================================================================

    __table_args__ = (
        # Index for customer's conversations
        Index("idx_customer_status", "customer_id", "status"),
        # Index for channel + status queries
        Index("idx_channel_status", "channel", "status"),
        # Index for intent-based filtering
        Index("idx_intent", "intent"),
    )

    # ========================================================================
    # PROPERTIES
    # ========================================================================

    @property
    def is_active(self) -> bool:
        """
        Check if conversation is active.

        Returns:
            bool: True if status is ACTIVE
        """
        return self.status == ConversationStatus.ACTIVE

    @property
    def is_resolved(self) -> bool:
        """
        Check if conversation is resolved.

        Returns:
            bool: True if status is RESOLVED
        """
        return self.status == ConversationStatus.RESOLVED

    @property
    def is_escalated(self) -> bool:
        """
        Check if conversation is escalated.

        Returns:
            bool: True if status is ESCALATED
        """
        return self.status == ConversationStatus.ESCALATED

    # ========================================================================
    # METHODS
    # ========================================================================

    def __repr__(self) -> str:
        """String representation of conversation."""
        return (
            f"<Conversation(id={self.id}, "
            f"customer_id={self.customer_id}, "
            f"status='{self.status.value}', "
            f"messages={self.message_count})>"
        )

    def to_dict(self, include_messages: bool = False, include_customer: bool = False) -> dict:
        """
        Convert conversation to dictionary.

        Args:
            include_messages: Whether to include messages
            include_customer: Whether to include customer data

        Returns:
            dict: Conversation data
        """
        data = {
            "id": self.id,
            "customer_id": self.customer_id,
            "title": self.title,
            "status": self.status.value,
            "channel": self.channel.value,
            "summary": self.summary,
            "intent": self.intent,
            "sentiment": self.sentiment,
            "message_count": self.message_count,
            "escalation_reason": self.escalation_reason,
            "priority": self.priority,
            "created_at": self.created_at.isoformat() if self.created_at else None,
            "updated_at": self.updated_at.isoformat() if self.updated_at else None,
        }

        if include_customer and self.customer:
            data["customer"] = self.customer.to_dict(include_conversations=False)

        if include_messages:
            data["messages"] = [
                msg.to_dict()
                for msg in self.messages
            ]

        return data

    def add_message(self) -> None:
        """
        Increment message count.

        Called when a new message is added to conversation.
        """
        self.message_count += 1

    def mark_resolved(self, summary: str = None) -> None:
        """
        Mark conversation as resolved.

        Args:
            summary: Optional resolution summary
        """
        self.status = ConversationStatus.RESOLVED
        if summary:
            self.summary = summary

    def escalate(self, reason: str, priority: str = None, assigned_group: str = None, ticket_id: str = None) -> None:
        """
        Escalate conversation to human agent.

        Args:
            reason: Reason for escalation
            priority: Priority of escalation (optional)
        """
        self.status = ConversationStatus.ESCALATED
        self.escalation_reason = reason
        if priority:
            self.priority = priority
        self.assigned_group = assigned_group
        self.ticket_id = ticket_id

    def close(self) -> None:
        """Close conversation."""
        self.status = ConversationStatus.CLOSED


FILE PATH: ./app/models/transaction.py
--------------------

"""
Transaction Model
Represents financial transactions on accounts.
"""
from sqlalchemy import Column, String, Numeric, ForeignKey, DateTime
from sqlalchemy.orm import relationship
from datetime import datetime
from app.models import BaseModel

class Transaction(BaseModel):
    __tablename__ = "transactions"

    account_id = Column(ForeignKey("accounts.id"), nullable=False, index=True)
    reference = Column(String(50), unique=True, nullable=False, index=True)
    amount = Column(Numeric(15, 2), nullable=False)
    currency = Column(String(3), default="GBP", nullable=False)
    description = Column(String(255), nullable=False)
    category = Column(String(50), nullable=True, index=True)
    date = Column(DateTime, default=datetime.utcnow, nullable=False, index=True)
    merchant_name = Column(String(100), nullable=True)

    # Relationships
    account = relationship("Account", back_populates="transactions")

    def __repr__(self):
        return f"<Transaction({self.reference}, amount={self.amount})>"


FILE PATH: ./app/models/__init__.py
--------------------
"""
Database Models

This module provides base model classes and common utilities
for all database models in the application.
"""

from datetime import datetime,timezone
from sqlalchemy import Column, Integer, DateTime, Boolean
from typing import Any

from app.database import Base


# ============================================================================
# TIMESTAMP MIXIN
# ============================================================================

class TimestampMixin:
    """
    Mixin to add created_at and updated_at timestamps to models.

    Automatically sets timestamps on creation and update.
    """

    created_at = Column(
        DateTime(timezone=True),
        default=datetime.now(timezone.utc),
        nullable=False,
        comment="Record creation timestamp (UTC)",
    )

    updated_at = Column(
        DateTime(timezone=True),
        default=datetime.now(timezone.utc),
        onupdate=datetime.now(timezone.utc),
        nullable=False,
        comment="Record last update timestamp (UTC)",
    )


# ============================================================================
# SOFT DELETE MIXIN
# ============================================================================

class SoftDeleteMixin:
    """
    Mixin to add soft delete functionality to models.

    Instead of deleting records, marks them as deleted with timestamp.
    """

    deleted_at = Column(
        DateTime(timezone=True),
        nullable=True,
        default=None,
        comment="Record deletion timestamp (NULL if not deleted)",
    )

    is_deleted = Column(
        Boolean,
        default=False,
        nullable=False,
        index=True,  # Index for query performance
        comment="Soft delete flag",
    )

    def soft_delete(self) -> None:
        """Mark record as deleted without removing from database."""
        self.is_deleted = True
        self.deleted_at = datetime.now(datetime.timezone.utc)

    def restore(self) -> None:
        """Restore a soft-deleted record."""
        self.is_deleted = False
        self.deleted_at = None


# ============================================================================
# BASE MODEL
# ============================================================================

class BaseModel(Base, TimestampMixin):
    """
    Abstract base model with common fields.

    Provides:
    - Auto-incrementing ID
    - Created/updated timestamps
    - String representation
    - Dictionary conversion

    All application models should inherit from this.
    """

    __abstract__ = True  # Don't create table for this class

    id = Column(
        Integer,
        primary_key=True,
        autoincrement=True,
        comment="Primary key",
    )

    def __repr__(self) -> str:
        """
        String representation of model instance.

        Returns:
            str: Model representation
        """
        return f"<{self.__class__.__name__}(id={self.id})>"

    def to_dict(self, exclude: set = None) -> dict[str, Any]:
        """
        Convert model instance to dictionary.

        Args:
            exclude: Set of column names to exclude

        Returns:
            dict: Model data as dictionary
        """
        exclude = exclude or set()

        return {
            column.name: getattr(self, column.name)
            for column in self.__table__.columns
            if column.name not in exclude
        }

    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> "BaseModel":
        """
        Create model instance from dictionary.

        Args:
            data: Dictionary with model data

        Returns:
            BaseModel: New model instance
        """
        return cls(**data)


# ============================================================================
# EXAMPLE MODEL (for reference)
# ============================================================================

# Example of how to use BaseModel:
#
# from app.models import BaseModel
# from sqlalchemy import Column, String
#
# class Customer(BaseModel):
#     __tablename__ = "customers"
#
#     name = Column(String(100), nullable=False)
#     email = Column(String(255), unique=True, nullable=False)
#     phone = Column(String(20), nullable=True)
#
# This automatically includes:
# - id (primary key)
# - created_at (timestamp)
# - updated_at (timestamp)
# - __repr__() method
# - to_dict() method
# - from_dict() class method


from app.models.customer import Customer
from app.models.conversation import Conversation, ConversationStatus, ConversationChannel
from app.models.message import Message, MessageRole
from app.models.product import Product
from app.models.account import Account, AccountType, AccountStatus
from app.models.transaction import Transaction

__all__ = [
    "Base",
    "Customer",
    "Conversation",
    "ConversationStatus",
    "ConversationChannel",
    "Message",
    "MessageRole",
    "TimestampMixin",
    "SoftDeleteMixin",
    "BaseModel",
    "Product",
    "Account",
    "AccountType",
    "AccountStatus",
    "Transaction"
]


FILE PATH: ./app/models/message.py
--------------------
"""
Message Model

Represents a single message in a conversation between customer and AI system.
Tracks message content, sender, and metadata.
"""

from sqlalchemy import Column, String, Integer, ForeignKey, Text, Enum, Boolean, Index
from sqlalchemy.orm import relationship
import enum

from app.models import BaseModel


# ============================================================================
# ENUMS
# ============================================================================

class MessageRole(str, enum.Enum):
    """Message sender role enumeration."""

    CUSTOMER = "customer"      # Message from customer
    AGENT = "agent"            # Message from AI agent
    SYSTEM = "system"          # System message
    HUMAN_AGENT = "human_agent"  # Message from human agent


# ============================================================================
# MESSAGE MODEL
# ============================================================================

class Message(BaseModel):
    """
    Message model.

    Represents a single message in a conversation.
    Contains message content, role, and metadata.
    """

    __tablename__ = "messages"

    # ========================================================================
    # FOREIGN KEYS
    # ========================================================================

    conversation_id = Column(
        Integer,
        ForeignKey("conversations.id", ondelete="CASCADE"),
        nullable=False,
        index=True,
        comment="Foreign key to conversation",
    )

    # ========================================================================
    # MESSAGE CONTENT
    # ========================================================================

    role = Column(
        Enum(MessageRole),
        nullable=False,
        index=True,
        comment="Message sender role",
    )

    content = Column(
        Text,
        nullable=False,
        comment="Message content/text",
    )

    # ========================================================================
    # METADATA
    # ========================================================================

    agent_name = Column(
        String(100),
        nullable=True,
        comment="Name of AI agent that generated message (if role=agent)",
    )

    intent = Column(
        String(100),
        nullable=True,
        index=True,
        comment="Detected intent in customer message",
    )

    sentiment = Column(
        String(50),
        nullable=True,
        comment="Message sentiment (positive, negative, neutral)",
    )

    confidence_score = Column(
        Integer,
        nullable=True,
        comment="Confidence score (0-100) for intent detection",
    )

    # ========================================================================
    # FLAGS
    # ========================================================================

    is_error = Column(
        Boolean,
        default=False,
        nullable=False,
        comment="Whether message represents an error",
    )

    requires_human = Column(
        Boolean,
        default=False,
        nullable=False,
        index=True,
        comment="Whether message requires human agent intervention",
    )

    # ========================================================================
    # ADDITIONAL DATA
    # ========================================================================

    metadata_json = Column(
        Text,
        nullable=True,
        comment="Additional metadata as JSON string",
    )

    # ========================================================================
    # RELATIONSHIPS
    # ========================================================================

    conversation = relationship(
        "Conversation",
        back_populates="messages",
        lazy="selectin",  # Eager load conversation
    )

    # ========================================================================
    # INDEXES
    # ========================================================================

    __table_args__ = (
        # Index for conversation's messages (most common query)
        Index("idx_conversation_created", "conversation_id", "created_at"),
        # Index for role-based filtering
        Index("idx_role", "role"),
        # Index for messages requiring human intervention
        Index("idx_requires_human", "requires_human"),
        # Index for intent-based analytics
        Index("idx_conversation_intent", "conversation_id", "intent"),
    )

    # ========================================================================
    # PROPERTIES
    # ========================================================================

    @property
    def is_customer_message(self) -> bool:
        """
        Check if message is from customer.

        Returns:
            bool: True if role is CUSTOMER
        """
        return self.role == MessageRole.CUSTOMER

    @property
    def is_agent_message(self) -> bool:
        """
        Check if message is from AI agent.

        Returns:
            bool: True if role is AGENT
        """
        return self.role == MessageRole.AGENT

    @property
    def is_system_message(self) -> bool:
        """
        Check if message is system message.

        Returns:
            bool: True if role is SYSTEM
        """
        return self.role == MessageRole.SYSTEM

    @property
    def content_length(self) -> int:
        """
        Get message content length.

        Returns:
            int: Character count
        """
        return len(self.content) if self.content else 0

    # ========================================================================
    # METHODS
    # ========================================================================

    def __repr__(self) -> str:
        """String representation of message."""
        content_preview = self.content[:50] + "..." if len(self.content) > 50 else self.content
        return (
            f"<Message(id={self.id}, "
            f"conversation_id={self.conversation_id}, "
            f"role='{self.role.value}', "
            f"content='{content_preview}')>"
        )

    def to_dict(self, include_conversation: bool = False) -> dict:
        """
        Convert message to dictionary.

        Args:
            include_conversation: Whether to include conversation data

        Returns:
            dict: Message data
        """
        data = {
            "id": self.id,
            "conversation_id": self.conversation_id,
            "role": self.role.value,
            "content": self.content,
            "agent_name": self.agent_name,
            "intent": self.intent,
            "sentiment": self.sentiment,
            "confidence_score": self.confidence_score,
            "is_error": self.is_error,
            "requires_human": self.requires_human,
            "metadata_json": self.metadata_json,
            "created_at": self.created_at.isoformat() if self.created_at else None,
            "updated_at": self.updated_at.isoformat() if self.updated_at else None,
        }

        if include_conversation and self.conversation:
            data["conversation"] = self.conversation.to_dict(
                include_messages=False,
                include_customer=False
            )

        return data


FILE PATH: ./app/models/product.py
--------------------
"""
Product Model
Represents financial products (Savings, Credit Cards, Loans).
"""
from sqlalchemy import Column, String, Numeric, Text, Boolean, JSON
from app.models import BaseModel

class Product(BaseModel):
    __tablename__ = "products"

    name = Column(String(100), nullable=False, index=True)
    type = Column(String(50), nullable=False, index=True, comment="savings, credit, loan")
    description = Column(Text, nullable=True)
    interest_rate = Column(Numeric(5, 4), nullable=True, comment="Annual interest rate (decimal)")
    features = Column(JSON, default=list, comment="List of product features")
    requirements = Column(JSON, default=dict, comment="Eligibility requirements")
    is_active = Column(Boolean, default=True, index=True)

    def __repr__(self):
        return f"<Product(name='{self.name}', type='{self.type}')>"


FILE PATH: ./app/models/customer.py
--------------------
"""
Customer Model

Represents a customer in the FCA financial services support system.
Stores customer information and links to conversations.
"""

from sqlalchemy import Column, String, Boolean, Text, Index
from sqlalchemy.orm import relationship
from typing import List

from app.models import BaseModel


class Customer(BaseModel):
    """
    Customer model.

    Represents a customer who interacts with the support system.
    Includes personal information, contact details, and relationship
    to conversations.
    """

    __tablename__ = "customers"

    # ========================================================================
    # PERSONAL INFORMATION
    # ========================================================================

    first_name = Column(
        String(100),
        nullable=False,
        comment="Customer first name",
    )

    last_name = Column(
        String(100),
        nullable=False,
        comment="Customer last name",
    )

    email = Column(
        String(255),
        unique=True,
        nullable=False,
        index=True,  # Index for fast lookup
        comment="Customer email address (unique)",
    )

    phone = Column(
        String(20),
        nullable=True,
        comment="Customer phone number",
    )

    # ========================================================================
    # ACCOUNT INFORMATION
    # ========================================================================

    customer_id = Column(
        String(50),
        unique=True,
        nullable=False,
        index=True,  # Index for fast lookup
        comment="External customer ID from core banking system",
    )

    account_number = Column(
        String(50),
        nullable=True,
        comment="Primary account number",
    )

    # ========================================================================
    # STATUS FLAGS
    # ========================================================================

    is_active = Column(
        Boolean,
        default=True,
        nullable=False,
        index=True,
        comment="Whether customer account is active",
    )

    is_verified = Column(
        Boolean,
        default=False,
        nullable=False,
        comment="Whether customer identity is verified",
    )

    is_vip = Column(
        Boolean,
        default=False,
        nullable=False,
        index=True,
        comment="VIP customer flag (premium service)",
    )

    # ========================================================================
    # ADDITIONAL INFORMATION
    # ========================================================================

    notes = Column(
        Text,
        nullable=True,
        comment="Internal notes about customer",
    )

    # ========================================================================
    # RELATIONSHIPS
    # ========================================================================

    conversations = relationship(
        "Conversation",
        back_populates="customer",
        lazy="selectin",  # Eager load conversations
        cascade="all, delete-orphan",  # Delete conversations when customer deleted
    )

    # ========================================================================
    # INDEXES
    # ========================================================================

    __table_args__ = (
        # Composite index for name searches
        Index("idx_customer_name", "first_name", "last_name"),
        # Index for active VIP customers (common query)
        Index("idx_active_vip", "is_active", "is_vip"),
    )

    # ========================================================================
    # PROPERTIES
    # ========================================================================

    @property
    def full_name(self) -> str:
        """
        Get customer's full name.

        Returns:
            str: First name + last name
        """
        return f"{self.first_name} {self.last_name}"

    @property
    def conversation_count(self) -> int:
        """
        Get number of conversations.

        Returns:
            int: Count of conversations
        """
        return len(self.conversations)

    # ========================================================================
    # METHODS
    # ========================================================================

    def __repr__(self) -> str:
        """String representation of customer."""
        return f"<Customer(id={self.id}, name='{self.full_name}', email='{self.email}')>"

    def to_dict(self, include_conversations: bool = False) -> dict:
        """
        Convert customer to dictionary.

        Args:
            include_conversations: Whether to include conversations

        Returns:
            dict: Customer data
        """
        data = {
            "id": self.id,
            "customer_id": self.customer_id,
            "first_name": self.first_name,
            "last_name": self.last_name,
            "full_name": self.full_name,
            "email": self.email,
            "phone": self.phone,
            "account_number": self.account_number,
            "is_active": self.is_active,
            "is_verified": self.is_verified,
            "is_vip": self.is_vip,
            "notes": self.notes,
            "created_at": self.created_at.isoformat() if self.created_at else None,
            "updated_at": self.updated_at.isoformat() if self.updated_at else None,
        }

        if include_conversations:
            data["conversations"] = [
                conv.to_dict(include_messages=False)
                for conv in self.conversations
            ]
            data["conversation_count"] = self.conversation_count

        return data


FILE PATH: ./app/models/faq.py
--------------------
"""
FAQ Model
"""
from sqlalchemy import Column, Integer, String, Boolean, Text
from app.database import Base

class FAQ(Base):
    __tablename__ = "faqs"

    id = Column(Integer, primary_key=True, index=True)
    question = Column(String, index=True, nullable=False)
    answer = Column(Text, nullable=False)
    category = Column(String, index=True)  # e.g., 'security', 'account'
    keywords = Column(String)  # Comma-separated for simple search
    is_active = Column(Boolean, default=True)


FILE PATH: ./app/models/account.py
--------------------
"""
Account Model
Represents a customer's bank account.
"""
from sqlalchemy import Column, String, Numeric, ForeignKey, Enum as SAEnum
from sqlalchemy.orm import relationship
import enum
from app.models import BaseModel

class AccountType(str, enum.Enum):
    CURRENT = "current"
    SAVINGS = "savings"
    LOAN = "loan"
    CREDIT = "credit"

class AccountStatus(str, enum.Enum):
    ACTIVE = "active"
    FROZEN = "frozen"
    CLOSED = "closed"

class Account(BaseModel):
    __tablename__ = "accounts"

    account_number = Column(String(20), unique=True, nullable=False, index=True)
    customer_id = Column(String(50), nullable=False, index=True, comment="External Link")
    product_id = Column(ForeignKey("products.id"), nullable=True)

    type = Column(SAEnum(AccountType), nullable=False, default=AccountType.CURRENT)
    status = Column(SAEnum(AccountStatus), nullable=False, default=AccountStatus.ACTIVE)
    currency = Column(String(3), default="GBP", nullable=False)
    balance = Column(Numeric(15, 2), default=0.00, nullable=False)
    available_balance = Column(Numeric(15, 2), default=0.00, nullable=False)

    # Relationships
    product = relationship("Product")
    # Using string reference to avoid circular imports
    transactions = relationship("Transaction", back_populates="account", cascade="all, delete-orphan")

    def __repr__(self):
        return f"<Account({self.account_number}, type={self.type}, balance={self.balance})>"


FILE PATH: ./app/api/__init__.py
--------------------
from app.api.routes.messages import router as messages_router

__all__ = ["messages_router"]


FILE PATH: ./app/api/routes/messages.py
--------------------
"""
Message Router API

FastAPI endpoints for agent message processing.
Handles customer messages and returns coordinated responses.
"""

from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
from typing import Optional, Dict, Any
import logging

from app.coordinator.agent_coordinator import AgentCoordinator

router = APIRouter(prefix="/api/v1", tags=["messages"])
coordinator = AgentCoordinator()
logger = logging.getLogger(__name__)


# ============================================================================
# REQUEST/RESPONSE MODELS
# ============================================================================

class MessageRequest(BaseModel):
    """Incoming message request."""
    message: str
    customer_id: int
    conversation_id: int


class AgentMetadata(BaseModel):
    """Agent response metadata."""
    agent: str
    intent: str
    confidence: float
    turn_count: int
    escalated: bool
    escalation_id: Optional[str] = None


class MessageResponse(BaseModel):
    """API response."""
    response: str
    metadata: Dict[str, Any]
    status: str = "success"


class ConversationHistoryItem(BaseModel):
    """Single conversation turn."""
    timestamp: str
    message: str
    agent: str
    intent: str
    response: str


class ConversationHistory(BaseModel):
    """Conversation history response."""
    conversation_id: int
    history: list[ConversationHistoryItem]


class ConversationStats(BaseModel):
    """Conversation statistics."""
    total_conversations: int
    total_messages: int
    escalated_conversations: int
    avg_messages_per_conversation: float
    agent_distribution: Dict[str, int]
    intent_distribution: Dict[str, int]


# ============================================================================
# MESSAGE ENDPOINTS
# ============================================================================

@router.post("/messages/process", response_model=MessageResponse)
async def process_message(request: MessageRequest) -> MessageResponse:
    """
    Process customer message through agent system.

    Args:
        request: MessageRequest with message, customer_id, conversation_id

    Returns:
        MessageResponse with agent response and metadata

    Example:
        POST /api/v1/messages/process
        {
            "message": "What's my account balance?",
            "customer_id": 101,
            "conversation_id": 1
        }
    """
    try:
        logger.info(f"Processing message for customer {request.customer_id}")

        # Process through coordinator
        response = await coordinator.process_message(
            message=request.message,
            customer_id=request.customer_id,
            conversation_id=request.conversation_id,
        )

        return MessageResponse(
            response=response["response"],
            metadata={
                "agent": response["agent"],
                "intent": response["intent"],
                "confidence": response["confidence"],
                "turn_count": response["turn_count"],
                "escalated": response["escalated"],
                "escalation_id": response.get("escalation_id"),
            }
        )

    except ValueError as e:
        logger.error(f"Validation error: {e}")
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        logger.error(f"Processing error: {e}")
        raise HTTPException(status_code=500, detail="Error processing message")


# ============================================================================
# CONVERSATION ENDPOINTS
# ============================================================================

@router.get("/conversations/{conversation_id}/history", response_model=ConversationHistory)
async def get_conversation_history(
    conversation_id: int,
    limit: int = 10,
) -> ConversationHistory:
    """
    Get conversation history.

    Args:
        conversation_id: ID of conversation
        limit: Max messages to return

    Returns:
        ConversationHistory with message turns
    """
    try:
        history = coordinator.get_conversation_history(conversation_id, limit)

        if history is None:
            raise HTTPException(status_code=404, detail="Conversation not found")

        return ConversationHistory(
            conversation_id=conversation_id,
            history=history,
        )

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"History retrieval error: {e}")
        raise HTTPException(status_code=500, detail="Error retrieving history")


@router.get("/customers/{customer_id}/conversations")
async def get_customer_conversations(customer_id: int) -> Dict[str, Any]:
    """
    Get all conversations for a customer.

    Args:
        customer_id: Customer ID

    Returns:
        List of conversations with metadata
    """
    try:
        conversations = coordinator.get_all_conversations(customer_id)

        return {
            "customer_id": customer_id,
            "conversations": [
                {
                    "conversation_id": conv.conversation_id,
                    "message_count": len(conv.messages),
                    "created_at": conv.created_at.isoformat(),
                    "is_escalated": conv.is_escalated,
                    "escalation_id": conv.escalation_id,
                    "last_intent": conv.last_intent,
                }
                for conv in conversations
            ]
        }

    except Exception as e:
        logger.error(f"Error retrieving conversations: {e}")
        raise HTTPException(status_code=500, detail="Error retrieving conversations")


# ============================================================================
# ESCALATION ENDPOINTS
# ============================================================================

@router.get("/escalations")
async def get_escalated_conversations() -> Dict[str, Any]:
    """
    Get all escalated conversations.

    Returns:
        List of escalated conversations with details
    """
    try:
        escalated = coordinator.get_escalated_conversations()

        return {
            "escalated_count": len(escalated),
            "escalations": escalated,
        }

    except Exception as e:
        logger.error(f"Error retrieving escalations: {e}")
        raise HTTPException(status_code=500, detail="Error retrieving escalations")


@router.post("/escalations/{conversation_id}/resolve")
async def resolve_escalation(
    conversation_id: int,
    resolution_notes: str,
) -> Dict[str, Any]:
    """
    Mark escalation as resolved.

    Args:
        conversation_id: Conversation ID
        resolution_notes: Resolution details

    Returns:
        Success confirmation
    """
    try:
        resolved = coordinator.resolve_escalation(conversation_id, resolution_notes)

        if not resolved:
            raise HTTPException(status_code=404, detail="Conversation not escalated")

        return {
            "status": "resolved",
            "conversation_id": conversation_id,
        }

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error resolving escalation: {e}")
        raise HTTPException(status_code=500, detail="Error resolving escalation")


# ============================================================================
# STATISTICS ENDPOINTS
# ============================================================================

@router.get("/statistics", response_model=ConversationStats)
async def get_statistics() -> ConversationStats:
    """
    Get coordinator statistics.

    Returns:
        ConversationStats with metrics
    """
    try:
        stats = coordinator.get_statistics()

        return ConversationStats(**stats)

    except Exception as e:
        logger.error(f"Error retrieving statistics: {e}")
        raise HTTPException(status_code=500, detail="Error retrieving statistics")


@router.get("/info")
async def get_coordinator_info() -> Dict[str, Any]:
    """
    Get coordinator information.

    Returns:
        Coordinator capabilities and status
    """
    try:
        info = coordinator.get_coordinator_info()
        return info

    except Exception as e:
        logger.error(f"Error retrieving info: {e}")
        raise HTTPException(status_code=500, detail="Error retrieving info")


# ============================================================================
# HEALTH CHECK
# ============================================================================

@router.get("/health")
async def health_check() -> Dict[str, str]:
    """
    Health check endpoint.

    Returns:
        Status confirmation
    """
    return {
        "status": "healthy",
        "service": "message-router",
        "version": "1.0.0",
    }


FILE PATH: ./app/services/faq_service.py
--------------------
"""
FAQ Service
"""
from typing import List, Optional
from sqlalchemy.ext.asyncio import AsyncSession
from app.services.base import BaseService
from app.repositories.faq import FAQRepository
from app.models.faq import FAQ

class FAQService(BaseService):
    def __init__(self, db: AsyncSession = None):
        super().__init__(db)
        if self.db:
            self.repo = FAQRepository(self.db)

    async def __aenter__(self):
        await super().__aenter__()
        self.repo = FAQRepository(self.db)
        return self

    async def search_faqs(self, query: str) -> List[FAQ]:
        """Search for relevant FAQs."""
        return await self.repo.search(query)


FILE PATH: ./app/services/transaction_service.py
--------------------
from typing import List
from sqlalchemy.ext.asyncio import AsyncSession
from app.services.base import BaseService
from app.repositories.transaction import TransactionRepository
from app.models.transaction import Transaction

class TransactionService(BaseService):
    def __init__(self, db: AsyncSession = None):
        super().__init__(db)
        if self.db:
            self.repo = TransactionRepository(self.db)

    async def __aenter__(self):
        await super().__aenter__()
        self.repo = TransactionRepository(self.db)
        return self

    async def get_transactions_by_account(self, account_id: int, limit: int = 10) -> List[Transaction]:
        """Get recent transactions for an account."""
        return await self.repo.get_by_account_id(account_id, limit)


FILE PATH: ./app/services/conversation.py
--------------------
"""
Conversation Service

Business logic for conversation operations.
"""

from typing import Optional, List
from sqlalchemy.ext.asyncio import AsyncSession

from app.services.base import BaseService
from app.repositories.conversation import ConversationRepository
from app.repositories.customer import CustomerRepository
from app.models.conversation import Conversation, ConversationStatus, ConversationChannel


class ConversationService(BaseService):
    """
    Conversation service.

    Handles conversation business logic and operations.
    """

    def __init__(self, db: AsyncSession = None):
        """Initialize conversation service."""
        super().__init__(db)
# ðŸ‘‡ THIS WAS LIKELY MISSING OR BROKEN ðŸ‘‡
        if self.db:
            self.repo = ConversationRepository(self.db)
        else:
            self.repo = None

    async def __aenter__(self):
        """Enter async context."""
        await super().__aenter__()
        self.repo = ConversationRepository(self.db)
        self.customer_repo = CustomerRepository(self.db)
        return self

    async def start_conversation(
        self,
        customer_id: int,
        title: str,
        channel: ConversationChannel = ConversationChannel.WEB
    ) -> Conversation:
        """
        Start new conversation.

        Args:
            customer_id: Customer ID
            title: Conversation title
            channel: Communication channel

        Returns:
            Conversation: Created conversation

        Raises:
            ValueError: If customer not found
        """
        # Verify customer exists
        customer = await self.customer_repo.get_by_id(customer_id)
        if not customer:
            raise ValueError(f"Customer {customer_id} not found")

        # Create conversation
        data = {
            "customer_id": customer_id,
            "title": title,
            "channel": channel,
            "status": ConversationStatus.ACTIVE,
            "message_count": 0,
        }

        conversation = await self.repo.create(data)
        await self.commit()

        return conversation

    async def get_conversation(self, conversation_id: int) -> Optional[Conversation]:
        """
        Get conversation by ID.

        Args:
            conversation_id: Conversation ID

        Returns:
            Conversation or None: Conversation if found
        """
        return await self.repo.get_by_id(conversation_id)

    async def get_customer_conversations(
        self,
        customer_id: int,
        page: int = 1,
        page_size: int = 100
    ) -> List[Conversation]:
        """
        Get conversations for customer.

        Args:
            customer_id: Customer ID
            page: Page number (1-indexed)
            page_size: Items per page

        Returns:
            List[Conversation]: Customer conversations
        """
        skip = (page - 1) * page_size
        return await self.repo.get_by_customer(
            customer_id,
            skip=skip,
            limit=page_size
        )

    async def resolve_conversation(
        self,
        conversation_id: int,
        summary: str = None
    ) -> Optional[Conversation]:
        """
        Mark conversation as resolved.

        Args:
            conversation_id: Conversation ID
            summary: Resolution summary

        Returns:
            Conversation or None: Resolved conversation
        """
        conversation = await self.repo.get_by_id(conversation_id)
        if not conversation:
            return None

        conversation.mark_resolved(summary=summary)
        await self.commit()

        return conversation

    async def escalate_conversation(
        self,
        conversation_id: int,
        reason: str,
        priority: str,
        assigned_group: str = None,  # [FIX] New Arg
        ticket_id: str = None        # [FIX] New Arg
    ) -> Optional[Conversation]:
        """Escalate with full tracking details."""

        conversation = await self.repo.get_by_id(conversation_id)

        if conversation:
            # Pass all data to the model
            conversation.escalate(
                reason=reason,
                priority=priority,
                assigned_group=assigned_group,
                ticket_id=ticket_id
            )

            await self.repo.session.commit()
            await self.repo.session.refresh(conversation)

        return conversation


FILE PATH: ./app/services/account_service.py
--------------------
from typing import List, Optional
from sqlalchemy.ext.asyncio import AsyncSession
from app.services.base import BaseService
from app.repositories.account import AccountRepository
from app.models.account import Account

class AccountService(BaseService):
    def __init__(self, db: AsyncSession = None):
        super().__init__(db)
        if self.db:
            self.repo = AccountRepository(self.db)

    async def __aenter__(self):
        await super().__aenter__()
        self.repo = AccountRepository(self.db)
        return self

    async def get_accounts_by_customer(self, customer_id: str) -> List[Account]:
        """Get all accounts for a customer ID."""
        return await self.repo.get_by_customer_id(customer_id)

    async def get_account_balance(self, account_number: str) -> Optional[float]:
        """Get balance for a specific account."""
        account = await self.repo.get_by_account_number(account_number)
        return float(account.balance) if account else None


FILE PATH: ./app/services/__init__.py
--------------------
"""
Services Package

Business logic layer for all models.
"""

from app.services.base import BaseService
from app.services.customer import CustomerService
from app.services.conversation import ConversationService
from app.services.message import MessageService
from app.services.product_service import ProductService
from app.services.account_service import AccountService
from app.services.transaction_service import TransactionService
from app.services.faq_service import FAQService

__all__ = [
    "BaseService",
    "CustomerService",
    "ConversationService",
    "MessageService",
    "ProductService",
    "AccountService",
    "TransactionService",
    "FAQService"
]


FILE PATH: ./app/services/message.py
--------------------
"""
Message Service

Business logic for message operations.
"""

from typing import Optional, List
from sqlalchemy.ext.asyncio import AsyncSession

from app.services.base import BaseService
from app.repositories.message import MessageRepository
from app.repositories.conversation import ConversationRepository
from app.models.message import Message, MessageRole


class MessageService(BaseService):
    """
    Message service.

    Handles message business logic and operations.
    """

    def __init__(self, db: AsyncSession = None):
        """Initialize message service."""
        super().__init__(db)
        self.repo = None
        self.conversation_repo = None

    async def __aenter__(self):
        """Enter async context."""
        await super().__aenter__()
        self.repo = MessageRepository(self.db)
        self.conversation_repo = ConversationRepository(self.db)
        return self

    async def add_message(
        self,
        conversation_id: int,
        role: MessageRole,
        content: str,
        agent_name: str = None,
        intent: str = None,
        sentiment: str = None,
        confidence_score: int = None
    ) -> Message:
        """
        Add message to conversation.

        Args:
            conversation_id: Conversation ID
            role: Message role
            content: Message content
            agent_name: AI agent name (if role=AGENT)
            intent: Detected intent
            sentiment: Message sentiment
            confidence_score: Confidence score (0-100)

        Returns:
            Message: Created message

        Raises:
            ValueError: If conversation not found
        """
        # Verify conversation exists
        conversation = await self.conversation_repo.get_by_id(conversation_id)
        if not conversation:
            raise ValueError(f"Conversation {conversation_id} not found")

        # Create message
        data = {
            "conversation_id": conversation_id,
            "role": role,
            "content": content,
            "agent_name": agent_name,
            "intent": intent,
            "sentiment": sentiment,
            "confidence_score": confidence_score,
        }

        message = await self.repo.create(data)

        # Update conversation message count
        conversation.add_message()

        await self.commit()

        return message

    async def get_conversation_messages(
        self,
        conversation_id: int,
        page: int = 1,
        page_size: int = 100
    ) -> List[Message]:
        """
        Get messages for conversation.

        Args:
            conversation_id: Conversation ID
            page: Page number (1-indexed)
            page_size: Items per page

        Returns:
            List[Message]: Conversation messages
        """
        skip = (page - 1) * page_size
        return await self.repo.get_by_conversation(
            conversation_id,
            skip=skip,
            limit=page_size
        )


FILE PATH: ./app/services/customer.py
--------------------
"""
Customer Service

Business logic for customer operations.
"""

from typing import Optional, List, Dict, Any
from sqlalchemy.ext.asyncio import AsyncSession

from app.services.base import BaseService
from app.repositories.customer import CustomerRepository
from app.models.customer import Customer


class CustomerService(BaseService):
    """
    Customer service.

    Handles customer business logic and operations.
    """

    def __init__(self, db: AsyncSession = None):
        """Initialize customer service."""
        super().__init__(db)
        # Initialize repo immediately if DB session exists
        if self.db:
            self.repo = CustomerRepository(self.db)
        else:
            self.repo = None

    async def __aenter__(self):
        """Enter async context."""
        await super().__aenter__()
        self.repo = CustomerRepository(self.db)
        return self

    # ========================================================================
    # CREATE OPERATIONS
    # ========================================================================

    async def create_customer(
        self,
        customer_id: str,
        first_name: str,
        last_name: str,
        email: str,
        phone: str = None,
        account_number: str = None,
        is_vip: bool = False
    ) -> Customer:
        """
        Create new customer.

        Args:
            customer_id: External customer ID
            first_name: First name
            last_name: Last name
            email: Email address
            phone: Phone number (optional)
            account_number: Account number (optional)
            is_vip: VIP status (default False)

        Returns:
            Customer: Created customer

        Raises:
            ValueError: If email already exists
        """
        # Check if email exists
        existing = await self.repo.get_by_email(email)
        if existing:
            raise ValueError(f"Customer with email {email} already exists")

        # Check if customer_id exists
        existing = await self.repo.get_by_customer_id(customer_id)
        if existing:
            raise ValueError(f"Customer with ID {customer_id} already exists")

        # Create customer
        data = {
            "customer_id": customer_id,
            "first_name": first_name,
            "last_name": last_name,
            "email": email,
            "phone": phone,
            "account_number": account_number,
            "is_vip": is_vip,
            "is_active": True,
            "is_verified": False,
        }

        customer = await self.repo.create(data)
        await self.commit()

        return customer

    # ========================================================================
    # READ OPERATIONS
    # ========================================================================

    async def get_customer(self, customer_id: int) -> Optional[Customer]:
        """
        Get customer by ID.

        Args:
            customer_id: Customer ID

        Returns:
            Customer or None: Customer if found
        """
        return await self.repo.get_by_id(customer_id)

    async def get_customer_by_email(self, email: str) -> Optional[Customer]:
        """
        Get customer by email.

        Args:
            email: Email address

        Returns:
            Customer or None: Customer if found
        """
        return await self.repo.get_by_email(email)

    async def get_active_customers(
        self,
        page: int = 1,
        page_size: int = 100
    ) -> List[Customer]:
        """
        Get active customers with pagination.

        Args:
            page: Page number (1-indexed)
            page_size: Items per page

        Returns:
            List[Customer]: Active customers
        """
        skip = (page - 1) * page_size
        return await self.repo.get_active_customers(skip=skip, limit=page_size)

    async def search_customers(
        self,
        name: str,
        page: int = 1,
        page_size: int = 100
    ) -> List[Customer]:
        """
        Search customers by name.

        Args:
            name: Name to search for
            page: Page number (1-indexed)
            page_size: Items per page

        Returns:
            List[Customer]: Matching customers
        """
        skip = (page - 1) * page_size
        return await self.repo.search_by_name(name, skip=skip, limit=page_size)

    # ========================================================================
    # UPDATE OPERATIONS
    # ========================================================================

    async def update_customer(
        self,
        customer_id: int,
        data: Dict[str, Any]
    ) -> Optional[Customer]:
        """
        Update customer.

        Args:
            customer_id: Customer ID
            data: Fields to update

        Returns:
            Customer or None: Updated customer
        """
        customer = await self.repo.update(customer_id, data)
        if customer:
            await self.commit()
        return customer

    async def verify_customer(self, customer_id: int) -> Optional[Customer]:
        """
        Verify customer identity.

        Args:
            customer_id: Customer ID

        Returns:
            Customer or None: Verified customer
        """
        return await self.update_customer(customer_id, {"is_verified": True})

    async def make_vip(self, customer_id: int) -> Optional[Customer]:
        """
        Upgrade customer to VIP.

        Args:
            customer_id: Customer ID

        Returns:
            Customer or None: VIP customer
        """
        return await self.update_customer(customer_id, {"is_vip": True})

    async def deactivate_customer(self, customer_id: int) -> Optional[Customer]:
        """
        Deactivate customer account.

        Args:
            customer_id: Customer ID

        Returns:
            Customer or None: Deactivated customer
        """
        return await self.update_customer(customer_id, {"is_active": False})

    # ========================================================================
    # DELETE OPERATIONS
    # ========================================================================

    async def delete_customer(self, customer_id: int) -> bool:
        """
        Delete customer (and all conversations/messages via CASCADE).

        Args:
            customer_id: Customer ID

        Returns:
            bool: True if deleted
        """
        success = await self.repo.delete(customer_id)
        if success:
            await self.commit()
        return success


FILE PATH: ./app/services/product_service.py
--------------------
"""
Product Service
Business logic for product operations.
"""
from typing import List
from sqlalchemy.ext.asyncio import AsyncSession
from app.services.base import BaseService
from app.repositories.product import ProductRepository
from app.models.product import Product

class ProductService(BaseService):
    """
    Product service.
    Exposes product data to agents.
    """
    def __init__(self, db: AsyncSession = None):
        super().__init__(db)
        if self.db:
            self.repo = ProductRepository(self.db)

    async def __aenter__(self):
        await super().__aenter__()
        self.repo = ProductRepository(self.db)
        return self

    async def get_all_products(self) -> List[Product]:
        """Get all available products."""
        return await self.repo.get_active_products()

    async def get_products_by_category(self, category: str) -> List[Product]:
        """
        Get products for a specific category.
        Agent maps 'loan_inquiry' -> 'loan' before calling this.
        """
        return await self.repo.get_by_type(category)


FILE PATH: ./app/services/base.py
--------------------
"""
Base Service

Provides common service functionality.
All model-specific services should inherit from this.
"""

from sqlalchemy.ext.asyncio import AsyncSession
from app.database import AsyncSessionLocal


class BaseService:
    """
    Base service class.

    Provides database session management and common functionality.
    """

    def __init__(self, db: AsyncSession = None):
        """
        Initialize service.

        Args:
            db: Optional database session (created if not provided)
        """
        self.db = db
        self._owns_session = db is None

    async def __aenter__(self):
        """Enter async context."""
        if self._owns_session:
            self.db = AsyncSessionLocal()
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """Exit async context."""
        if self._owns_session and self.db:
            if exc_type is not None:
                await self.db.rollback()
            await self.db.close()

    async def commit(self):
        """Commit current transaction."""
        await self.db.commit()

    async def rollback(self):
        """Rollback current transaction."""
        await self.db.rollback()


FILE PATH: ./tests/conftest.py
--------------------
"""
Pytest Configuration and Fixtures

This module provides test configuration and reusable fixtures
for all test modules.
"""
import pytest_asyncio
import pytest
import asyncio
from typing import AsyncGenerator, Generator
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession, async_sessionmaker
from httpx import AsyncClient

from app.main import app
from app.database import Base
from app.config import settings

# ============================================================================
# PYTEST CONFIGURATION
# ============================================================================

# Use async event loop for all tests
@pytest.fixture(scope="session")
def event_loop() -> Generator:
    """
    Create an instance of the default event loop for the test session.
    """
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)
    yield loop
    loop.close()

# ============================================================================
# DATABASE FIXTURES
# ============================================================================

@pytest_asyncio.fixture(scope="session")
async def test_engine():
    """
    Create test database engine.
    Uses separate test database to avoid affecting development data.
    """
    # Use test database URL (ensure this replaces the DB name correctly)
    # This replaces 'fca_support' with 'fca_support_test' in the connection string
    test_db_url = settings.database_url.replace("fca_support", "fca_support_test")

    # Create test engine
    engine = create_async_engine(
        test_db_url,
        echo=False,  # Don't log SQL in tests
        future=True,
    )

    # Create tables
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.drop_all) # Start clean
        await conn.run_sync(Base.metadata.create_all)

    yield engine

    # Drop tables and dispose engine
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.drop_all)

    await engine.dispose()


@pytest_asyncio.fixture
async def db_session(test_engine) -> AsyncGenerator[AsyncSession, None]:
    """
    Create database session for testing.

    Yields:
        AsyncSession: Database session
    """
    # Create session maker
    async_session = async_sessionmaker(
        test_engine,
        class_=AsyncSession,
        expire_on_commit=False,
    )

    async with async_session() as session:
        yield session
        await session.rollback()

    # CRITICAL FIX: Clean up data after each test
    # Because service methods call .commit(), data persists even after session.rollback()
    # We must explicitly delete data to prevent "already exists" errors in subsequent tests
    async with test_engine.begin() as conn:
        # Delete data from all tables in reverse order of dependency
        for table in reversed(Base.metadata.sorted_tables):
            await conn.execute(table.delete())


# ============================================================================
# APPLICATION FIXTURES
# ============================================================================

@pytest_asyncio.fixture
async def client():
    """
    Create an async test client for testing FastAPI endpoints.
    """
    async with AsyncClient(app=app, base_url="http://test") as ac:
        yield ac

# ============================================================================
# UTILITY FIXTURES
# ============================================================================

@pytest.fixture
def anyio_backend():
    """
    Specify async backend for anyio.
    """
    return "asyncio"


FILE PATH: ./tests/__init__.py
--------------------
"""
Test Package

This package contains all test modules for the FCA Multi-Agent Support System.
"""


FILE PATH: ./tests/test_customer.py
--------------------
"""
Customer Tests

Tests for Customer model and CustomerService.
"""

import pytest
from sqlalchemy.ext.asyncio import AsyncSession

from app.services.customer import CustomerService
from app.models.customer import Customer


# ============================================================================
# CREATE TESTS
# ============================================================================

@pytest.mark.asyncio
async def test_create_customer(db_session: AsyncSession):
    """Test creating a customer."""
    service = CustomerService(db=db_session)

    customer = await service.create_customer(
        customer_id="CUST-003",
        first_name="John",
        last_name="Smith",
        email="john4@example.com",
        phone="+44123456789"
    )

    assert customer.id is not None
    assert customer.customer_id == "CUST-003"
    assert customer.first_name == "John"
    assert customer.last_name == "Smith"
    assert customer.email == "john4@example.com"
    assert customer.phone == "+44123456789"
    assert customer.is_active is True
    assert customer.is_verified is False
    assert customer.is_vip is False


@pytest.mark.asyncio
async def test_create_customer_duplicate_email(db_session: AsyncSession):
    """Test creating customer with duplicate email raises error."""
    service = CustomerService(db=db_session)

    # Create first customer
    await service.create_customer(
        customer_id="CUST-003",
        first_name="John",
        last_name="Smith",
        email="john4@example.com"
    )

    # Try to create second customer with same email
    with pytest.raises(ValueError, match="already exists"):
        await service.create_customer(
            customer_id="CUST-003",
            first_name="Jane",
            last_name="Doe",
            email="john4@example.com"
        )


# ============================================================================
# READ TESTS
# ============================================================================

@pytest.mark.asyncio
async def test_get_customer(db_session: AsyncSession):
    """Test getting customer by ID."""
    service = CustomerService(db=db_session)

    # Create customer
    created = await service.create_customer(
        customer_id="CUST-006",
        first_name="John",
        last_name="Smith",
        email="john6@example.com"
    )

    # Get customer
    customer = await service.get_customer(created.id)

    assert customer is not None
    assert customer.id == created.id
    assert customer.email == "john6@example.com"


@pytest.mark.asyncio
async def test_get_customer_by_email(db_session: AsyncSession):
    """Test getting customer by email."""
    service = CustomerService(db=db_session)

    # Create customer
    await service.create_customer(
        customer_id="CUST-001",
        first_name="John",
        last_name="Smith",
        email="john@example.com"
    )

    # Get by email
    customer = await service.get_customer_by_email("john@example.com")

    assert customer is not None
    assert customer.email == "john@example.com"


@pytest.mark.asyncio
async def test_search_customers(db_session: AsyncSession):
    """Test searching customers by name."""
    service = CustomerService(db=db_session)

    # Create customers
    await service.create_customer(
        customer_id="CUST-001",
        first_name="John",
        last_name="Smith",
        email="john@example.com"
    )

    await service.create_customer(
        customer_id="CUST-002",
        first_name="Jane",
        last_name="Johnson",
        email="jane@example.com"
    )

    # Search for "john"
    results = await service.search_customers("john")

    assert len(results) == 2  # Matches "John" and "Johnson"
    assert any(c.first_name == "John" for c in results)
    assert any(c.last_name == "Johnson" for c in results)


# ============================================================================
# UPDATE TESTS
# ============================================================================

@pytest.mark.asyncio
async def test_update_customer(db_session: AsyncSession):
    """Test updating customer."""
    service = CustomerService(db=db_session)

    # Create customer
    customer = await service.create_customer(
        customer_id="CUST-001",
        first_name="John",
        last_name="Smith",
        email="john@example.com"
    )

    # Update customer
    updated = await service.update_customer(
        customer.id,
        {"first_name": "Jane", "phone": "+44123456789"}
    )

    assert updated is not None
    assert updated.first_name == "Jane"
    assert updated.phone == "+44123456789"
    assert updated.last_name == "Smith"  # Unchanged


@pytest.mark.asyncio
async def test_verify_customer(db_session: AsyncSession):
    """Test verifying customer."""
    service = CustomerService(db=db_session)

    # Create customer
    customer = await service.create_customer(
        customer_id="CUST-001",
        first_name="John",
        last_name="Smith",
        email="john@example.com"
    )

    assert customer.is_verified is False

    # Verify customer
    verified = await service.verify_customer(customer.id)

    assert verified is not None
    assert verified.is_verified is True


@pytest.mark.asyncio
async def test_make_vip(db_session: AsyncSession):
    """Test making customer VIP."""
    service = CustomerService(db=db_session)

    # Create customer
    customer = await service.create_customer(
        customer_id="CUST-001",
        first_name="John",
        last_name="Smith",
        email="john@example.com"
    )

    assert customer.is_vip is False

    # Make VIP
    vip = await service.make_vip(customer.id)

    assert vip is not None
    assert vip.is_vip is True


# ============================================================================
# DELETE TESTS
# ============================================================================

@pytest.mark.asyncio
async def test_delete_customer(db_session: AsyncSession):
    """Test deleting customer."""
    service = CustomerService(db=db_session)

    # Create customer
    customer = await service.create_customer(
        customer_id="CUST-001",
        first_name="John",
        last_name="Smith",
        email="john@example.com"
    )

    customer_id = customer.id

    # Delete customer
    success = await service.delete_customer(customer_id)

    assert success is True

    # Verify deleted
    deleted = await service.get_customer(customer_id)
    assert deleted is None


# ============================================================================
# PROPERTY TESTS
# ============================================================================

@pytest.mark.asyncio
async def test_customer_full_name(db_session: AsyncSession):
    """Test customer full_name property."""
    service = CustomerService(db=db_session)

    customer = await service.create_customer(
        customer_id="CUST-001",
        first_name="John",
        last_name="Smith",
        email="john@example.com"
    )

    assert customer.full_name == "John Smith"


FILE PATH: ./tests/test_health.py
--------------------
"""
Health Check Endpoint Tests

Tests for health check, ping, readiness, and liveness endpoints.
"""

import pytest
from httpx import AsyncClient


# ============================================================================
# HEALTH CHECK TESTS
# ============================================================================

@pytest.mark.asyncio
async def test_health_check_success(client: AsyncClient):
    """
    Test health check endpoint returns success.

    Verifies:
    - Status code 200 OK
    - Response structure
    - All required fields present
    - Health status is healthy
    """
    response = await client.get("/api/v1/health")

    # Check status code
    assert response.status_code == 200

    # Parse response
    data = response.json()

    # Check required fields
    assert "status" in data
    assert "timestamp" in data
    assert "version" in data
    assert "environment" in data
    assert "checks" in data

    # Check status is healthy
    assert data["status"] == "healthy"

    # Check version
    assert data["version"] == "0.1.0"

    # Check checks structure
    checks = data["checks"]
    assert "database" in checks
    assert "redis" in checks
    assert "groq_ai" in checks

    # Check database check
    db_check = checks["database"]
    assert "status" in db_check
    assert "type" in db_check
    assert db_check["type"] == "postgresql"


@pytest.mark.asyncio
async def test_health_check_database_status(client: AsyncClient):
    """
    Test health check includes database status.

    Verifies:
    - Database check exists
    - Database status is healthy
    - Pool size is reported
    """
    response = await client.get("/api/v1/health")
    data = response.json()

    db_check = data["checks"]["database"]

    # Check database status
    assert db_check["status"] == "healthy"
    assert "pool_size" in db_check
    assert db_check["pool_size"] > 0


# ============================================================================
# PING TESTS
# ============================================================================

@pytest.mark.asyncio
async def test_ping_success(client: AsyncClient):
    """
    Test ping endpoint returns success.

    Verifies:
    - Status code 200 OK
    - Response structure
    - Quick response time
    """
    response = await client.get("/api/v1/ping")

    # Check status code
    assert response.status_code == 200

    # Parse response
    data = response.json()

    # Check required fields
    assert "status" in data
    assert "timestamp" in data

    # Check status is ok
    assert data["status"] == "ok"


# ============================================================================
# READINESS TESTS
# ============================================================================

@pytest.mark.asyncio
async def test_readiness_success(client: AsyncClient):
    """
    Test readiness endpoint returns ready.

    Verifies:
    - Status code 200 OK
    - Response indicates ready
    """
    response = await client.get("/api/v1/ready")

    # Check status code
    assert response.status_code == 200

    # Parse response
    data = response.json()

    # Check status
    assert "status" in data
    assert data["status"] == "ready"


# ============================================================================
# LIVENESS TESTS
# ============================================================================

@pytest.mark.asyncio
async def test_liveness_success(client: AsyncClient):
    """
    Test liveness endpoint returns alive.

    Verifies:
    - Status code 200 OK
    - Response indicates alive
    """
    response = await client.get("/api/v1/live")

    # Check status code
    assert response.status_code == 200

    # Parse response
    data = response.json()

    # Check status
    assert "status" in data
    assert data["status"] == "alive"


# ============================================================================
# ROOT ENDPOINT TESTS
# ============================================================================

@pytest.mark.asyncio
async def test_root_endpoint(client: AsyncClient):
    """
    Test root endpoint returns API information.

    Verifies:
    - Status code 200 OK
    - Response structure
    - API metadata present
    """
    response = await client.get("/")

    # Check status code
    assert response.status_code == 200

    # Parse response
    data = response.json()

    # Check required fields
    assert "name" in data
    assert "version" in data
    assert "status" in data
    assert "environment" in data

    # Check values
    assert data["status"] == "operational"
    assert data["version"] == "0.1.0"


FILE PATH: ./tests/integration/test_integration.py
--------------------
"""
Integration Tests

End-to-end testing of multi-agent system.
Tests workflow, coordinator, and API together.
"""

import asyncio
import pytest
from app.workflows.message_workflow import MessageWorkflow
from app.coordinator.agent_coordinator import AgentCoordinator


@pytest.fixture
def coordinator():
    """Provide coordinator instance."""
    return AgentCoordinator()


@pytest.fixture
def workflow():
    """Provide workflow instance."""
    return MessageWorkflow()


class TestAccountInquiry:
    """Test account inquiry flows."""

    @pytest.mark.asyncio
    async def test_balance_inquiry(self, coordinator):
        """Test balance inquiry."""
        response = await coordinator.process_message(
            message="What's my account balance?",
            customer_id=101,
            conversation_id=1,
        )

        assert response["agent"] == "account"
        assert response["intent"] == "account_inquiry"
        assert response["confidence"] > 0.8
        assert "balance" in response["response"].lower()

    @pytest.mark.asyncio
    async def test_transaction_history(self, coordinator):
        """Test transaction history request."""
        response = await coordinator.process_message(
            message="Show me my recent transactions",
            customer_id=101,
            conversation_id=1,
        )

        assert response["agent"] == "account"
        assert "transaction" in response["response"].lower()


class TestGeneralInquiry:
    """Test general inquiry flows."""

    @pytest.mark.asyncio
    async def test_faq_match(self, coordinator):
        """Test FAQ matching."""
        response = await coordinator.process_message(
            message="How do I open an account?",
            customer_id=102,
            conversation_id=2,
        )

        assert response["agent"] == "general"
        assert response["intent"] == "general_inquiry"
        assert "account" in response["response"].lower()

    @pytest.mark.asyncio
    async def test_support_info(self, coordinator):
        """Test support information."""
        response = await coordinator.process_message(
            message="How do I contact support?",
            customer_id=102,
            conversation_id=2,
        )

        assert response["agent"] == "general"
        assert "support" in response["response"].lower()


class TestEscalation:
    """Test escalation flows."""

    @pytest.mark.asyncio
    async def test_complaint_escalation(self, coordinator):
        """Test complaint escalation."""
        response = await coordinator.process_message(
            message="I'm not happy with your service!",
            customer_id=103,
            conversation_id=3,
        )

        assert response["agent"] == "human"
        assert response["intent"] == "complaint"
        assert response["escalated"]
        assert response["escalation_id"] is not None

    @pytest.mark.asyncio
    async def test_urgent_escalation(self, coordinator):
        """Test urgent escalation."""
        response = await coordinator.process_message(
            message="My card was stolen! I need immediate help!",
            customer_id=104,
            conversation_id=4,
        )

        assert response["agent"] == "human"
        assert response["escalated"]


class TestMultiTurn:
    """Test multi-turn conversations."""

    @pytest.mark.asyncio
    async def test_conversation_history(self, coordinator):
        """Test multi-turn conversation."""
        conv_id = 5
        customer_id = 105

        # Turn 1
        response1 = await coordinator.process_message(
            message="What's my balance?",
            customer_id=customer_id,
            conversation_id=conv_id,
        )
        assert response1["turn_count"] == 1

        # Turn 2
        response2 = await coordinator.process_message(
            message="Show transactions",
            customer_id=customer_id,
            conversation_id=conv_id,
        )
        assert response2["turn_count"] == 2

        # Turn 3
        response3 = await coordinator.process_message(
            message="I need a statement",
            customer_id=customer_id,
            conversation_id=conv_id,
        )
        assert response3["turn_count"] == 3

        # Verify history
        history = coordinator.get_conversation_history(conv_id)
        assert len(history) == 3


class TestStatistics:
    """Test statistics tracking."""

    @pytest.mark.asyncio
    async def test_agent_distribution(self, coordinator):
        """Test agent distribution statistics."""

        # Create messages for different agents
        await coordinator.process_message(
            message="What's my balance?",
            customer_id=101,
            conversation_id=10,
        )

        await coordinator.process_message(
            message="How do I open account?",
            customer_id=102,
            conversation_id=11,
        )

        await coordinator.process_message(
            message="I'm unhappy",
            customer_id=103,
            conversation_id=12,
        )

        # Check statistics
        stats = coordinator.get_statistics()
        assert stats["total_conversations"] > 0
        assert "account" in stats["agent_distribution"]
        assert "general" in stats["agent_distribution"]
        assert "human" in stats["agent_distribution"]



FILE PATH: ./docs/architecture.md
--------------------
# System Architecture

## Overview

The FCA Multi-Agent Support System is a production-ready AI customer support application built for UK financial services. It uses a multi-agent architecture with LangGraph orchestration to provide compliant, intelligent responses.

## High-Level Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Client    â”‚
â”‚  (Browser)  â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚ HTTP/HTTPS
       â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           FastAPI Application            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚         API Layer (Routers)        â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚               â†“                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚      Service Layer (Business)      â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚               â†“                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚    LangGraph Workflow Engine       â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚ â”‚
â”‚  â”‚  â”‚    Multi-Agent System        â”‚  â”‚ â”‚
â”‚  â”‚  â”‚  â€¢ Intent Classifier         â”‚  â”‚ â”‚
â”‚  â”‚  â”‚  â€¢ FAQ Retriever             â”‚  â”‚ â”‚
â”‚  â”‚  â”‚  â€¢ Account Lookup            â”‚  â”‚ â”‚
â”‚  â”‚  â”‚  â€¢ Payment Handler           â”‚  â”‚ â”‚
â”‚  â”‚  â”‚  â€¢ Compliance Checker        â”‚  â”‚ â”‚
â”‚  â”‚  â”‚  â€¢ Escalation Agent          â”‚  â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚               â†“                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚      Database Layer (ORM)          â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ PostgreSQL  â”‚  â”‚  Redis  â”‚ â”‚
â”‚  â”‚  Database   â”‚  â”‚  Cache  â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚                  â”‚
       â†“                  â†“
   Persistent         In-Memory
     Storage          Storage
```

## Component Details

### API Layer
- **FastAPI Routers** - HTTP endpoint definitions
- **Pydantic Models** - Request/response validation
- **Middleware** - Cross-cutting concerns (logging, CORS, rate limiting)

### Service Layer
- **ConversationService** - Orchestrates agent workflow
- **HealthService** - System health monitoring

### LangGraph Workflow
- **State Machine** - Defines conversation flow
- **Agent Routing** - Routes messages to appropriate agents
- **Error Handling** - Graceful degradation

### Database Layer
- **SQLAlchemy ORM** - Object-relational mapping
- **Async Support** - Non-blocking database operations
- **Alembic Migrations** - Database version control

### External Services
- **Groq AI API** - LLM inference
- **PostgreSQL** - Persistent data storage
- **Redis** - Caching layer

## Data Flow

1. **User sends message** â†’ FastAPI receives HTTP request
2. **Request validation** â†’ Pydantic validates input
3. **Service layer** â†’ ConversationService handles request
4. **Database lookup** â†’ Fetch customer/conversation
5. **LangGraph workflow** â†’ Execute agent pipeline
6. **Agent processing** â†’ Each agent processes in sequence
7. **Database save** â†’ Store results
8. **Response** â†’ Return to user

## Technology Stack

| Layer | Technology | Version | Purpose |
|-------|-----------|---------|---------|
| **Web Framework** | FastAPI | 0.104.1 | API endpoints |
| **ASGI Server** | Uvicorn | 0.24.0 | HTTP server |
| **Database** | PostgreSQL | 15 | Persistent storage |
| **ORM** | SQLAlchemy | 2.0.23 | Database abstraction |
| **Cache** | Redis | 7 | In-memory cache |
| **AI Framework** | LangChain | 0.1.0 | LLM orchestration |
| **Workflow** | LangGraph | 0.0.20 | Agent routing |
| **LLM Provider** | Groq AI | - | Fast inference |
| **Testing** | pytest | 7.4.3 | Test framework |
| **Containerization** | Docker | - | Deployment |

## Design Patterns

### Multi-Agent Pattern
Each agent specializes in one task:
- **Single Responsibility** - One agent, one purpose
- **Composability** - Agents combine flexibly
- **Testability** - Test agents independently

### Service Layer Pattern
Separates business logic from API:
- **Reusability** - Services used by multiple endpoints
- **Testability** - Test services without HTTP
- **Maintainability** - Change business logic independently

### Repository Pattern
Database abstraction:
- **Abstraction** - Hide database details
- **Testability** - Mock database easily
- **Flexibility** - Switch databases if needed

## Security Considerations

- âœ… Environment variables for secrets
- âœ… Non-root Docker user
- âœ… Input validation (Pydantic)
- âœ… SQL injection prevention (ORM)
- âœ… Rate limiting
- âœ… CORS configuration
- âœ… Request size limits
- âœ… Audit logging

## Scalability

### Horizontal Scaling
- Stateless application (scale containers)
- Database connection pooling
- Redis for shared state

### Performance Optimizations
- Async I/O (FastAPI + asyncpg)
- Database indexes
- Redis caching
- Connection pooling

## Deployment Architecture

```
Internet
   â†“
Load Balancer
   â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ App 1   â”‚ App 2   â”‚ App 3   â”‚  (Docker containers)
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”´â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”´â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â†“
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚ PostgreSQL â”‚
     â”‚  (Primary) â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Future Enhancements

- [ ] WebSocket support for real-time chat
- [ ] Admin dashboard
- [ ] Advanced analytics
- [ ] Kubernetes deployment
- [ ] Multi-region support
- [ ] Vector database for semantic search


FILE PATH: ./scripts/20260114_add_priority_to_conversations.py
--------------------
import os

# ---------------- CONFIGURATION ----------------
output_filename = "full_project_context.txt"

# 1. File types to include
# Added .yml and .yaml explicitly for CI files
valid_extensions = ['.py', '.toml', '.yml', '.yaml', '.json', '.md', '.sh']

# 2. Specific files to always include (no extension)
valid_filenames = ['Dockerfile', 'Makefile', '.env.example', 'ci.yml']

# 3. Folders to IGNORE (Skip these)
# We exclude '.git' (history) but we do NOT exclude '.github' (workflows)
ignore_folders = {
    'venv', '__pycache__', 'node_modules', '.idea', '.vscode',
    '.git', '.pytest_cache', 'dist', 'build'
}
# -----------------------------------------------

def pack_project():
    print(f"ðŸ“¦ Packing project context...")

    with open(output_filename, "w", encoding="utf-8") as outfile:
        # Header
        outfile.write(f"PROJECT CONTEXT: {os.path.basename(os.getcwd())}\n")
        outfile.write("INCLUDES: Python, Docker, Configs, and CI/CD Workflows.\n")
        outfile.write("="*50 + "\n\n")

        file_count = 0

        for root, dirs, files in os.walk("."):
            # 1. Filter directories in-place
            # This ensures we don't walk into venv or .git,
            # but we DO walk into .github since it's not in the ignore list.
            dirs[:] = [d for d in dirs if d not in ignore_folders]

            for file in files:
                is_valid_ext = any(file.endswith(ext) for ext in valid_extensions)
                is_valid_name = file in valid_filenames

                if is_valid_ext or is_valid_name:
                    file_path = os.path.join(root, file)

                    # Write File Header
                    outfile.write(f"FILE PATH: {file_path}\n")
                    outfile.write("-" * 20 + "\n")

                    try:
                        with open(file_path, "r", encoding="utf-8") as infile:
                            outfile.write(infile.read())
                            outfile.write("\n\n") # Buffer between files
                            file_count += 1
                    except Exception as e:
                        outfile.write(f"[Error reading file: {e}]\n\n")

    print(f"âœ… Success! Packed {file_count} files (including workflows).")
    print(f"ðŸ“„ Upload '{output_filename}' to Gemini.")

if __name__ == "__main__":
    pack_project()


FILE PATH: ./.github/workflows/ci.yml
--------------------
name: CI Pipeline

# Trigger on push to any branch and pull requests
on:
  push:
    branches: ["**"]
  pull_request:
    branches: [main, develop]
  workflow_dispatch:  # Allow manual trigger

# Cancel in-progress runs if new commit pushed
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # ============================================================================
  # TEST JOB
  # ============================================================================
  
  test:
    name: Test (Python ${{ matrix.python-version }})
    runs-on: ubuntu-latest
    
    strategy:
      matrix:
        python-version: ["3.11"]
    
    # Service containers for database
    services:
      postgres:
        image: postgres:15-alpine
        env:
          POSTGRES_USER: test_user
          POSTGRES_PASSWORD: test_password
          POSTGRES_DB: test_db
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
      
      redis:
        image: redis:7-alpine
        ports:
          - 6379:6379
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    
    steps:
      # ========================================================================
      # SETUP
      # ========================================================================
      
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}
          cache: 'pip'
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
      
      # ========================================================================
      # LINTING & FORMATTING
      # ========================================================================
      
      - name: Check code formatting with black
        run: |
          black --check app/ tests/
      
      - name: Lint with flake8
        run: |
          # Stop build if there are Python syntax errors or undefined names
          flake8 app/ tests/ --count --select=E9,F63,F7,F82 --show-source --statistics
          # Exit-zero treats all errors as warnings
          flake8 app/ tests/ --count --exit-zero --max-complexity=10 --max-line-length=100 --statistics
      
      - name: Type check with mypy
        run: |
          mypy app/ --ignore-missing-imports
        continue-on-error: true  # Don't fail on type errors yet
      
      # ========================================================================
      # TESTING
      # ========================================================================
      
      - name: Run tests with pytest
        env:
          DATABASE_URL: postgresql+asyncpg://test_user:test_password@localhost:5432/test_db
          REDIS_URL: redis://localhost:6379/0
          GROQ_API_KEY: test_key
          SECRET_KEY: test-secret-key
          ENVIRONMENT: test
        run: |
          pytest tests/ -v --cov=app --cov-report=term-missing --cov-report=xml
      
      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          file: ./coverage.xml
          fail_ci_if_error: false
  
  # ============================================================================
  # BUILD JOB
  # ============================================================================
  
  build:
    name: Build Docker Image
    runs-on: ubuntu-latest
    needs: test  # Only build if tests pass
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Build Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: false
          tags: fca-support:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
      
      - name: Test Docker image
        run: |
          docker run --rm fca-support:${{ github.sha }} python -c "import app; print('âœ“ Import successful')"

FILE PATH: ./alembic/env.py
--------------------
"""
Alembic Environment Configuration

Configures Alembic to work with our SQLAlchemy models and async engine.
"""

from logging.config import fileConfig
import asyncio
from sqlalchemy import pool
from sqlalchemy.engine import Connection
from sqlalchemy.ext.asyncio import async_engine_from_config
from alembic import context

# Import application configuration
from app.config import settings
from app.database import Base

# Import all models to ensure they're registered
from app.models import Customer, Conversation, Message

# this is the Alembic Config object
config = context.config

# Interpret the config file for Python logging.
if config.config_file_name is not None:
    fileConfig(config.config_file_name)

# Set SQLAlchemy URL from settings
config.set_main_option("sqlalchemy.url", settings.database_url)

# Add your model's MetaData object here for 'autogenerate' support
target_metadata = Base.metadata


def run_migrations_offline() -> None:
    """
    Run migrations in 'offline' mode.

    This configures the context with just a URL and not an Engine,
    though an Engine is also acceptable here. By skipping the Engine
    creation we don't even need a DBAPI to be available.

    Calls to context.execute() here emit the given string to the
    script output.
    """
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )

    with context.begin_transaction():
        context.run_migrations()


def do_run_migrations(connection: Connection) -> None:
    """
    Run migrations with given connection.

    Args:
        connection: SQLAlchemy connection
    """
    context.configure(
        connection=connection,
        target_metadata=target_metadata,
        compare_type=True,  # Detect column type changes
        compare_server_default=True,  # Detect default value changes
    )

    with context.begin_transaction():
        context.run_migrations()


async def run_async_migrations() -> None:
    """
    Run migrations in async mode.

    Creates an async engine and runs migrations.
    """
    # Create async engine from config
    connectable = async_engine_from_config(
        config.get_section(config.config_ini_section, {}),
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
    )

    async with connectable.connect() as connection:
        # Run migrations in sync context
        await connection.run_sync(do_run_migrations)

    # Dispose engine
    await connectable.dispose()


def run_migrations_online() -> None:
    """
    Run migrations in 'online' mode.

    In this scenario we need to create an Engine and associate
    a connection with the context.
    """
    asyncio.run(run_async_migrations())


# Determine offline vs online mode
if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()


FILE PATH: ./alembic/versions/f57c936ded09_initial_migration_create_customers_.py
--------------------
"""Initial migration: create customers, conversations, messages tables

Revision ID: f57c936ded09
Revises:
Create Date: 2025-12-14 18:31:52.625606

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = 'f57c936ded09'
down_revision: Union[str, None] = None
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('customers',
    sa.Column('first_name', sa.String(length=100), nullable=False, comment='Customer first name'),
    sa.Column('last_name', sa.String(length=100), nullable=False, comment='Customer last name'),
    sa.Column('email', sa.String(length=255), nullable=False, comment='Customer email address (unique)'),
    sa.Column('phone', sa.String(length=20), nullable=True, comment='Customer phone number'),
    sa.Column('customer_id', sa.String(length=50), nullable=False, comment='External customer ID from core banking system'),
    sa.Column('account_number', sa.String(length=50), nullable=True, comment='Primary account number'),
    sa.Column('is_active', sa.Boolean(), nullable=False, comment='Whether customer account is active'),
    sa.Column('is_verified', sa.Boolean(), nullable=False, comment='Whether customer identity is verified'),
    sa.Column('is_vip', sa.Boolean(), nullable=False, comment='VIP customer flag (premium service)'),
    sa.Column('notes', sa.Text(), nullable=True, comment='Internal notes about customer'),
    sa.Column('id', sa.Integer(), autoincrement=True, nullable=False, comment='Primary key'),
    sa.Column('created_at', sa.DateTime(timezone=True), nullable=False, comment='Record creation timestamp (UTC)'),
    sa.Column('updated_at', sa.DateTime(timezone=True), nullable=False, comment='Record last update timestamp (UTC)'),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index('idx_active_vip', 'customers', ['is_active', 'is_vip'], unique=False)
    op.create_index('idx_customer_name', 'customers', ['first_name', 'last_name'], unique=False)
    op.create_index(op.f('ix_customers_customer_id'), 'customers', ['customer_id'], unique=True)
    op.create_index(op.f('ix_customers_email'), 'customers', ['email'], unique=True)
    op.create_index(op.f('ix_customers_is_active'), 'customers', ['is_active'], unique=False)
    op.create_index(op.f('ix_customers_is_vip'), 'customers', ['is_vip'], unique=False)
    op.create_table('conversations',
    sa.Column('customer_id', sa.Integer(), nullable=False, comment='Foreign key to customer'),
    sa.Column('title', sa.String(length=200), nullable=False, comment='Conversation title/subject'),
    sa.Column('status', sa.Enum('ACTIVE', 'RESOLVED', 'ESCALATED', 'CLOSED', name='conversationstatus'), nullable=False, comment='Current conversation status'),
    sa.Column('channel', sa.Enum('WEB', 'MOBILE', 'API', 'WHATSAPP', 'SMS', name='conversationchannel'), nullable=False, comment='Communication channel'),
    sa.Column('summary', sa.Text(), nullable=True, comment='AI-generated conversation summary'),
    sa.Column('intent', sa.String(length=100), nullable=True, comment='Detected customer intent'),
    sa.Column('sentiment', sa.String(length=50), nullable=True, comment='Overall conversation sentiment'),
    sa.Column('message_count', sa.Integer(), nullable=False, comment='Total number of messages'),
    sa.Column('escalation_reason', sa.Text(), nullable=True, comment='Reason for escalation (if escalated)'),
    sa.Column('id', sa.Integer(), autoincrement=True, nullable=False, comment='Primary key'),
    sa.Column('created_at', sa.DateTime(timezone=True), nullable=False, comment='Record creation timestamp (UTC)'),
    sa.Column('updated_at', sa.DateTime(timezone=True), nullable=False, comment='Record last update timestamp (UTC)'),
    sa.ForeignKeyConstraint(['customer_id'], ['customers.id'], ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index('idx_channel_status', 'conversations', ['channel', 'status'], unique=False)
    op.create_index('idx_customer_status', 'conversations', ['customer_id', 'status'], unique=False)
    op.create_index('idx_intent', 'conversations', ['intent'], unique=False)
    op.create_index(op.f('ix_conversations_channel'), 'conversations', ['channel'], unique=False)
    op.create_index(op.f('ix_conversations_customer_id'), 'conversations', ['customer_id'], unique=False)
    op.create_index(op.f('ix_conversations_intent'), 'conversations', ['intent'], unique=False)
    op.create_index(op.f('ix_conversations_status'), 'conversations', ['status'], unique=False)
    op.create_table('messages',
    sa.Column('conversation_id', sa.Integer(), nullable=False, comment='Foreign key to conversation'),
    sa.Column('role', sa.Enum('CUSTOMER', 'AGENT', 'SYSTEM', 'HUMAN_AGENT', name='messagerole'), nullable=False, comment='Message sender role'),
    sa.Column('content', sa.Text(), nullable=False, comment='Message content/text'),
    sa.Column('agent_name', sa.String(length=100), nullable=True, comment='Name of AI agent that generated message (if role=agent)'),
    sa.Column('intent', sa.String(length=100), nullable=True, comment='Detected intent in customer message'),
    sa.Column('sentiment', sa.String(length=50), nullable=True, comment='Message sentiment (positive, negative, neutral)'),
    sa.Column('confidence_score', sa.Integer(), nullable=True, comment='Confidence score (0-100) for intent detection'),
    sa.Column('is_error', sa.Boolean(), nullable=False, comment='Whether message represents an error'),
    sa.Column('requires_human', sa.Boolean(), nullable=False, comment='Whether message requires human agent intervention'),
    sa.Column('metadata_json', sa.Text(), nullable=True, comment='Additional metadata as JSON string'),
    sa.Column('id', sa.Integer(), autoincrement=True, nullable=False, comment='Primary key'),
    sa.Column('created_at', sa.DateTime(timezone=True), nullable=False, comment='Record creation timestamp (UTC)'),
    sa.Column('updated_at', sa.DateTime(timezone=True), nullable=False, comment='Record last update timestamp (UTC)'),
    sa.ForeignKeyConstraint(['conversation_id'], ['conversations.id'], ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index('idx_conversation_created', 'messages', ['conversation_id', 'created_at'], unique=False)
    op.create_index('idx_conversation_intent', 'messages', ['conversation_id', 'intent'], unique=False)
    op.create_index('idx_requires_human', 'messages', ['requires_human'], unique=False)
    op.create_index('idx_role', 'messages', ['role'], unique=False)
    op.create_index(op.f('ix_messages_conversation_id'), 'messages', ['conversation_id'], unique=False)
    op.create_index(op.f('ix_messages_intent'), 'messages', ['intent'], unique=False)
    op.create_index(op.f('ix_messages_requires_human'), 'messages', ['requires_human'], unique=False)
    op.create_index(op.f('ix_messages_role'), 'messages', ['role'], unique=False)
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_index(op.f('ix_messages_role'), table_name='messages')
    op.drop_index(op.f('ix_messages_requires_human'), table_name='messages')
    op.drop_index(op.f('ix_messages_intent'), table_name='messages')
    op.drop_index(op.f('ix_messages_conversation_id'), table_name='messages')
    op.drop_index('idx_role', table_name='messages')
    op.drop_index('idx_requires_human', table_name='messages')
    op.drop_index('idx_conversation_intent', table_name='messages')
    op.drop_index('idx_conversation_created', table_name='messages')
    op.drop_table('messages')
    op.drop_index(op.f('ix_conversations_status'), table_name='conversations')
    op.drop_index(op.f('ix_conversations_intent'), table_name='conversations')
    op.drop_index(op.f('ix_conversations_customer_id'), table_name='conversations')
    op.drop_index(op.f('ix_conversations_channel'), table_name='conversations')
    op.drop_index('idx_intent', table_name='conversations')
    op.drop_index('idx_customer_status', table_name='conversations')
    op.drop_index('idx_channel_status', table_name='conversations')
    op.drop_table('conversations')
    op.drop_index(op.f('ix_customers_is_vip'), table_name='customers')
    op.drop_index(op.f('ix_customers_is_active'), table_name='customers')
    op.drop_index(op.f('ix_customers_email'), table_name='customers')
    op.drop_index(op.f('ix_customers_customer_id'), table_name='customers')
    op.drop_index('idx_customer_name', table_name='customers')
    op.drop_index('idx_active_vip', table_name='customers')
    op.drop_table('customers')
    # ### end Alembic commands ###
    # Drop ENUM types (PostgreSQL only)
    op.execute("DROP TYPE IF EXISTS conversationstatus CASCADE;")
    op.execute("DROP TYPE IF EXISTS conversationchannel CASCADE;")
    op.execute("DROP TYPE IF EXISTS messagerole CASCADE;")


FILE PATH: ./alembic/versions/536e165d8fe2_add_faq_table.py
--------------------
"""add_faq_table

Revision ID: 536e165d8fe2
Revises: f57c936ded09
Create Date: 2026-01-18 03:38:38.172294

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = '536e165d8fe2'
down_revision: Union[str, None] = 'f57c936ded09'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_index('ix_faqs_category', table_name='faqs')
    op.drop_index('ix_faqs_id', table_name='faqs')
    op.drop_index('ix_faqs_question', table_name='faqs')
    op.drop_table('faqs')
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('faqs',
    sa.Column('id', sa.INTEGER(), autoincrement=True, nullable=False),
    sa.Column('question', sa.VARCHAR(), autoincrement=False, nullable=False),
    sa.Column('answer', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('category', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('keywords', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('is_active', sa.BOOLEAN(), autoincrement=False, nullable=True),
    sa.PrimaryKeyConstraint('id', name='faqs_pkey')
    )
    op.create_index('ix_faqs_question', 'faqs', ['question'], unique=False)
    op.create_index('ix_faqs_id', 'faqs', ['id'], unique=False)
    op.create_index('ix_faqs_category', 'faqs', ['category'], unique=False)
    # ### end Alembic commands ###


FILE PATH: ./htmlcov/status.json
--------------------
{"note":"This file is an internal implementation detail to speed up HTML report generation. Its format can change at any time. You might be looking for the JSON report: https://coverage.rtfd.io/cmd.html#cmd-json","format":5,"version":"7.12.0","globals":"235bc110282c4fa5d34e4c46560aaa3f","files":{"z_5f5a17c013354698_config_py":{"hash":"3bc3a289c0e53af653f69b601878b3da","index":{"url":"z_5f5a17c013354698_config_py.html","file":"app/config.py","description":"","nums":{"precision":0,"n_files":1,"n_statements":99,"n_excluded":2,"n_missing":44,"n_branches":0,"n_partial_branches":0,"n_missing_branches":0}}},"z_5f5a17c013354698_database_py":{"hash":"09640a826e713aa91d97ce7fcbc909b3","index":{"url":"z_5f5a17c013354698_database_py.html","file":"app/database.py","description":"","nums":{"precision":0,"n_files":1,"n_statements":37,"n_excluded":17,"n_missing":22,"n_branches":0,"n_partial_branches":0,"n_missing_branches":0}}},"z_5f5a17c013354698_logger_py":{"hash":"eee15c1e002f5c2fe36e7796af5142a7","index":{"url":"z_5f5a17c013354698_logger_py.html","file":"app/logger.py","description":"","nums":{"precision":0,"n_files":1,"n_statements":69,"n_excluded":16,"n_missing":24,"n_branches":0,"n_partial_branches":0,"n_missing_branches":0}}},"z_5f5a17c013354698_main_py":{"hash":"259c23bed621209fd7fdb52456ecf65e","index":{"url":"z_5f5a17c013354698_main_py.html","file":"app/main.py","description":"","nums":{"precision":0,"n_files":1,"n_statements":49,"n_excluded":3,"n_missing":20,"n_branches":0,"n_partial_branches":0,"n_missing_branches":0}}},"z_6c0e4b930745278b_conversation_py":{"hash":"93c666fe6591c5e32c26c15655a66862","index":{"url":"z_6c0e4b930745278b_conversation_py.html","file":"app/models/conversation.py","description":"","nums":{"precision":0,"n_files":1,"n_statements":64,"n_excluded":8,"n_missing":20,"n_branches":0,"n_partial_branches":0,"n_missing_branches":0}}},"z_6c0e4b930745278b_customer_py":{"hash":"1ce81649f1c453d6d4ef3108de315cfd","index":{"url":"z_6c0e4b930745278b_customer_py.html","file":"app/models/customer.py","description":"","nums":{"precision":0,"n_files":1,"n_statements":30,"n_excluded":3,"n_missing":7,"n_branches":0,"n_partial_branches":0,"n_missing_branches":0}}},"z_6c0e4b930745278b_message_py":{"hash":"cc5871e4c9284e5aa1ad7ca7cc9bcb0a","index":{"url":"z_6c0e4b930745278b_message_py.html","file":"app/models/message.py","description":"","nums":{"precision":0,"n_files":1,"n_statements":40,"n_excluded":9,"n_missing":8,"n_branches":0,"n_partial_branches":0,"n_missing_branches":0}}},"z_4eed7ad336a4b97f_base_py":{"hash":"64fa50bb3390bd55f14844931d0e3b1e","index":{"url":"z_4eed7ad336a4b97f_base_py.html","file":"app/repositories/base.py","description":"","nums":{"precision":0,"n_files":1,"n_statements":83,"n_excluded":0,"n_missing":65,"n_branches":0,"n_partial_branches":0,"n_missing_branches":0}}},"z_4eed7ad336a4b97f_conversation_py":{"hash":"78b4eff3a0198ed75039331e9d779780","index":{"url":"z_4eed7ad336a4b97f_conversation_py.html","file":"app/repositories/conversation.py","description":"","nums":{"precision":0,"n_files":1,"n_statements":25,"n_excluded":0,"n_missing":13,"n_branches":0,"n_partial_branches":0,"n_missing_branches":0}}},"z_4eed7ad336a4b97f_customer_py":{"hash":"b6b860c05e3ca43c6b5d795615e7d68c","index":{"url":"z_4eed7ad336a4b97f_customer_py.html","file":"app/repositories/customer.py","description":"","nums":{"precision":0,"n_files":1,"n_statements":24,"n_excluded":0,"n_missing":12,"n_branches":0,"n_partial_branches":0,"n_missing_branches":0}}},"z_4eed7ad336a4b97f_message_py":{"hash":"3de64a15b3f8308c0a3dfca3d2f523fb","index":{"url":"z_4eed7ad336a4b97f_message_py.html","file":"app/repositories/message.py","description":"","nums":{"precision":0,"n_files":1,"n_statements":14,"n_excluded":0,"n_missing":5,"n_branches":0,"n_partial_branches":0,"n_missing_branches":0}}},"z_6549c0330f733809_health_py":{"hash":"7aaf9f4c56964397b436d919b0bf1ca1","index":{"url":"z_6549c0330f733809_health_py.html","file":"app/routers/health.py","description":"","nums":{"precision":0,"n_files":1,"n_statements":41,"n_excluded":0,"n_missing":14,"n_branches":0,"n_partial_branches":0,"n_missing_branches":0}}},"z_5f5a17c013354698_seed_py":{"hash":"f477c1f471ee911c9eb591628ca773a7","index":{"url":"z_5f5a17c013354698_seed_py.html","file":"app/seed.py","description":"","nums":{"precision":0,"n_files":1,"n_statements":77,"n_excluded":4,"n_missing":77,"n_branches":0,"n_partial_branches":0,"n_missing_branches":0}}},"z_c318f3fa19a49f69_base_py":{"hash":"c697002209e53028ffbde5fc7c6c7f50","index":{"url":"z_c318f3fa19a49f69_base_py.html","file":"app/services/base.py","description":"","nums":{"precision":0,"n_files":1,"n_statements":19,"n_excluded":0,"n_missing":9,"n_branches":0,"n_partial_branches":0,"n_missing_branches":0}}},"z_c318f3fa19a49f69_conversation_py":{"hash":"99a66ed3137e6b23d0b85e597e3c4c65","index":{"url":"z_c318f3fa19a49f69_conversation_py.html","file":"app/services/conversation.py","description":"","nums":{"precision":0,"n_files":1,"n_statements":44,"n_excluded":0,"n_missing":27,"n_branches":0,"n_partial_branches":0,"n_missing_branches":0}}},"z_c318f3fa19a49f69_customer_py":{"hash":"f004174b095929e84ad0f867ede6512f","index":{"url":"z_c318f3fa19a49f69_customer_py.html","file":"app/services/customer.py","description":"","nums":{"precision":0,"n_files":1,"n_statements":52,"n_excluded":0,"n_missing":31,"n_branches":0,"n_partial_branches":0,"n_missing_branches":0}}},"z_c318f3fa19a49f69_message_py":{"hash":"7623dc373a56b08d6e931a49bd265523","index":{"url":"z_c318f3fa19a49f69_message_py.html","file":"app/services/message.py","description":"","nums":{"precision":0,"n_files":1,"n_statements":28,"n_excluded":0,"n_missing":17,"n_branches":0,"n_partial_branches":0,"n_missing_branches":0}}},"z_c78f3e75ce3283c5_account_agent_py":{"hash":"09e7cf9bf6c9d96557b7c0b9b52f7cdc","index":{"url":"z_c78f3e75ce3283c5_account_agent_py.html","file":"app/agents/account_agent.py","description":"","nums":{"precision":0,"n_files":1,"n_statements":101,"n_excluded":0,"n_missing":89,"n_branches":0,"n_partial_branches":0,"n_missing_branches":0}}},"z_c78f3e75ce3283c5_base_py":{"hash":"6c585adc91577c260afb737dcd0ef461","index":{"url":"z_c78f3e75ce3283c5_base_py.html","file":"app/agents/base.py","description":"","nums":{"precision":0,"n_files":1,"n_statements":46,"n_excluded":46,"n_missing":27,"n_branches":0,"n_partial_branches":0,"n_missing_branches":0}}},"z_c78f3e75ce3283c5_compliance_checker_py":{"hash":"997960a2e76229febaf7b1ee720c5426","index":{"url":"z_c78f3e75ce3283c5_compliance_checker_py.html","file":"app/agents/compliance_checker.py","description":"","nums":{"precision":0,"n_files":1,"n_statements":101,"n_excluded":0,"n_missing":82,"n_branches":0,"n_partial_branches":0,"n_missing_branches":0}}},"z_c78f3e75ce3283c5_general_agent_py":{"hash":"4b3763fd82ce20aff9cc3a74d9160793","index":{"url":"z_c78f3e75ce3283c5_general_agent_py.html","file":"app/agents/general_agent.py","description":"","nums":{"precision":0,"n_files":1,"n_statements":29,"n_excluded":0,"n_missing":19,"n_branches":0,"n_partial_branches":0,"n_missing_branches":0}}},"z_c78f3e75ce3283c5_human_agent_py":{"hash":"ff1875e83db4a3d7a05f853e5a3736d2","index":{"url":"z_c78f3e75ce3283c5_human_agent_py.html","file":"app/agents/human_agent.py","description":"","nums":{"precision":0,"n_files":1,"n_statements":86,"n_excluded":0,"n_missing":64,"n_branches":0,"n_partial_branches":0,"n_missing_branches":0}}},"z_c78f3e75ce3283c5_intent_classifier_py":{"hash":"1847a3a40c215fe0d5c23b0e485885cb","index":{"url":"z_c78f3e75ce3283c5_intent_classifier_py.html","file":"app/agents/intent_classifier.py","description":"","nums":{"precision":0,"n_files":1,"n_statements":62,"n_excluded":0,"n_missing":46,"n_branches":0,"n_partial_branches":0,"n_missing_branches":0}}},"z_c78f3e75ce3283c5_product_recommender_py":{"hash":"0077c5df3209bb56e5ac4c5499385422","index":{"url":"z_c78f3e75ce3283c5_product_recommender_py.html","file":"app/agents/product_recommender.py","description":"","nums":{"precision":0,"n_files":1,"n_statements":85,"n_excluded":0,"n_missing":70,"n_branches":0,"n_partial_branches":0,"n_missing_branches":0}}},"z_f5d38b4fd357c032_message_workflow_py":{"hash":"d0bfdc523c89cfafddd40e4c562d63db","index":{"url":"z_f5d38b4fd357c032_message_workflow_py.html","file":"app/workflows/message_workflow.py","description":"","nums":{"precision":0,"n_files":1,"n_statements":135,"n_excluded":0,"n_missing":102,"n_branches":0,"n_partial_branches":0,"n_missing_branches":0}}},"z_517fd9267c132944_agent_coordinator_py":{"hash":"eb5177f0b4d1d439a68f9d9feeeea85c","index":{"url":"z_517fd9267c132944_agent_coordinator_py.html","file":"app/coordinator/agent_coordinator.py","description":"","nums":{"precision":0,"n_files":1,"n_statements":111,"n_excluded":0,"n_missing":79,"n_branches":0,"n_partial_branches":0,"n_missing_branches":0}}},"z_7bced6e93b6b263d_messages_py":{"hash":"5a4162364bf20e0c1890bef9ec66f136","index":{"url":"z_7bced6e93b6b263d_messages_py.html","file":"app/api/routes/messages.py","description":"","nums":{"precision":0,"n_files":1,"n_statements":110,"n_excluded":0,"n_missing":55,"n_branches":0,"n_partial_branches":0,"n_missing_branches":0}}},"z_6c0e4b930745278b_product_py":{"hash":"fa433c5a8e9dece63ebbf56a147d5d75","index":{"url":"z_6c0e4b930745278b_product_py.html","file":"app/models/product.py","description":"","nums":{"precision":0,"n_files":1,"n_statements":11,"n_excluded":2,"n_missing":0,"n_branches":0,"n_partial_branches":0,"n_missing_branches":0}}},"z_6c0e4b930745278b_account_py":{"hash":"c0c55f8ceeceba856b793af31a30be15","index":{"url":"z_6c0e4b930745278b_account_py.html","file":"app/models/account.py","description":"","nums":{"precision":0,"n_files":1,"n_statements":25,"n_excluded":2,"n_missing":0,"n_branches":0,"n_partial_branches":0,"n_missing_branches":0}}},"z_6c0e4b930745278b_transaction_py":{"hash":"2bf63763bf90b6bbf03b8a841a6a44d7","index":{"url":"z_6c0e4b930745278b_transaction_py.html","file":"app/models/transaction.py","description":"","nums":{"precision":0,"n_files":1,"n_statements":15,"n_excluded":2,"n_missing":0,"n_branches":0,"n_partial_branches":0,"n_missing_branches":0}}},"z_4eed7ad336a4b97f_product_py":{"hash":"9ad608521a393b1a8e6a69f78ce9a67f","index":{"url":"z_4eed7ad336a4b97f_product_py.html","file":"app/repositories/product.py","description":"","nums":{"precision":0,"n_files":1,"n_statements":14,"n_excluded":0,"n_missing":5,"n_branches":0,"n_partial_branches":0,"n_missing_branches":0}}},"z_4eed7ad336a4b97f_account_py":{"hash":"14a6ba840a685879cee0390c59a47708","index":{"url":"z_4eed7ad336a4b97f_account_py.html","file":"app/repositories/account.py","description":"","nums":{"precision":0,"n_files":1,"n_statements":14,"n_excluded":0,"n_missing":5,"n_branches":0,"n_partial_branches":0,"n_missing_branches":0}}},"z_4eed7ad336a4b97f_transaction_py":{"hash":"9fb85dc90bef702138e4bb7e2f90ae03","index":{"url":"z_4eed7ad336a4b97f_transaction_py.html","file":"app/repositories/transaction.py","description":"","nums":{"precision":0,"n_files":1,"n_statements":11,"n_excluded":0,"n_missing":3,"n_branches":0,"n_partial_branches":0,"n_missing_branches":0}}},"z_c318f3fa19a49f69_product_service_py":{"hash":"8c5df2c88d506472e1de96c8f1204e40","index":{"url":"z_c318f3fa19a49f69_product_service_py.html","file":"app/services/product_service.py","description":"","nums":{"precision":0,"n_files":1,"n_statements":18,"n_excluded":0,"n_missing":6,"n_branches":0,"n_partial_branches":0,"n_missing_branches":0}}},"z_c318f3fa19a49f69_account_service_py":{"hash":"de369b8b91cd8632a099e9e81c6c177c","index":{"url":"z_c318f3fa19a49f69_account_service_py.html","file":"app/services/account_service.py","description":"","nums":{"precision":0,"n_files":1,"n_statements":19,"n_excluded":0,"n_missing":7,"n_branches":0,"n_partial_branches":0,"n_missing_branches":0}}},"z_c318f3fa19a49f69_transaction_service_py":{"hash":"7aa3ab31e6de8faae95cc6a0e189853d","index":{"url":"z_c318f3fa19a49f69_transaction_service_py.html","file":"app/services/transaction_service.py","description":"","nums":{"precision":0,"n_files":1,"n_statements":16,"n_excluded":0,"n_missing":5,"n_branches":0,"n_partial_branches":0,"n_missing_branches":0}}},"z_5f5a17c013354698_seed_database_py":{"hash":"aa2dd1b98b71d22a88a1d7825d392755","index":{"url":"z_5f5a17c013354698_seed_database_py.html","file":"app/seed_database.py","description":"","nums":{"precision":0,"n_files":1,"n_statements":299,"n_excluded":12,"n_missing":299,"n_branches":0,"n_partial_branches":0,"n_missing_branches":0}}},"z_6549c0330f733809_admin_py":{"hash":"1c7dbb6328070ce3304c0bab9a78d20d","index":{"url":"z_6549c0330f733809_admin_py.html","file":"app/routers/admin.py","description":"","nums":{"precision":0,"n_files":1,"n_statements":27,"n_excluded":0,"n_missing":12,"n_branches":0,"n_partial_branches":0,"n_missing_branches":0}}},"z_6c0e4b930745278b_faq_py":{"hash":"5b9e8a766220c7636a9650402193a1fc","index":{"url":"z_6c0e4b930745278b_faq_py.html","file":"app/models/faq.py","description":"","nums":{"precision":0,"n_files":1,"n_statements":10,"n_excluded":0,"n_missing":0,"n_branches":0,"n_partial_branches":0,"n_missing_branches":0}}},"z_4eed7ad336a4b97f_faq_py":{"hash":"37ebdf4829eea71423184acbdb57c31c","index":{"url":"z_4eed7ad336a4b97f_faq_py.html","file":"app/repositories/faq.py","description":"","nums":{"precision":0,"n_files":1,"n_statements":12,"n_excluded":0,"n_missing":4,"n_branches":0,"n_partial_branches":0,"n_missing_branches":0}}},"z_c318f3fa19a49f69_faq_service_py":{"hash":"acc9f6e32baa3802f44b4131aae62648","index":{"url":"z_c318f3fa19a49f69_faq_service_py.html","file":"app/services/faq_service.py","description":"","nums":{"precision":0,"n_files":1,"n_statements":16,"n_excluded":0,"n_missing":5,"n_branches":0,"n_partial_branches":0,"n_missing_branches":0}}},"z_5f5a17c013354698_debug_wiring_py":{"hash":"3de130ccffe62ab86e1689aabde0b9ff","index":{"url":"z_5f5a17c013354698_debug_wiring_py.html","file":"app/debug_wiring.py","description":"","nums":{"precision":0,"n_files":1,"n_statements":43,"n_excluded":2,"n_missing":43,"n_branches":0,"n_partial_branches":0,"n_missing_branches":0}}},"z_5f5a17c013354698_verify_full_workflow_py":{"hash":"18e1118cf9226b8d4f061914e64513c4","index":{"url":"z_5f5a17c013354698_verify_full_workflow_py.html","file":"app/verify_full_workflow.py","description":"","nums":{"precision":0,"n_files":1,"n_statements":32,"n_excluded":2,"n_missing":32,"n_branches":0,"n_partial_branches":0,"n_missing_branches":0}}}}}

